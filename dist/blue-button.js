require = (function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw (f.code = "MODULE_NOT_FOUND", f) } var l = n[o] = { exports: {} }; t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++)s(r[o]); return s })({
  1: [function (require, module, exports) {
    "use strict";

    var parseCMS = require("@amida-tech/blue-button-cms");
    var parseNCPDP;
    var _ = require('lodash');

    try {
      parseNCPDP = require("@amida-tech/blue-button-ncpdp").parseXml;
    } catch (ex) {
      parseNCPDP = null;
    }

    var componentRouter = require("./parser/router").componentRouter;
    var xmlParser = require("@amida-tech/blue-button-xml").xmlUtil;
    var util = require("util");
    var sense = require("./sense.js");

    //add model/package version to metadata
    var version = require("../package.json").version;

    //insert sections list into metadata
    function sections(data) {
      if (!data.meta) {
        data.meta = {};
      }

      if (data.data.meta) {
        _.extend(data.meta, data.data.meta);
        delete data.data.meta;
      }
      data.meta.sections = Object.keys(data.data);
      return data;
    }

    function parseText(txt) {
      //txt must be a string
      if (!txt || typeof (txt) !== "string") {
        //TODO: throw a proper error here
        return null;
      }

      return sections(parseCMS.parseText(txt));
    }

    function parseXml(doc, options, sensed) {
      //data must be an object
      if (!doc || typeof (doc) !== "object") {
        //TODO: throw a proper error here
        return null;
      }

      if (arguments.length === 1) {
        options = {};
      }

      if (!sensed) {
        sensed = sense.senseXml(doc);
      }

      var componentParser = componentRouter(options.component, sensed);

      if (!componentParser) {
        var msg = util.format("Component %s is not supported.", options.component);
        //callback(new Error(msg)); //TODO:revise this use of callbacks
        return {
          "errors": new Error(msg)
        };
      }
      var ret = componentParser.instance();

      ret.run(doc, options.sourceKey);
      ret.cleanupTree(options.sourceKey); // first build the data objects up
      return sections({
        "data": ret.toJSON(),
        "meta": {
          "version": version
        },
        "errors": ret.errors
      });
    }

    function parseString(data, options) {
      //data must be a string
      if (!data || typeof (data) !== "string") {
        //TODO: throw a proper error here
        return null;
      }

      if (arguments.length === 1) {
        options = {};
      }

      var doc = xmlParser.parse(data);
      return parseXml(doc, options);
    }

    var parse = function (data, options) {
      //data must be a string
      if (!data || typeof (data) !== "string") {
        //TODO: throw a proper error here
        return null;
      }

      if (arguments.length === 1) {
        options = {};
      }

      var sensed = sense.senseString(data);

      if (sensed) {
        if (sensed.xml) {
          if (sensed.type === 'ncpdp' && parseNCPDP) {
            return parseNCPDP(sensed.xml);
          }
          return parseXml(sensed.xml, options, sensed);
        } else if (sensed.json) {
          return sensed.json;
        } else {
          return parseText(data);
        }
      } else {
        return null;
      }
    };

    module.exports = {
      parse: parse,
      parseXml: parseXml,
      parseString: parseString,
      parseText: parseText
    };

  }, { "../package.json": 96, "./parser/router": 43, "./sense.js": 44, "blue-button-cms": "blue-button-cms", "blue-button-ncpdp": undefined, "blue-button-xml": "blue-button-xml", "lodash": 95, "util": 94 }], 2: [function (require, module, exports) {
    "use strict";

    var component = require("@amida-tech/blue-button-xml").component;
    var shared = require("./shared");

    var exportC32 = function (version) {
      var patient = require("./demographics").patient;
      var allergiesSection = require("./sections/allergies").allergiesSection(version)[0];
      var vitalSignsSection = require("./sections/vitals").vitalSignsSection(version)[0];
      var resultsSection = require("./sections/results").resultsSection(version)[0];
      var problemsSection = require("./sections/problems").problemsSection(version)[0];
      var proceduresSection = require("./sections/procedures").proceduresSection(version)[0];
      var immunizationsSection = require("./sections/immunizations").immunizationsSection(version)[0];
      var medicationsSection = require("./sections/medications").medicationsSection(version)[0];
      var encountersSection = require("./sections/encounters").encountersSection(version)[0];
      return component.define("C32")
        .fields([
          ["meta", "0..1", ".", shared.metaData],
          ["demographics", "1..1", "(/ | //h:recordTarget/h:patientRole)[last()]", patient],
          ["allergies", "0..1", allergiesSection.xpath(), allergiesSection],
          ["encounters", "0..1", encountersSection.xpath(), encountersSection],
          ["immunizations", "0..1", immunizationsSection.xpath(), immunizationsSection],
          ["medications", "0..1", medicationsSection.xpath(), medicationsSection],
          ["problems", "0..1", problemsSection.xpath(), problemsSection],
          ["procedures", "0..1", proceduresSection.xpath(), proceduresSection],
          ["vitals", "0..1", vitalSignsSection.xpath(), vitalSignsSection],
          ["results", "0..1", resultsSection.xpath(), resultsSection]
        ]);

    };

    exports.C32 = exportC32;

  }, { "./demographics": 4, "./sections/allergies": 5, "./sections/encounters": 6, "./sections/immunizations": 7, "./sections/medications": 8, "./sections/problems": 9, "./sections/procedures": 10, "./sections/results": 11, "./sections/vitals": 12, "./shared": 13, "blue-button-xml": "blue-button-xml" }], 3: [function (require, module, exports) {
    "use strict";

    var includeCleanup = require("../common/cleanup");

    var cleanup = module.exports = Object.create(includeCleanup);

    var _ = require("lodash");

    cleanup.augmentObservation = function () {

      if (_.get(this, "js.problem_text") && _.get(this, "js.problem_text.js")) {
        if (!_.get(this, "js.code.js.name")) {
          this.js.code.js.name = this.js.problem_text.js;
        }
      }

    };

  }, { "../common/cleanup": 41, "lodash": 95 }], 4: [function (require, module, exports) {
    "use strict";

    var shared = require('./shared');
    var processor = require("@amida-tech/blue-button-xml").processor;
    var component = require("@amida-tech/blue-button-xml").component;

    var Guardian = component.define("Guardian")
      .fields([
        ["relation", "0..1", "h:code", shared.SimplifiedCode],
        ["addresses", "0..*", "h:addr", shared.Address],
        ["names", "1..*", "h:guardianPerson/h:name", shared.IndividualName],
        ["phone", "0..*", shared.phone.xpath(), shared.phone],
        ["email", "0..*", shared.email.xpath(), shared.email],
      ]);

    var LanguageCommunication = component.define("LanguageCommunication")
      .fields([
        ["language", "1..1", "h:languageCode/@code"],
        ["preferred", "1..1", "h:preferenceInd/@value", processor.asBoolean],
        ["mode", "0..1", "h:modeCode", shared.SimplifiedCode],
        ["proficiency", "0..1", "h:proficiencyLevelCode", shared.SimplifiedCode]
      ]);

    exports.patient = component.define("Patient")
      .fields([
        ["name", "1..1", "h:patient/h:name", shared.IndividualName],
        ["dob", "1..1", "h:patient/h:birthTime", shared.EffectiveTime],
        ["gender", "1..1", "h:patient/h:administrativeGenderCode", shared.SimplifiedCode],
        ["identifiers", "1..*", "h:id", shared.Identifier],
        ["marital_status", "0..1", "h:patient/h:maritalStatusCode", shared.SimplifiedCode],
        ["addresses", "0..*", "h:addr", shared.Address],
        ["phone", "0..*", shared.phone.xpath(), shared.phone],
        ["email", "0..*", shared.email.xpath(), shared.email],
        ["race", "0..1", "h:patient/h:raceCode", shared.simplifiedCodeOID("2.16.840.1.113883.6.238")],
        ["ethnicity", "0..1", "h:patient/h:ethnicGroupCode", shared.simplifiedCodeOID("2.16.840.1.113883.6.238")],
        ["languages", "0..*", "h:patient/h:languageCommunication", LanguageCommunication],
        ["religion", "0..1", "h:patient/h:religiousAffiliationCode/@code", shared.SimpleCode("2.16.840.1.113883.5.1076")],
        ["birthplace", "0..1", "h:patient/h:birthplace/h:place/h:addr", shared.Address],
        ["guardians", "0..*", "h:patient/h:guardian", Guardian]
      ]);

  }, { "./shared": 13, "blue-button-xml": "blue-button-xml" }], 5: [function (require, module, exports) {
    "use strict";

    // NOTE: allergies section not present in ccda-r1.0, so just kept
    // templateIds hard-coded with ccda-r1.1 values
    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var processor = require("@amida-tech/blue-button-xml").processor;
    var _ = require("lodash");

    var exportAllergiesSection = function (version) {

      var allergySeverityObservation = component.define("allergySeverityObservation")
        .fields([

          //VA Mod, per file no coding, so shim into code name.
          //["code", "0..1", "h:value", shared.ConceptDescriptor],
          ["code.name", "0..1", "h:text", shared.TextWithReference]
          //Interpretation not in C32 Spec.
          //["interpretation", "0..1", "h:interpretationCode", shared.ConceptDescriptor]
        ]);

      var allergyReaction = component.define("allergyReaction");
      allergyReaction.templateRoot(["2.16.840.1.113883.10.20.1.54"]);
      allergyReaction.fields([
        ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
        ["reaction.name", "1..1", "h:text", shared.TextWithReference],
        //Reaction Severity not included in C32 Spec.
        //["severity", "0..1", "h:entryRelationship/h:observation", allergySeverityObservation]
      ]);

      var allergenDescriptor = component.define('allergenDescriptor');
      allergenDescriptor.fields([

        ["name", "0..1", "h:name/text()"],
        ["code", "0..1", "h:code", shared.ConceptDescriptor]
      ]).cleanupStep(function () {

        //Custom VA C32 Shim.
        if (_.get(this, "js.code")) {
          if (_.get(this, "js.code.js.name") === "Coded Allergy Name Not Available") {
            delete this.js.code;
          }
        }

      });

      /*
      var allergyStatusObservation = component.define("allergyStatusObservation");
      allergyStatusObservation.fields([
          ["code", "0..1", "@code"],
          ["status", "0..1", "@code", shared.SimpleCode("2.16.840.1.113883.3.88.12.80.68")],
      ]);
      */

      var allergyObservation = component.define("allergyObservation"); // this is status observation
      allergyObservation.templateRoot(["2.16.840.1.113883.10.20.1.18"]);
      allergyObservation.fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        //NOTE: Negation Id (per PragueExpat)
        ["negation_indicator", "0..1", "./@negationInd", processor.asBoolean],
        //NOTE allergen must be optional in case of negationInd = true (per PragueExpat)
        ["allergen", "0..1", "h:participant/h:participantRole/h:playingEntity", allergenDescriptor], // (see above) - was 1..1 //Require (optional in spec)

        ["intolerance", "0..1", "h:code", shared.ConceptDescriptor],
        ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],

        //Status not included on C32.
        //["status", "0..1", "h:entryRelationship/h:observation[h:templateId/@root='2.16.840.1.113883.10.20.22.4.28']/h:value", shared.ConceptDescriptor],
        ["reactions", "0..*", allergyReaction.xpath(), allergyReaction],
        ["severity", "0..1", "h:entryRelationship/h:observation[h:templateId/@root='2.16.840.1.113883.10.20.1.55']", allergySeverityObservation]
      ]);

      var problemAct = component.define('problemAct');
      problemAct.templateRoot(['2.16.840.1.113883.3.88.11.83.6']);
      problemAct.fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
        ["problemStatus", "1..1", "h:statusCode/@code"],
        ["observation", "1..1", allergyObservation.xpath(), allergyObservation] // Ignore observation cardinality (in spec can be more than 1)
      ]);
      problemAct.cleanupStep(cleanup.allergiesProblemStatusToHITSP);

      var allergiesSection = component.define('allergiesSection');
      allergiesSection.templateRoot(['2.16.840.1.113883.3.88.11.83.102']);
      allergiesSection.fields([
        ["problemAct", "1..*", problemAct.xpath(), problemAct]
      ]);
      allergiesSection.cleanupStep(cleanup.replaceWithField(["problemAct"]));

      return [allergiesSection, problemAct];
    };
    exports.allergiesSection = exportAllergiesSection;
    exports.allergiesEntry = exportAllergiesSection;

  }, { "../cleanup": 3, "../shared": 13, "blue-button-xml": "blue-button-xml", "lodash": 95 }], 6: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportEncountersSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      /*var finding = component.define("finding");
      finding.templateRoot([clinicalStatementsIDs.Indication]);
      finding.fields([
          ["identifiers", "1..*", "h:id", shared.Identifier],
          ["value", "1..1", "h:value", shared.ConceptDescriptor],
          ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime]
      ]);*/
      //finding.cleanupStep(cleanup.extractAllFields(['value']));

      // Iff needed add this later by refactoring Problem Observation from Problems.  They should share.
      //var diagnosis = component.define("diagnosis");
      //finding.templateRoot(['2.16.840.1.113883.10.20.22.4.80']);
      //finding.fields([
      //  ["code", "1..1", "h:code", shared.ConceptDescriptor]
      //]);
      //finding.cleanupStep(cleanup.extractAllFields(['code']));

      var activity = component.define('activity');
      activity.templateRoot(["2.16.840.1.113883.10.20.1.2", "2.16.840.1.113883.3.88.11.83.16"]);
      activity.fields([
        ["encounter", "1..1", "h:code", shared.ConceptDescriptor],
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
        ["performers", "0..*", "h:performer/h:assignedEntity", shared.assignedEntity],
        ["locations", "0..*", "h:participant/h:participantRole", shared.serviceDeliveryLocation]

        //No findings in C32 Spec.
        //["findings", "0..*", finding.xpath(), finding] //,
        //["diagnoses", "0..*", diagnosis.xpath(), diagnosis]
      ]);

      var encountersSection = component.define('encountersSection');
      encountersSection.templateRoot(["2.16.840.1.113883.3.88.11.83.127", "1.3.6.1.4.1.19376.1.5.3.1.1.5.3.3"]);
      encountersSection.fields([
        ["activity", "0..*", activity.xpath(), activity]
      ]);
      encountersSection.cleanupStep(cleanup.replaceWithField(["activity"]));
      return [encountersSection, activity];
    };
    exports.encountersSection = exportEncountersSection;
    exports.encountersEntry = exportEncountersSection;

  }, { "../cleanup": 3, "../shared": 13, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 7: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");
    var _ = require("lodash");

    var augmentImmunizationStatus = function () {
      var tmpStatus = "";
      if (_.get(this, 'js.negation_ind') === "true") {
        tmpStatus = "refused";
      } else if (_.get(this, 'js.mood_code') === "INT") {
        tmpStatus = "pending";
      } else if (_.get(this, 'js.mood_code') === "EVN") {
        tmpStatus = "complete";
      } else {
        tmpStatus = "unknown";
      }
      this.js = tmpStatus;
    };

    var exportImmunizationsSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      var ImmunizationStatus = component.define("ImmunizationStatus")
        .fields([
          ["mood_code", "0..1", "./@moodCode"],
          ["negation_ind", "0..1", "./@negationInd"],
        ]).cleanupStep(augmentImmunizationStatus);

      var ImmunizationAdministration = component.define("ImmunizationAdministration")
        .fields([
          ["route", "0..1", "h:routeCode", shared.ConceptDescriptor],
          ["body_site", "0..1", "h:approachSiteCode", shared.ConceptDescriptor],
          ["dose", "0..1", "h:doseQuantity", shared.PhysicalQuantity],
          ["form", "0..1", "h:administrationUnitCode", shared.ConceptDescriptor]
        ]);

      var ImmunizationInstructions = component.define("MedicationInstructions")
        .fields([
          ["code", "0..1", "h:code", shared.ConceptDescriptor],
          ["free_text", "0..1", "h:text", shared.TextWithReference]
        ]);

      var immunizationActivityProduct = component.define('immunizationActivityProduct')
        .fields([
          ["product", "1..1", "h:manufacturedMaterial/h:code", shared.ConceptDescriptor],
          ["lot_number", "0..1", "h:manufacturedMaterial/h:lotNumberText"],
          ["manufacturer", "0..1", "h:manufacturerOrganization/h:name"],
        ]);

      var ImmunizationActivity = component.define("ImmunizationActivity")
        .templateRoot(["2.16.840.1.113883.3.88.11.83.13"])
        .fields([
          ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["status", "0..1", "./../h:substanceAdministration", ImmunizationStatus],
          ["sequence_number", "0..1", "h:entryRelationship[@typeCode='SUBJ']/h:observation/h:value"],
          ["product", "0..1", "h:consumable/h:manufacturedProduct", immunizationActivityProduct],
          ["administration", "0..1", "./../h:substanceAdministration", ImmunizationAdministration],
          ["performer", "0..1", "h:performer/h:assignedEntity", shared.assignedEntity],
          //Not in C32 Spec.
          //["instructions", "0..1", "h:entryRelationship[@typeCode='RSON']/h:act", ImmunizationInstructions],
          ["refusal_reason", "0..1", "h:entryRelationship[@typeCode='RSON']/h:act", shared.SimpleCode("2.16.840.1.113883.10.20.1.27")],
        ]);

      var immunizationsSection = component.define("immunizationsSection");
      immunizationsSection.templateRoot(["2.16.840.1.113883.3.88.11.83.117", "1.3.6.1.4.1.19376.1.5.3.1.3.23"]);
      immunizationsSection.fields([
        ["immunizations", "0..*", ImmunizationActivity.xpath(), ImmunizationActivity]
      ]);

      immunizationsSection.cleanupStep(cleanup.replaceWithField('immunizations'));

      return [immunizationsSection, ImmunizationActivity];
    };

    exports.immunizationsSection = exportImmunizationsSection;
    exports.immunizationsEntry = exportImmunizationsSection;

  }, { "../cleanup": 3, "../shared": 13, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml", "lodash": 95 }], 8: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var processor = require("@amida-tech/blue-button-xml").processor;
    var bbm = require("@amida-tech/blue-button-meta");
    var _ = require("lodash");

    var exportMedicationsSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      var MedicationInterval = component.define("MedicationInterval")
        .fields([
          ["phase", "0..1", "./h:phase", shared.EffectiveTime],
          ["period", "0..1", "./h:period", shared.PhysicalQuantity],
          ["alignment", "0..1", "./@alignment"],
          ["frequency", "0..1", "./@institutionSpecified", processor.asBoolean],
          ["event", "0..1", "./h:event/@code", shared.SimpleCode("2.16.840.1.113883.5.139")],
          ["event_offset", "0..1", "./h:offset", shared.EventOffset]
        ]);

      var MedicationAdministration = component.define("MedicationAdministration")
        .fields([
          ["route", "0..1", "h:routeCode", shared.ConceptDescriptor],
          ["site", "0..1", "h:approachSiteCode", shared.ConceptDescriptor],
          ["form", "0..1", "h:administrationUnitCode", shared.ConceptDescriptor],
          //["dose", "0..1", "h:doseQuantity", shared.PhysicalQuantity],
          ["rate", "0..1", "h:rateQuantity", shared.PhysicalQuantity],
          ["dose_restriction", "0..1", "h:maxDoseQuantity", shared.PhysicalQuantity],
          //["interval", "0..1", "h:effectiveTime[@operator='A']", MedicationInterval],
        ]);

      var MedicationIndication = component.define("MedicationIndication")
        .fields([
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["code", "0..1", "h:code", shared.ConceptDescriptor],
          ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
          ["value", "0..1", "h:value", shared.ConceptDescriptor]
        ]);

      var MedicationPrecondition = component.define("MedicationPrecondition")
        .fields([
          ["code", "0..1", "h:code", shared.ConceptDescriptor],
          ["text", "0..1", "h:text"],
          ["value", "0..1", "h:value", shared.ConceptDescriptor]
        ]);

      var author = component.define("author")
        .fields([
          ["date_time", "0..1", "h:time", shared.EffectiveTime],
          ["identifiers", "0..*", "h:assignedAuthor/h:id", shared.Identifier],
          [version === "" ? "name" : "organization", "0..1",
            "(h:assignedAuthor/h:representedOrganization | h:assignedAuthor/h:assignedPerson/h:name)[last()]", (version === "" ? shared.IndividualName : shared.Organization)
          ]
        ]);

      var MedicationInformation = component.define("MedicationInformation")
        .templateRoot("2.16.840.1.113883.10.20.22.4.23")
        .fields([
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["unencoded_name", "0..1", "h:manufacturedMaterial/h:code/h:originalText", shared.TextWithReference],
          ["product", "1..1", "h:manufacturedMaterial/h:code", shared.ConceptDescriptor],
          ["manufacturer", "0..1", "h:manufacturerOrganization/h:name"]
        ]);

      var MedicationSupplyOrder = component.define("MedicationSupplyOrder")
        .fields([
          ["identifiers", "0..*", "h:assignedEntity/h:id", shared.Identifier],
          ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
          ["repeatNumber", "0..1", "h:repeatNumber/@value"],
          ["quantity", "0..1", "h:quantity/@value"],
          ["status", "0..1", "h:status/@code"],
          ["author", "0..1", "h:author", author] //, instructions use references, which are not supported (also samples don't have good data for it)
          //["instructions", "0..1", "h:entryRelationship[@typeCode='SUBJ']/h:act", MedicationInstructions]
        ]);

      var MedicationPerformer = component.define("MedicationPerformer")
        .fields([
          ["identifiers", "0..*", "h:assignedEntity/h:id", shared.Identifier],
          ["address", "0..*", "h:assignedEntity/h:addr", shared.Address],
          ["phone", "0..1", "h:assignedEntity/" + shared.phone.xpath(), shared.phone],
          ["organization", "0..*", "h:assignedEntity/h:representedOrganization", shared.Organization]
        ]);
      /*
          var MedicationDrugVehicle = component.define("MedicationDrugVehicle")
              .templateRoot("2.16.840.1.113883.10.20.22.4.24")
              .fields([
                  ["playingEntity", "0..1", "h:playingEntity/h:code", shared.ConceptDescriptor]
              ]).cleanupStep(cleanup.extractAllFields(["drug_vehicle"]));
  */
      var MedicationInstructions = component.define("MedicationInstructions")
        .fields([
          ["code", "0..1", "../h:code", shared.ConceptDescriptor],
          ["freeText", "0..1", "../h:text", shared.TextWithReference]
        ]);

      var MedicationDispense = component.define("MedicationDispense")
        .templateRoot("2.16.840.1.113883.10.20.22.4.18")
        .fields([
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["performer", "0..1", "h:performer", MedicationPerformer],
          ["supply", "0..1", "h:entryRelationship[@typeCode='REFR']/h:supply", MedicationSupplyOrder]
        ]);

      var MedicationActivity = component.define("MedicationActivity")
        .templateRoot("2.16.840.1.113883.3.88.11.83.8")
        .fields([
          ["date_time", "0..1", "h:effectiveTime[not (@operator='A')]", shared.EffectiveTime],
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["status", "1..1", "./../h:substanceAdministration/@moodCode"],
          ["sig", "0..1", "h:text", shared.TextWithReference],
          ["product", "1..1", "h:consumable/h:manufacturedProduct", MedicationInformation],
          ["supply", "0..1", "h:entryRelationship[@typeCode='REFR']/h:supply", MedicationSupplyOrder],
          ["administration", "0..1", "../h:substanceAdministration", MedicationAdministration],
          ["performer", "0..1", "h:performer", MedicationPerformer],
          ["drug_vehicle", "0..1", "h:participant[@typeCode='CSM']/h:participantRole/h:playingEntity[@classCode='MMAT']/h:code", shared.ConceptDescriptor],
          ["precondition", "1..1", "h:precondition/h:criterion", MedicationPrecondition],
          ["indication", "0..1", "h:entryRelationship[@typeCode='RSON']/h:observation", MedicationIndication],
          //["instructions", "0..1", "h:entryRelationship[@typeCode='REFR']/h:supply/*/*/h:templateId[@root='2.16.840.1.113883.10.20.22.4.20']", MedicationInstructions],
          ["dispense", "0..1", MedicationDispense.xpath(), MedicationDispense]
        ])
        //.cleanupStep(Cleanup.extractAllFields(["medicationName"]))
        .cleanupStep(function () {

          this.js.identifiers = _.filter(this.js.identifiers, function (identifier) {
            if (identifier) {
              if (identifier.js === null) {
                return false;
              } else {
                return true;
              }
            } else {
              return false;
            }
          });

          //Cleanup Status.

          if (_.get(this, "js.status") === "EVN") {
            this.js.status = "Completed";
          }
          if (_.get(this, "js.status") === "INT") {
            this.js.status = "Prescribed";
          }

          // separate out two effectiveTimes

          /*
        // 1.  startDate --- endDate
        var range = this.js.times.filter(function(t){
          return -1 === ['PIVL_TS', 'EIVL_TS'].indexOf(t.js.xsitype);
        });

        // 2.  dosing interval
        var period= this.js.times.filter(function(t){
          return -1 !== ['PIVL_TS', 'EIVL_TS'].indexOf(t.js.xsitype);
        });

        delete this.js.times;

        if (range.length > 0) {
          this.js.dateRange = range[0];
        }

        if (period.length > 0) {
          this.js.dosePeriod = period[0].js.period;
        }*/

        });

      var medicationsSection = component.define("medicationsSection");
      medicationsSection.templateRoot(["2.16.840.1.113883.3.88.11.83.112", "1.3.6.1.4.1.19376.1.5.3.1.3.19"]);
      medicationsSection.fields([
        ["medications", "0..*", MedicationActivity.xpath(), MedicationActivity]
      ]);
      medicationsSection.cleanupStep(cleanup.replaceWithField('medications'));
      return [medicationsSection, MedicationActivity];

    };

    exports.medicationsSection = exportMedicationsSection;
    exports.medicationsEntry = exportMedicationsSection;

  }, { "../cleanup": 3, "../shared": 13, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml", "lodash": 95 }], 9: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportProblemsSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      //These three elements aren't used right now, but can be refactored to use in standardized way.
      var AgeObservation = component.define("AgeObservation")
        .templateRoot("2.16.840.1.113883.10.20.1.38");

      var ProblemStatus = component.define("ProblemStatus")
        .templateRoot("2.16.840.1.113883.10.20.1.50")
        .fields([
          ["name", "0..1", "h:value/@displayName"],
          ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
        ]);

      var ProblemObservation = component.define("ProblemObservation")
        .fields([
          ["code", "0..1", "../h:value", shared.ConceptDescriptor],
          ["problem_text", "0..1", "../h:text", shared.TextWithReference],
          ["date_time", "0..1", "../h:effectiveTime", shared.EffectiveTime],
        ]).cleanupStep(cleanup.augmentObservation).cleanupStep(cleanup.removeField("problem_text"));

      //TODO:  Cleanup/investigate negation status.
      var ProblemConcernAct = component.define("ProblemConcernAct")
        .fields([
          ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
          ["identifiers", "0..*", "h:entryRelationship/h:observation/h:id", shared.Identifier],
          ["negation_indicator", "0..1", "h:entryRelationship/h:observation", shared.NegationIndicator],
          ["problem", "1:1", "h:entryRelationship/h:observation/h:value", ProblemObservation],
          ["onset_age", "0..1", "h:entryRelationship/h:observation/h:entryRelationship/h:observation/h:templateId[@root='2.16.840.1.1 13883.10.20.1.38']/../h:value/@value"],
          ["onset_age_unit", "0..1", "h:entryRelationship/h:observation/h:entryRelationship/h:observation/h:templateId[@root='2.16.840.1.1 13883.10.20.1.38']/../h:value", shared.AgeDescriptor],
          ["status", "0..1", ProblemStatus.xpath(), ProblemStatus],
          //Patient Status not supported.
          //["patient_status", "0..1", "h:entryRelationship/h:observation/h:entryRelationship/h:observation/h:templateId[@root='2.16.840.1.113883.10.20.22.4.5']/../h:value/@displayName"],
          ["source_list_identifiers", "0..*", "h:id", shared.Identifier],
        ]);

      var NonProblemObservation = ProblemConcernAct
        .define("ProblemObservation");

      var ProblemOrganizer = component.define("ProblemOrganizer")
        .templateRoot(["2.16.840.1.113883.3.88.11.83.7"]);

      var problemsSection = component.define("problemsSection");
      problemsSection.templateRoot(["2.16.840.1.113883.3.88.11.83.103"]); // coded entries required
      problemsSection.fields([
        ["problems", "0..*", ProblemOrganizer.xpath(), ProblemConcernAct],
      ]);

      problemsSection.cleanupStep(cleanup.replaceWithField("problems"));
      return [problemsSection, ProblemConcernAct];
    };

    exports.problemsSection = exportProblemsSection;
    exports.problemsEntry = exportProblemsSection;

  }, { "../cleanup": 3, "../shared": 13, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 10: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportProceduresSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      var entry = component.define('entry');
      entry.templateRoot(["2.16.840.1.113883.3.88.11.83.17", "1.3.6.1.4.1.19376.1.5.3.1.4.19"]);
      entry.fields([
        ["procedure", "1..1", "h:code", shared.ConceptDescriptor],
        ["identifiers", "0..*", "h:id", shared.Identifier],
        //Not C32 Supported.
        //["status", "1..1", "h:statusCode", shared.simplifiedCodeOID('2.16.840.1.113883.11.20.9.22')],
        ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
        ["body_sites", "0..*", "h:targetSiteCode", shared.ConceptDescriptor],

        //Not C32 Supported.
        //["specimen", "0..1", "h:specimen", ProcedureSpecimen],
        //Not C32 Supported.
        //["priority", "0..1", "h:priorityCode", shared.ConceptDescriptor],
        ["performers", "0..*", "h:performer/h:assignedEntity", shared.assignedEntity],
        //Not C32 Supported.
        //["locations", "0..*", "h:participant/h:participantRole", shared.serviceDeliveryLocation],
        ['procedure_type', "1..1", "h:templateId/@root"]
      ]);

      entry.cleanupStep(function () {
        var typeMap = {
          "2.16.840.1.113883.3.88.11.83.17": "procedure" // ccda-r1
        };
        var t = this.js['procedure_type'];
        this.js['procedure_type'] = typeMap[t];
      });

      var proceduresSection = component.define('proceduresSection');
      proceduresSection.templateRoot(["2.16.840.1.113883.10.20.1.12"]);
      proceduresSection.fields([
        ["entry", "0..*", entry.xpath(), entry]
      ]);
      proceduresSection.cleanupStep(cleanup.replaceWithField('entry'));
      return [proceduresSection, entry];
    };

    exports.proceduresSection = exportProceduresSection;
    exports.proceduresEntry = exportProceduresSection;

  }, { "../cleanup": 3, "../shared": 13, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 11: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportResultsSection = function (version) {
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];
      var sectionIDs = bbm.CCDA["sections" + version];

      var referenceRange = component.define('referenceRange')
        .fields([
          ["low", "0..1", "h:value/h:low/@value"],
          ["high", "0..1", "h:value/h:high/@value"],
          ["unit", "0..1", "h:value/h:low/@unit"],
          ["range", "0..1", "h:text/text()"]
        ]);

      var ResultObservation = component.define("ResultObservation")
        .templateRoot("2.16.840.1.113883.3.88.11.83.15.1")
        .fields([
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["result", "1..1", "h:code", shared.ConceptDescriptor],
          ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
          //["physicalQuantity.text", "1..1", "h:value[@xsi:type='ST']", shared.PhysicalQuantity],
          ["status", "1..1", "h:statusCode/@code"],
          ["text", "0..1", "h:value[@xsi:type='ST']/text()"],
          ["reference_range", "0..1", "h:referenceRange/h:observationRange", referenceRange],
          //["codedValue", "0..1", "h:value[@xsi:type='CD']", shared.ConceptDescriptor],
          //["freeTextValue", "0..1", "h:text", shared.TextWithReference],
          ["interpretations", "0..*", "h:interpretationCode[@codeSystem='2.16.840.1.113883.5.83']", shared.SimplifiedCode]
        ]);
      //ResultObservation.cleanupStep(cleanup.extractAllFields(['resultName']));

      // TODO: Accomodating both PQ and CD values needed
      //ResultObservation.cleanupStep(cleanup.extractAllFields(['physicalQuantity']));
      //ResultObservation.cleanupStep(cleanup.extractAllFields(['codedValue']));

      var ResultsOrganizer = component.define("ResultsOrganizer")
        .templateRoot("2.16.840.1.113883.10.20.1.32")
        .fields([
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["result_set", "0..1", "h:code", shared.ConceptDescriptor],
          ["results", "1..*", ResultObservation.xpath(), ResultObservation]
        ]);

      var resultsSection = component.define("resultsSection");
      resultsSection.templateRoot(['2.16.840.1.113883.3.88.11.83.122']); // .1 for "entries required"
      resultsSection.fields([
        ["panels", "0..*", ResultsOrganizer.xpath(), ResultsOrganizer]
      ]);
      resultsSection.cleanupStep(cleanup.replaceWithField('panels'));

      return [resultsSection, ResultsOrganizer];
    };

    exports.resultsSection = exportResultsSection;
    exports.resultsEntry = exportResultsSection;

  }, { "../cleanup": 3, "../shared": 13, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 12: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportVitalSignsSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      var VitalSignObservation = component.define("VitalSignObservation")
        .templateRoot("2.16.840.1.113883.3.88.11.83.14")
        .fields([
          ["identifiers", "0..*", "h:id", shared.Identifier], //this one is stripped out by "paredown" cleanup step in component.js
          ["vital", "1..1", "h:code", shared.ConceptDescriptor],
          //["identifiers","0..*", "h:id", shared.Identifier], //dup with first line
          ["status", "1..1", "h:statusCode/@code"],
          ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
          ["physicalQuantity", "1..1", "h:value[@xsi:type='PQ']", shared.PhysicalQuantity],
          //["freeTextValue", "0..1", "h:text", shared.TextWithReference],
          ["interpretations", "0..*", "h:interpretationCode[@codeSystem='2.16.840.1.113883.5.83']", shared.SimplifiedCode]
        ]);
      //VitalSignObservation.cleanupStep(cleanup.extractAllFields(['code']));
      VitalSignObservation.cleanupStep(cleanup.extractAllFields(['physicalQuantity']));

      var vitalSignsSection = component.define("vitalSignsSection");
      vitalSignsSection.templateRoot(["2.16.840.1.113883.3.88.11.83.119"]);
      vitalSignsSection.fields([
        ["entry", "0..*", VitalSignObservation.xpath(), VitalSignObservation]
      ]);
      vitalSignsSection.cleanupStep(cleanup.replaceWithField('entry'));
      return [vitalSignsSection, VitalSignObservation];
    };

    // var VitalSignObservation = component.define("VitalSignObservation")
    //     .templateRoot(clinicalStatementsIDs.VitalSignObservation)
    //     .fields([
    //         ["identifiers", "0..*", "h:id", shared.Identifier], //this one is stripped out by "paredown" cleanup step in component.js
    //         ["vital", "1..1", "h:code", shared.ConceptDescriptor],
    //         //["identifiers","1..*", "h:id", shared.Identifier], //dup with first line
    //         ["status", "1..1", "h:statusCode/@code"],
    //         ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
    //         ["physicalQuantity", "1..1", "h:value[@xsi:type='PQ']", shared.PhysicalQuantity],
    //         //["freeTextValue", "0..1", "h:text", shared.TextWithReference],
    //         ["interpretations", "0..*", "h:interpretationCode[@codeSystem='2.16.840.1.113883.5.83']", shared.SimplifiedCode]
    //     ]);
    //   //VitalSignObservation.cleanupStep(cleanup.extractAllFields(['code']));
    //   VitalSignObservation.cleanupStep(cleanup.extractAllFields(['physicalQuantity']));

    /*
      //Vitals organizer is not used (flattened out in JSON model)
      var VitalSignsOrganizer = component.define("VitalSignsOrganizer")
      .templateRoot("2.16.840.1.113883.10.20.22.4.26")
      .fields([
        ["panelName","0..1", "h:code", shared.ConceptDescriptor],
        ["sourceIds","1..*", "h:id", shared.Identifier],
        ["vitals", "1..*", VitalSignObservation.xpath(), VitalSignObservation]
      ]);
      
      
      exports.VitalSignsSection = Component.define("VitalSignsSection")
      .templateRoot("2.16.840.1.113883.10.20.22.2.4.1")
      .fields([
        //["name","0..1", "h:code", shared.ConceptDescriptor],
        //["panels","0..*", VitalSignsOrganizer.xpath(), VitalSignsOrganizer],
        ["vitals","0..*", VitalSignObservation.xpath(), VitalSignObservation],
      ]);
      */

    exports.vitalSignsSection = exportVitalSignsSection;

    exports.vitalSignsEntry = exportVitalSignsSection;

  }, { "../cleanup": 3, "../shared": 13, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 13: [function (require, module, exports) {
    "use strict";

    var component = require("@amida-tech/blue-button-xml").component;
    var processor = require("@amida-tech/blue-button-xml").processor;
    var cleanup = require("./cleanup");
    var common = require("@amida-tech/blue-button-xml").common;

    var commonShared = require('../common/shared');

    var shared = module.exports = Object.create(commonShared);

    var TextWithReference = shared.TextWithReference = component.define("TextWithReference");
    TextWithReference.fields([
      ["text", "0..*", "text()"],
      ["reference", "0..1", "./h:reference/@value"],
    ])
      .cleanupStep(cleanup.resolveReference);

    var NegationIndicator = shared.NegationIndicator = component.define("NegationIndicator");
    NegationIndicator.fields([
      ["negation_indicator", "0..1", "@negationInd", processor.asBoolean]
    ]).cleanupStep(function () {
      //Flag missing negations as false.
      if (this.js) {
        if (!common.exists(this.js)) {
          this.js.negation_indicator = false;
        }
        if (this.js.negation_indicator === 'true') {
          this.js.negation_indicator = true;
        }
      } else {
        this.js = {
          negation_indicator: false
        };
      }
    })
      .cleanupStep(cleanup.replaceWithField('negation_indicator'));

    var conceptWoutTranslation = component.define("conceptWoutTranslation");
    conceptWoutTranslation.fields([
      ["name", "0..1", "@displayName"],
      ["code", "1..1", "@code"],
      ["system", "1..1", "@codeSystem"],
      ["code_system_name", "0..1", "@codeSystemName"],
      ["nullFlavor", "0..1", "@nullFlavor"],
      ["original_text", "0..1", "h:originalText", TextWithReference]
    ]);
    conceptWoutTranslation.cleanupStep(cleanup.augmentConcept);
    conceptWoutTranslation.cleanupStep(cleanup.removeField('system'));

    var ConceptDescriptor = shared.ConceptDescriptor = conceptWoutTranslation.define("ConceptDescriptor");
    ConceptDescriptor.fields([
      ["translations", "0..*", "h:translation", conceptWoutTranslation],
    ]);

    var AgeDescriptor = shared.AgeDescriptor = component.define("AgeDescriptor");
    AgeDescriptor.fields([
      ["units", "0..1", "@unit"],
    ])
      .cleanupStep(cleanup.augmentAge);

    var SimplifiedCode = shared.SimplifiedCode = ConceptDescriptor.define("SimpifiedCode")
      .cleanupStep(cleanup.augmentSimplifiedCode);

    var PhysicalQuantity = shared.PhysicalQuantity = component.define("PhysicalQuantity")
      .fields([
        ["value", "1..1", "@value", processor.asFloat],
        ["unit", "0..1", "@unit"]
      ]);

    var EventOffset = shared.EventOffset = component.define("EventOffset")
      .fields([
        ["low", "0..1", "h:/low", PhysicalQuantity],
        ["high", "0..1", "h:/high", PhysicalQuantity],
        ["center", "0..1", "h:/center", PhysicalQuantity],
        ["width", "0..1", "h:/width", PhysicalQuantity],
      ]);

    var EffectiveTime = shared.EffectiveTime = component.define("EffectiveTime")
      .fields([
        ["point", "0..1", "@value", processor.asTimestamp],
        ["point_resolution", "0..1", "@value", processor.asTimestampResolution],
        ["low", "0..1", "h:low/@value", processor.asTimestamp],
        ["low_resolution", "0..1", "h:low/@value", processor.asTimestampResolution],
        ["high", "0..1", "h:high/@value", processor.asTimestamp],
        ["high_resolution", "0..1", "h:high/@value", processor.asTimestampResolution],
        ["center", "0..1", "h:center/@value", processor.asTimestamp],
        ["center_resolution", "0..1", "h:center/@value", processor.asTimestampResolution]
      ])
      .cleanupStep(cleanup.augmentEffectiveTime);

    var IndividualName = shared.IndividualName = component.define('IndividualName')
      .fields([
        ["prefix", "0..1", "h:prefix/text()"],
        ["middle", "0..*", "h:given/text()"],
        ["last", "0..1", "h:family/text()"],
        ["suffix", "0..1", "h:suffix/text()"],
        ["freetext_name", "0..1", "../h:name/text()", processor.asString]
      ]).cleanupStep(cleanup.augmentIndividualName).cleanupStep(cleanup.clearNulls);

    var Address = shared.Address = component.define("Address")
      .fields([
        ["street_lines", "1..4", "h:streetAddressLine/text()"],
        ["city", "1..1", "h:city/text()", processor.asString],
        ["state", "0..1", "h:state/text()"],
        ["zip", "0..1", "h:postalCode/text()"],
        ["country", "0..1", "h:country/text()"],
        ["use", "0..1", "@use", shared.SimpleCode("2.16.840.1.113883.5.1119")]
      ]);

    var Organization = shared.Organization = component.define("Organization")
      .fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["name", "0..*", "h:name/text()"],
        ["address", "0..*", "h:addr", Address],
        ["email", "0..*", shared.email.xpath(), shared.email],
        ["phone", "0..*", shared.phone.xpath(), shared.phone]
      ]);

    var assignedEntity = shared.assignedEntity = component.define("assignedEntity")
      .fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["name", "0..*", "h:assignedPerson/h:name", IndividualName],
        ["address", "0..*", "h:addr", Address],
        ["email", "0..*", shared.email.xpath(), shared.email],
        ["phone", "0..*", shared.phone.xpath(), shared.phone],
        ["organization", "0..*", "h:representedOrganization", Organization],
        ["code", "0..*", "h:code", ConceptDescriptor],
      ]);

    shared.serviceDeliveryLocation = component.define('serviceDeliveryLocation')
      .fields([
        ["name", "0:1", "h:playingEntity/h:name/text()"],
        ["location_type", "1..1", "h:code", ConceptDescriptor],
        ["address", "0..*", "h:addr", Address],
        ["email", "0..*", shared.email.xpath(), shared.email],
        ["phone", "0..*", shared.phone.xpath(), shared.phone]
      ]);

  }, { "../common/shared": 42, "./cleanup": 3, "blue-button-xml": "blue-button-xml" }], 14: [function (require, module, exports) {
    "use strict";

    var component = require("@amida-tech/blue-button-xml").component;
    var shared = require("./shared");

    var exportCCD = function (version) {
      var header = require("./header").header;
      var patient = require("./demographics").patient;
      var resultsSection = require("./sections/results").resultsSection(version)[0];
      var vitalSignsSection = require("./sections/vitals").vitalSignsSection(version)[0];
      var problemsSection = require("./sections/problems").problemsSection(version)[0];
      var immunizationsSection = require("./sections/immunizations").immunizationsSection(version)[0];
      var socialHistorySection = require("./sections/social_history").socialHistorySection(version)[0];
      var medicationsSection = require("./sections/medications").medicationsSection(version)[0];
      var allergiesSection = require("./sections/allergies").allergiesSection(version)[0];
      var encountersSection = require("./sections/encounters").encountersSection(version)[0];
      var proceduresSection = require("./sections/procedures").proceduresSection(version)[0];
      var plan_of_care_section = require("./sections/plan_of_care").plan_of_care_section(version)[0];
      var payers_section = require("./sections/payers").payers_section(version)[0];

      return component.define("CCD")
        .fields([
          ["meta", "0..1", ".", shared.metaData],
          ["header", "1..1", "(/ | //h:ClinicalDocument)[last()]", header],
          ["demographics", "1..1", "(/ | //h:recordTarget/h:patientRole)[last()]", patient],
          ["vitals", "0..1", vitalSignsSection.xpath(), vitalSignsSection],
          ["results", "0..1", resultsSection.xpath(), resultsSection],
          ["medications", "0..1", medicationsSection.xpath(), medicationsSection],
          ["encounters", "0..1", encountersSection.xpath(), encountersSection],
          ["allergies", "0..1", allergiesSection.xpath(), allergiesSection],
          ["immunizations", "0..1", immunizationsSection.xpath(), immunizationsSection],
          ["social_history", "0..1", socialHistorySection.xpath(), socialHistorySection],
          ["problems", "0..1", problemsSection.xpath(), problemsSection],
          ["procedures", "0..1", proceduresSection.xpath(), proceduresSection],
          ["plan_of_care", "0..1", plan_of_care_section.xpath(), plan_of_care_section],
          ["payers", "0..1", payers_section.xpath(), payers_section],
        ]);
    };

    exports.CCD = exportCCD;

  }, { "./demographics": 16, "./header": 17, "./sections/allergies": 18, "./sections/encounters": 19, "./sections/immunizations": 20, "./sections/medications": 21, "./sections/payers": 22, "./sections/plan_of_care": 23, "./sections/problems": 24, "./sections/procedures": 25, "./sections/results": 26, "./sections/social_history": 27, "./sections/vitals": 28, "./shared": 29, "blue-button-xml": "blue-button-xml" }], 15: [function (require, module, exports) {
    "use strict";

    var includeCleanup = require("../common/cleanup");

    var cleanup = module.exports = Object.create(includeCleanup);

    var _ = require("lodash");

    cleanup.promoteAllergenNameIfNoAllergen = function () {
      if (this.js && (!_.get(this, "js.allergen"))) {
        var name = this.js.allergenName && this.js.allergenName.js;
        if (name) {
          this.js.allergen = {
            name: name
          };
        }
      }
      delete this.js.allergenName;
    };

    cleanup.promoteFreeTextIfNoReaction = function () {
      if (this.js && (!_.get(this, "js.reaction"))) {
        var name = this.js.free_text_reaction && this.js.free_text_reaction.js;
        if (name) {
          this.js.reaction = {
            name: name
          };
        }
      }
      delete this.js.free_text_reaction;
    };

  }, { "../common/cleanup": 41, "lodash": 95 }], 16: [function (require, module, exports) {
    "use strict";

    var shared = require('./shared');
    var processor = require("@amida-tech/blue-button-xml").processor;
    var component = require("@amida-tech/blue-button-xml").component;

    var Guardian = component.define("Guardian")
      .fields([
        ["relation", "0..1", "h:code", shared.SimplifiedCode],
        ["addresses", "0..*", "h:addr", shared.Address],
        ["names", "1..*", "h:guardianPerson/h:name", shared.IndividualName],
        ["phone", "0..*", shared.phone.xpath(), shared.phone],
        ["email", "0..*", shared.email.xpath(), shared.email],
      ]);

    var LanguageCommunication = component.define("LanguageCommunication")
      .fields([
        ["language", "1..1", "h:languageCode/@code"],
        ["preferred", "1..1", "h:preferenceInd/@value", processor.asBoolean],
        ["mode", "0..1", "h:modeCode", shared.SimplifiedCode],
        ["proficiency", "0..1", "h:proficiencyLevelCode", shared.SimplifiedCode]
      ]);

    exports.patient = component.define("Patient")
      .fields([
        ["name", "1..1", "h:patient/h:name", shared.IndividualName],
        ["dob", "1..1", "h:patient/h:birthTime", shared.EffectiveTime],
        ["gender", "1..1", "h:patient/h:administrativeGenderCode", shared.SimplifiedCode],
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["marital_status", "0..1", "h:patient/h:maritalStatusCode", shared.SimplifiedCode],
        ["addresses", "0..*", "h:addr", shared.Address],
        ["phone", "0..*", shared.phone.xpath(), shared.phone],
        ["email", "0..*", shared.email.xpath(), shared.email],
        ["race", "0..1", "h:patient/h:raceCode", shared.simplifiedCodeOID("2.16.840.1.113883.6.238")],
        ["ethnicity", "0..1", "h:patient/h:ethnicGroupCode", shared.simplifiedCodeOID("2.16.840.1.113883.6.238")],
        ["languages", "0..*", "h:patient/h:languageCommunication", LanguageCommunication],
        ["religion", "0..1", "h:patient/h:religiousAffiliationCode/@code", shared.SimpleCode("2.16.840.1.113883.5.1076")],
        ["birthplace", "0..1", "h:patient/h:birthplace/h:place/h:addr", shared.Address],
        ["guardians", "0..*", "h:patient/h:guardian", Guardian]
      ]);

  }, { "./shared": 29, "blue-button-xml": "blue-button-xml" }], 17: [function (require, module, exports) {
    "use strict";

    var shared = require('./shared');
    var processor = require("@amida-tech/blue-button-xml").processor;
    var component = require("@amida-tech/blue-button-xml").component;

    var Author = component.define("Author")
      .fields([
        ["author", "0..*", "h:assignedAuthor", shared.assignedEntity],
        ["date_time", "1..1", "h:time", shared.EffectiveTime],
      ]);

    exports.header = component.define("Header")
      .fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["confidentiality_code", "0..1", "h:confidentialityCode", shared.ConceptDescriptor],
        ["template", "0..1", "h:code", shared.ConceptDescriptor],
        ["title", "0..1", "h:title", processor.asString],
        //timestamp

        ["author", "0..1", "//h:author", Author],
        ["data_enterer", "0..1", "//h:dataEnterer/h:assignedEntity", shared.assignedEntity],
        ["informant", "0..1", "//h:informant/h:assignedEntity", shared.assignedEntity]

        //["custodian", "0..1", "//h:informant/h:assignedEntity", shared.assignedEntity],
        //["service_event", "0..1", "//h:serviceEvent", shared.assignedEntity],
        //service event performer

      ]);

  }, { "./shared": 29, "blue-button-xml": "blue-button-xml" }], 18: [function (require, module, exports) {
    "use strict";

    // NOTE: allergies section not present in ccda-r1.0, so just kept
    // templateIds hard-coded with ccda-r1.1 values
    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var Processor = require("@amida-tech/blue-button-xml").processor;

    var exportAllergiesSection = function (version) {

      var allergySeverityObservation = component.define("allergySeverityObservation")
        .fields([
          ["code", "0..1", "h:value", shared.ConceptDescriptor],
          ["interpretation", "0..1", "h:interpretationCode", shared.ConceptDescriptor]
        ]);

      var allergyReaction = component.define("allergyReaction");
      allergyReaction.templateRoot(["2.16.840.1.113883.10.20.22.4.9"]);
      allergyReaction.fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
        ["reaction", "1..1", "h:value", shared.ConceptDescriptor],
        ["free_text_reaction", "0..1", "h:text", shared.TextWithReference],
        ["severity", "0..1", "h:entryRelationship/h:observation", allergySeverityObservation]
      ]);
      allergyReaction.cleanupStep(cleanup.promoteFreeTextIfNoReaction);

      var allergenDescriptor = shared.ConceptDescriptor.define('allergenDescriptor');
      allergenDescriptor.fields([
        ["name", "0..1", "h:originalText", shared.TextWithReference, 'epic']
      ]);

      var allergyObservation = component.define("allergyObservation"); // this is status observation
      allergyObservation.templateRoot(["2.16.840.1.113883.10.20.22.4.7"]);
      allergyObservation.fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        //NOTE: Negation Id (per PragueExpat)
        ["negation_indicator", "0..1", "./@negationInd", Processor.asBoolean],
        //NOTE allergen must be optional in case of negationInd = true (per PragueExpat)
        ["allergen", "0..1", "h:participant/h:participantRole/h:playingEntity/h:code", allergenDescriptor], // (see above) - was 1..1 //Require (optional in spec)
        ["allergenName", "0..1", "h:participant/h:participantRole/h:playingEntity/h:name", shared.TextWithReference],

        ["intolerance", "0..1", "h:value", shared.ConceptDescriptor],
        ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],

        ["status", "0..1", "h:entryRelationship/h:observation[h:templateId/@root='2.16.840.1.113883.10.20.22.4.28']/h:value", shared.ConceptDescriptor],
        ["reactions", "0..*", allergyReaction.xpath(), allergyReaction],
        ["severity", "0..1", "h:entryRelationship/h:observation[h:templateId/@root='2.16.840.1.113883.10.20.22.4.8']", allergySeverityObservation]
      ]);
      allergyObservation.cleanupStep(cleanup.promoteAllergenNameIfNoAllergen);

      var problemAct = component.define('problemAct');
      problemAct.templateRoot(['2.16.840.1.113883.10.20.22.4.30']);
      problemAct.fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
        ["problemStatus", "1..1", "h:statusCode/@code"],
        ["observation", "1..1", allergyObservation.xpath(), allergyObservation] // Ignore observation cardinality (in spec can be more than 1)
      ]);
      problemAct.cleanupStep(cleanup.allergiesProblemStatusToHITSP);

      var allergiesSection = component.define('allergiesSection');
      allergiesSection.templateRoot(['2.16.840.1.113883.10.20.22.2.6', '2.16.840.1.113883.10.20.22.2.6.1']);
      allergiesSection.fields([
        ["problemAct", "1..*", problemAct.xpath(), problemAct]
      ]);
      allergiesSection.cleanupStep(cleanup.replaceWithField(["problemAct"]));

      return [allergiesSection, problemAct];
    };
    exports.allergiesSection = exportAllergiesSection;
    exports.allergiesEntry = exportAllergiesSection;

  }, { "../cleanup": 15, "../shared": 29, "blue-button-xml": "blue-button-xml" }], 19: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportEncountersSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      var finding = component.define("finding");
      finding.templateRoot([clinicalStatementsIDs.Indication]);
      finding.fields([
        ["identifiers", "1..*", "h:id", shared.Identifier],
        ["value", "1..1", "h:value", shared.ConceptDescriptor],
        ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime]
      ]);
      //finding.cleanupStep(cleanup.extractAllFields(['value']));

      // Iff needed add this later by refactoring Problem Observation from Problems.  They should share.
      //var diagnosis = component.define("diagnosis");
      //finding.templateRoot(['2.16.840.1.113883.10.20.22.4.80']);
      //finding.fields([
      //  ["code", "1..1", "h:code", shared.ConceptDescriptor]
      //]);
      //finding.cleanupStep(cleanup.extractAllFields(['code']));

      var activity = component.define('activity');
      activity.templateRoot([clinicalStatementsIDs.EncounterActivities, clinicalStatementsIDs.EncounterActivity]);
      activity.fields([
        ["encounter", "1..1", "h:code", shared.ConceptDescriptor],
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
        ["performers", "0..*", "h:performer/h:assignedEntity", shared.assignedEntity],
        ["locations", "0..*", "h:participant/h:participantRole", shared.serviceDeliveryLocation],
        ["findings", "0..*", finding.xpath(), finding] //,
        //["diagnoses", "0..*", diagnosis.xpath(), diagnosis]
      ]);

      var encountersSection = component.define('encountersSection');
      encountersSection.templateRoot([sectionIDs.EncountersSection, sectionIDs.EncountersSectionEntriesOptional]);
      encountersSection.fields([
        ["activity", "0..*", activity.xpath(), activity]
      ]);
      encountersSection.cleanupStep(cleanup.replaceWithField(["activity"]));
      return [encountersSection, activity];
    };
    exports.encountersSection = exportEncountersSection;
    exports.encountersEntry = exportEncountersSection;

  }, { "../cleanup": 15, "../shared": 29, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 20: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");
    var _ = require("lodash");

    var augmentImmunizationStatus = function () {
      var tmpStatus = "";
      if (_.get(this, "js.negation_ind") === "true") {
        tmpStatus = "refused";
      } else if (_.get(this, "js.mood_code") === "INT") {
        tmpStatus = "pending";
      } else if (_.get(this, "js.mood_code") === "EVN") {
        tmpStatus = "complete";
      } else {
        tmpStatus = "unknown";
      }
      this.js = tmpStatus;
    };

    var exportImmunizationsSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      var ImmunizationStatus = component.define("ImmunizationStatus")
        .fields([
          ["mood_code", "0..1", "./@moodCode"],
          ["negation_ind", "0..1", "./@negationInd"],
        ]).cleanupStep(augmentImmunizationStatus);

      var ImmunizationAdministration = component.define("ImmunizationAdministration")
        .fields([
          ["route", "0..1", "h:routeCode", shared.ConceptDescriptor],
          ["body_site", "0..1", "h:approachSiteCode", shared.ConceptDescriptor],
          ["dose", "0..1", "h:doseQuantity", shared.PhysicalQuantity],
          ["form", "0..1", "h:administrationUnitCode", shared.ConceptDescriptor]
        ]);

      var ImmunizationInstructions = component.define("MedicationInstructions")
        .fields([
          ["code", "0..1", "h:code", shared.ConceptDescriptor],
          ["free_text", "0..1", "h:text", shared.TextWithReference]
        ]);

      var immunizationActivityProduct = component.define('immunizationActivityProduct')
        .fields([
          ["product", "1..1", "h:manufacturedMaterial/h:code", shared.ConceptDescriptor],
          ["lot_number", "0..1", "h:manufacturedMaterial/h:lotNumberText/text()"],
          ["manufacturer", "0..1", "h:manufacturerOrganization/h:name/text()"],
        ]);

      var ImmunizationActivity = component.define("ImmunizationActivity")
        .templateRoot([clinicalStatementsIDs.ImmunizationActivity, clinicalStatementsIDs.MedicationActivity])
        .fields([
          ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["status", "0..1", "./../h:substanceAdministration", ImmunizationStatus],
          ["sequence_number", "0..1", "h:repeatNumber/@value"],
          ["product", "0..1", "h:consumable/h:manufacturedProduct", immunizationActivityProduct],
          ["administration", "0..1", "./../h:substanceAdministration", ImmunizationAdministration],
          ["performer", "0..1", "h:performer/h:assignedEntity", shared.assignedEntity],
          ["instructions", "0..1", "h:entryRelationship[@typeCode='SUBJ']/h:act", ImmunizationInstructions],
          ["refusal_reason", "0..1", "h:entryRelationship/h:observation/h:code/@code", shared.SimpleCode("2.16.840.1.113883.5.8")],
        ]).cleanupStep(function () { // Quick and dirty fix for when refusal_reason catches other observations in Vitera.
          if (this.js) { // Refusal reason should use the template id
            if (this.js.refusal_reason && (!_.get(this, "js.refusal_reason.js"))) {
              delete this.js.refusal_reason;
            }
          }
        });

      var immunizationsSection = component.define("immunizationsSection");
      immunizationsSection.templateRoot([sectionIDs.ImmunizationsSection, sectionIDs.ImmunizationsSectionEntriesOptional]);
      immunizationsSection.fields([
        ["immunizations", "0..*", ImmunizationActivity.xpath(), ImmunizationActivity]
      ]);

      immunizationsSection.cleanupStep(cleanup.replaceWithField('immunizations'));
      return [immunizationsSection, ImmunizationActivity];
    };

    exports.immunizationsSection = exportImmunizationsSection;
    exports.immunizationsEntry = exportImmunizationsSection;

  }, { "../cleanup": 15, "../shared": 29, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml", "lodash": 95 }], 21: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var processor = require("@amida-tech/blue-button-xml").processor;
    var bbm = require("@amida-tech/blue-button-meta");
    var _ = require("lodash");

    var exportMedicationsSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      // Common entries between ccda-r1.1 and ccda-r1.0

      /* 1. For the medication interval component, you may find that some of the fields
      below(xsi:type, alignment, event, event_offset) are not defined in ccda 1.1.
      specification and in many sample files.
  
      refer to this link: https://groups.google.com/forum/#!msg/ccda_samples/WawmwNMYT_8/pqnp5bG1IygJ
  
      2. This is about the frequency tag and institutionSpecified attribute:
  
      The period element can represent either timing between doses or frequency.
      Use @institutionSpecified to distinguish these: To specify an interval between doses
      (e.g., every 8 hours), set the value of @institutionSpecified to false or omit the attribute.
      To specify frequency of administration (e.g., 3 times per day), set the value
      of @institutionSpecified to true.
  
      source: http://wiki.siframework.org/CDA+-+Medications+Section
  
      */
      var MedicationInterval = component.define("MedicationInterval")
        .fields([
          ["phase", "0..1", "./h:phase", shared.EffectiveTime],
          ["period", "0..1", "./h:period", shared.PhysicalQuantity],
          ["alignment", "0..1", "./@alignment"],
          ["frequency", "0..1", "./@institutionSpecified", processor.asBoolean],
          ["event", "0..1", "./h:event/@code", shared.SimpleCode("2.16.840.1.113883.5.139")],
          ["event_offset", "0..1", "./h:offset", shared.EventOffset]
        ]);

      var MedicationAdministration = component.define("MedicationAdministration")
        .fields([
          ["route", "0..1", "h:routeCode", shared.ConceptDescriptor],
          ["site", "0..1", "h:approachSiteCode", shared.ConceptDescriptor],
          ["form", "0..1", "h:administrationUnitCode", shared.ConceptDescriptor],
          ["dose", "0..1", "h:doseQuantity", shared.PhysicalQuantity],
          ["rate", "0..1", "h:rateQuantity", shared.PhysicalQuantity],
          ["dose_restriction", "0..1", "h:maxDoseQuantity", shared.PhysicalQuantity],
          ["interval", "0..1", "h:effectiveTime[@operator='A']", MedicationInterval],
        ]);

      var MedicationIndication = component.define("MedicationIndication")
        .fields([
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["code", "0..1", "h:code", shared.ConceptDescriptor],
          ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
          ["value", "0..1", "h:value", shared.ConceptDescriptor]
        ]);

      var MedicationPrecondition = component.define("MedicationPrecondition")
        .fields([
          ["code", "0..1", "h:code", shared.ConceptDescriptor],
          ["text", "0..1", "h:text/text()"],
          ["value", "0..1", "h:value", shared.ConceptDescriptor]
        ]);

      var author = component.define("author")
        .fields([
          ["date_time", "0..1", "h:time", shared.EffectiveTime],
          ["identifiers", "0..*", "h:assignedAuthor/h:id", shared.Identifier],
          ["name", "0..1", "h:assignedAuthor/h:assignedPerson/h:name", shared.IndividualName],
          ["organization", "0..1", "h:assignedAuthor/h:representedOrganization", shared.Organization]
        ]);

      // below entries differ between ccda-r1.1 and ccda-r1.0
      // ***************************************************************************
      // *                      ccda-r1.1 (LATEST VERSION)                         *
      // ***************************************************************************

      var medicationInformation;
      var medicationSupplyOrder;
      var medicationActivity;
      var medicationsSection;

      if (version === "") {
        medicationInformation = component.define("medicationInformation")
          .templateRoot("2.16.840.1.113883.10.20.22.4.23")
          .fields([
            ["identifiers", "0..*", "h:id", shared.Identifier],
            ["unencoded_name", "0..1", "h:manufacturedMaterial/h:code/h:originalText", shared.TextWithReference],
            ["product", "1..1", "h:manufacturedMaterial/h:code", shared.ConceptDescriptor],
            ["manufacturer", "0..1", "h:manufacturerOrganization/h:name/text()"]
          ]);

        medicationSupplyOrder = component.define("medicationSupplyOrder")
          .fields([
            ["identifiers", "0..*", "h:assignedEntity/h:id", shared.Identifier],
            ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
            ["repeatNumber", "0..1", "h:repeatNumber/@value"],
            ["quantity", "0..1", "h:quantity/@value"],
            ["status", "0..1", "h:status/@code"],
            ["author", "0..1", "h:author", author] //, instructions use references, which are not supported (also samples don't have good data for it)
            //["instructions", "0..1", "h:entryRelationship[@typeCode='SUBJ']/h:act", MedicationInstructions]
          ]);

        var MedicationPerformer = component.define("MedicationPerformer")
          .fields([
            ["identifiers", "0..*", "h:assignedEntity/h:id", shared.Identifier],
            ["address", "0..*", "h:assignedEntity/h:addr", shared.Address],
            ["phone", "0..1", "h:assignedEntity/" + shared.phone.xpath(), shared.phone],
            ["organization", "0..*", "h:assignedEntity/h:representedOrganization", shared.Organization]
          ]);
        /*
        var MedicationDrugVehicle = component.define("MedicationDrugVehicle")
            .templateRoot("2.16.840.1.113883.10.20.22.4.24")
            .fields([
                ["playingEntity", "0..1", "h:playingEntity/h:code", shared.ConceptDescriptor]
            ]).cleanupStep(cleanup.extractAllFields(["drug_vehicle"]));
*/
        var MedicationInstructions = component.define("MedicationInstructions")
          .fields([
            ["code", "0..1", "../h:code", shared.ConceptDescriptor],
            ["freeText", "0..1", "../h:text", shared.TextWithReference]
          ]);

        var MedicationDispense = component.define("MedicationDispense")
          .templateRoot("2.16.840.1.113883.10.20.22.4.18")
          .fields([
            ["identifiers", "0..*", "h:id", shared.Identifier],
            ["performer", "0..1", "h:performer", MedicationPerformer],
            ["supply", "0..1", "h:entryRelationship[@typeCode='REFR']/h:supply", medicationSupplyOrder]
          ]);

        medicationActivity = component.define("medicationActivity")
          .fields([
            ["date_time", "0..1", "h:effectiveTime[not (@operator='A')]", shared.EffectiveTime],
            ["identifiers", "0..*", "h:id", shared.Identifier],
            ["status", "1..1", "./../h:substanceAdministration/@moodCode"],
            ["sig", "0..1", "h:text", shared.TextWithReference],
            ["product", "1..1", "h:consumable/h:manufacturedProduct", medicationInformation],
            ["supply", "0..1", "h:entryRelationship[@typeCode='REFR']/h:supply", medicationSupplyOrder],
            ["administration", "0..1", "../h:substanceAdministration", MedicationAdministration],
            ["performer", "0..1", "h:performer", MedicationPerformer],
            ["drug_vehicle", "0..1", "h:participant[@typeCode='CSM']/h:participantRole/h:playingEntity[@classCode='MMAT']/h:code", shared.ConceptDescriptor],
            ["precondition", "1..1", "h:precondition/h:criterion", MedicationPrecondition],
            ["indication", "0..1", "h:entryRelationship[@typeCode='RSON']/h:observation", MedicationIndication],
            //["instructions", "0..1", "h:entryRelationship[@typeCode='REFR']/h:supply/*/*/h:templateId[@root='2.16.840.1.113883.10.20.22.4.20']", MedicationInstructions],
            ["dispense", "0..1", MedicationDispense.xpath(), MedicationDispense]
          ])
          //.cleanupStep(Cleanup.extractAllFields(["medicationName"]))
          .cleanupStep(function () {

            //Cleanup Status.

            if (_.get(this, "js.status") === "EVN") {
              this.js.status = "Completed";
            }
            if (_.get(this, "js.status") === "INT") {
              this.js.status = "Prescribed";
            }

            // separate out two effectiveTimes

            /*
      // 1.  startDate --- endDate
      var range = this.js.times.filter(function(t){
        return -1 === ['PIVL_TS', 'EIVL_TS'].indexOf(t.js.xsitype);
      });

      // 2.  dosing interval
      var period= this.js.times.filter(function(t){
        return -1 !== ['PIVL_TS', 'EIVL_TS'].indexOf(t.js.xsitype);
      });

      delete this.js.times;

      if (range.length > 0) {
        this.js.dateRange = range[0];
      }

      if (period.length > 0) {
        this.js.dosePeriod = period[0].js.period;
      }*/

          });
        medicationActivity.setXPath(".//h:templateId[@root=\"2.16.840.1.113883.10.20.22.4.16\" and not(../@negationInd=\"true\")]/..");

        // ignore negationInd medications

        medicationsSection = component.define("medicationsSection");
        medicationsSection.templateRoot(["2.16.840.1.113883.10.20.22.2.1", "2.16.840.1.113883.10.20.22.2.1.1"]);
        medicationsSection.fields([
          ["medications", "0..*", medicationActivity.xpath(), medicationActivity]
        ]);
        medicationsSection.cleanupStep(cleanup.replaceWithField('medications'));
        return [medicationsSection, medicationActivity];

        // ***************************************************************************
        // *                      ccda-r1.0 (OLD VERSION)                            *
        // ***************************************************************************
      } else {

        medicationInformation = component.define("medicationInformation")
          .templateRoot("2.16.840.1.113883.10.20.1.53")
          .fields([
            ["unencoded_name", "0..1", "h:manufacturedProduct/h:manufacturedMaterial/h:code/h:originalText", shared.TextWithReference],
            ["product", "1..1", "h:manufacturedProduct/h:manufacturedMaterial/h:code", shared.ConceptDescriptor],
          ]);

        medicationSupplyOrder = component.define("medicationSupplyOrder")
          .templateRoot("2.16.840.1.113883.10.20.1.34")
          .fields([
            ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
            ["repeatNumber", "0..1", "h:repeatNumber/@value"],
            ["quantity", "0..1", "h:quantity/@value"],
            ["author", "0..1", "h:author", author]
          ]);

        medicationActivity = component.define("Medications")
          .templateRoot(["2.16.840.1.113883.10.20.1.34", "2.16.840.1.113883.10.20.1.24"])
          .fields([
            ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
            ["identifiers", "0..*", "h:id", shared.Identifier],
            ["status", "1..1", "h:statusCode/@code"],
            ["sig", "0..1", "h:text", shared.TextWithReference],
            ["product", "1..1", "(h:product | h:consumable)", medicationInformation],
            ["supply", "0..1", "../h:supply", medicationSupplyOrder],
            ["administration", "0..1", "../h:substanceAdministration", MedicationAdministration],
            ["precondition", "1..1", "h:precondition/h:criterion", MedicationPrecondition]
          ])
          .cleanupStep(function () {

            //Cleanup Status.

            if (_.get(this, "js.status") === "EVN") {
              this.js.status = "Completed";
            }
            if (_.get(this, "js.status") === "INT") {
              this.js.status = "Prescribed";
            }
          });

        medicationsSection = component.define("medicationsSection");
        medicationsSection.templateRoot("2.16.840.1.113883.10.20.1.8");
        medicationsSection.fields([
          ["Medications", "0..*", medicationActivity.xpath(), medicationActivity]
        ]);
        medicationsSection.cleanupStep(cleanup.replaceWithField('medications'));
        return [medicationsSection, medicationActivity];
      }
    };

    exports.medicationsSection = exportMedicationsSection;
    exports.medicationsEntry = exportMedicationsSection;

  }, { "../cleanup": 15, "../shared": 29, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml", "lodash": 95 }], 22: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportPayersSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      var procedure = component.define('procedure');
      procedure.fields([
        ["code", "1..1", "h:code", shared.ConceptDescriptor]
      ]);

      var authorization = component.define('authorization');
      authorization.fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["procedure", "1..1", "h:entryRelationship/h:procedure", procedure]
      ]);

      var policy_holder = component.define('policy_holder');
      policy_holder.fields([
        ["performer", "1..1", "h:participantRole", shared.assignedEntity]
      ]);

      var participant = component.define('participant');
      participant.fields([
        ["date_time", "0..1", "h:time", shared.EffectiveTime],
        ["code", "1..1", "h:participantRole/h:code", shared.ConceptDescriptor],
        ["performer", "1..1", "h:participantRole", shared.assignedEntity],
        ["name", "0..*", "h:participantRole/h:playingEntity/h:name", shared.IndividualName]
      ]);

      var guarantor = component.define('guarantor');
      guarantor.fields([
        ["code", "1..1", "../h:assignedEntity/h:code", shared.ConceptDescriptor],
        ["identifiers", "0..*", "../h:assignedEntity/h:id", shared.Identifier],
        ["name", "0..*", "../h:assignedEntity/h:assignedPerson/h:name", shared.IndividualName],
        ["address", "0..*", "../h:assignedEntity/h:addr", shared.Address],
        ["email", "0..*", "../h:assignedEntity/" + shared.email.xpath(), shared.email],
        ["phone", "0..*", "../h:assignedEntity/" + shared.phone.xpath(), shared.phone]
      ]);

      var organization = component.define('organization');
      organization.fields([
        ["address", "0..1", "h:addr", shared.Address],
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["phone", "0..*", shared.phone.xpath(), shared.phone],
        ["email", "0..*", shared.email.xpath(), shared.email]
      ]);

      var insurance = component.define('insurance');
      insurance.fields([
        ["code", "1..1", "h:assignedEntity/h:code", shared.ConceptDescriptor],
        ["performer", "0..1", "h:assignedEntity", shared.assignedEntity]
      ]);

      var policy = component.define('policy');
      policy.fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["code", "1..1", "h:code", shared.ConceptDescriptor],
        ["insurance", "1..1", "h:performer", insurance]
      ]);

      var entry = component.define('entry');
      entry.templateRoot([clinicalStatementsIDs.CoverageActivity]);
      entry.fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["policy", "1..1", "h:entryRelationship/h:act", policy],
        ["guarantor", "1..1", "h:entryRelationship/h:act/h:performer/h:templateId[not (@root='2.16.840.1.113883.10.20.22.4.87')]", guarantor],
        ["participant", "1..1", "h:entryRelationship/h:act/h:participant", participant],
        ["policy_holder", "1..1", "h:entryRelationship/h:act/h:participant[not (@typeCode='COV')]", policy_holder],
        ["authorization", "1..1", "h:entryRelationship/h:act/h:entryRelationship/h:act", authorization]
      ]);

      var payers_section = component.define('payers_section');
      payers_section.templateRoot([sectionIDs.PayersSection, sectionIDs.PayersSectionEntriesOptional]);
      payers_section.fields([
        ["entry", "0..*", entry.xpath(), entry]
      ]);
      payers_section.cleanupStep(cleanup.replaceWithField('entry'));

      return [payers_section, entry];
    };

    exports.payers_section = exportPayersSection;
    exports.payers_entry = exportPayersSection;

  }, { "../cleanup": 15, "../shared": 29, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 23: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportPlanOfCareSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      var date_time = component.define('date_time');
      date_time.fields([
        ["point", "1..1", "h:effectiveTime", shared.EffectiveTime]
      ]);

      var entry = component.define('entry');
      // observation, act, encounter, procedure
      entry.templateRoot(['2.16.840.1.113883.10.20.22.4.44',
        '2.16.840.1.113883.10.20.22.4.39',
        '2.16.840.1.113883.10.20.22.4.40',
        '2.16.840.1.113883.10.20.22.4.41',
        clinicalStatementsIDs.PlanOfCareActivity
      ]);
      entry.fields([
        ["plan", "1..1", "h:code", shared.ConceptDescriptor],
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
        ['type', "1..1", "h:templateId/@root"]
      ]);

      entry.cleanupStep(function () {
        var typeMap = {
          "2.16.840.1.113883.10.20.22.4.44": "observation", // ccda
          "2.16.840.1.113883.10.20.22.4.39": "act",
          "2.16.840.1.113883.10.20.22.4.40": "encounter",
          "2.16.840.1.113883.10.20.22.4.41": "procedure",
          "2.16.840.1.113883.10.20.1.25": "observation", // ccda-r1
          "2.16.840.1.113883.3.62.3.16.1": "act"
        };
        var t = this.js['type'];
        this.js['type'] = typeMap[t];
      });

      var plan_of_care_section = component.define('plan_of_care_section');
      plan_of_care_section.templateRoot([sectionIDs.PlanOfCareSection, sectionIDs.PlanOfCareSectionEntriesOptional]);
      plan_of_care_section.fields([
        ["entry", "0..*", entry.xpath(), entry]
      ]);
      plan_of_care_section.cleanupStep(cleanup.replaceWithField('entry'));

      return [plan_of_care_section, entry];
    };

    exports.plan_of_care_section = exportPlanOfCareSection;
    exports.plan_of_care_entry = exportPlanOfCareSection;

  }, { "../cleanup": 15, "../shared": 29, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 24: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportProblemsSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      //These three elements aren't used right now, but can be refactored to use in standardized way.
      var AgeObservation = component.define("AgeObservation")
        .templateRoot("2.16.840.1.113883.10.20.22.4.31");

      var ProblemStatus = component.define("ProblemStatus")
        .templateRoot("2.16.840.1.113883.10.20.22.4.6")
        .fields([
          ["name", "0..1", "h:value/@displayName"],
          ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
        ]);

      var HealthStatus = component.define("HealthStatus")
        .templateRoot("2.16.840.1.113883.10.20.22.4.5");

      var ProblemObservation = component.define("ProblemObservation2")
        .fields([
          //["name", "0..1", "@displayName"],
          //["code", "1..1", "@code"],
          //["system", "1..1", "@codeSystem"],
          //["code_system_name", "0..1", "@codeSystemName"],
          //["nullFlavor", "0..1", "@nullFlavor"],
          ["code", "0..1", "../h:value", shared.ConceptDescriptor],
          ["date_time", "0..1", "../h:effectiveTime", shared.EffectiveTime],
        ]);
      //.cleanupStep(cleanup.augmentConcept).cleanupStep(cleanup.removeField('system'));

      //TODO:  Cleanup/investigate negation status.
      var ProblemConcernAct = component.define("ProblemConcernAct")
        .templateRoot([clinicalStatementsIDs.ProblemObservation])
        .fields([
          ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
          ["identifiers", "0..*", "h:entryRelationship/h:observation/h:id", shared.Identifier],
          ["negation_indicator", "0..1", "h:entryRelationship/h:observation", shared.NegationIndicator],
          ["problem", "1:1", "h:entryRelationship/h:observation/h:value", ProblemObservation],
          ["onset_age", "0..1", "h:entryRelationship/h:observation/h:entryRelationship/h:observation/h:templateId[@root='2.16.840.1.113883.10.20.22.4.31']/../h:value/@value"],
          ["onset_age_unit", "0..1", "h:entryRelationship/h:observation/h:entryRelationship/h:observation/h:templateId[@root='2.16.840.1.113883.10.20.22.4.31']/../h:value", shared.AgeDescriptor],
          ["status", "0..1", ProblemStatus.xpath(), ProblemStatus],
          ["patient_status", "0..1", "h:entryRelationship/h:observation/h:entryRelationship/h:observation/h:templateId[@root='2.16.840.1.113883.10.20.22.4.5']/../h:value/@displayName"],
          ["source_list_identifiers", "0..*", "h:id", shared.Identifier],
        ]);

      var NonProblemObservation = ProblemConcernAct
        .define("ProblemObservation");

      var ProblemOrganizer = component.define("ProblemOrganizer")
        .templateRoot([clinicalStatementsIDs.ProblemAct, clinicalStatementsIDs.ProblemConcernAct]);

      var problemsSection = component.define("problemsSection");
      problemsSection.templateRoot(["2.16.840.1.113883.10.20.22.2.5.1", "2.16.840.1.113883.10.20.1.11"]); // coded entries required
      problemsSection.fields([
        ["problems", "0..*", ProblemOrganizer.xpath(), ProblemConcernAct],
      ]);

      problemsSection.cleanupStep(cleanup.replaceWithField("problems"));
      return [problemsSection, ProblemConcernAct];
    };

    exports.problemsSection = exportProblemsSection;
    exports.problemsEntry = exportProblemsSection;

  }, { "../cleanup": 15, "../shared": 29, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 25: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportProceduresSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      /*
      var organization = component.define('organization');
      organization.fields([
          ["name", "0:1", "h:name"],
          ["address", "0..1", "h:addr", shared.Address],
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["phone", "0..*", shared.phone.xpath(), shared.phone],
          ["email", "0..*", shared.email.xpath(), shared.email]
      ]);
  
      //replaced with shared.assignedEntity to normalize with performer in other sections
      var provider = component.define('provider');
      provider.fields([
          ["address", "1..1", "h:addr", shared.Address],
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["phone", "0..*", shared.phone.xpath(), shared.phone],
          ["email", "0..*", shared.email.xpath(), shared.email],
          ["organization", "0..1", "h:representedOrganization", organization]
      ]);
      */

      var ProcedureSpecimen = component.define('ProcedureSpecimen')
        .fields([
          ["identifiers", "0..*", "h:specimenRole/h:id", shared.Identifier],
          ["code", "0..1", "h:specimenRole/h:specimenPlayingEntity/h:code", shared.ConceptDescriptor]
        ]);

      var entry = component.define('entry');
      entry.templateRoot(['2.16.840.1.113883.10.20.22.4.12', '2.16.840.1.113883.10.20.22.4.13', '2.16.840.1.113883.10.20.22.4.14', clinicalStatementsIDs.ProcedureActivity]);
      entry.fields([
        ["procedure", "1..1", "h:code", shared.ConceptDescriptor],
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["status", "1..1", "h:statusCode", shared.simplifiedCodeOID('2.16.840.1.113883.11.20.9.22')],
        ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
        ["body_sites", "0..*", "h:targetSiteCode", shared.ConceptDescriptor],
        ["specimen", "0..1", "h:specimen", ProcedureSpecimen],
        ["priority", "0..1", "h:priorityCode", shared.ConceptDescriptor],
        ["performers", "0..*", "h:performer/h:assignedEntity", shared.assignedEntity],
        ["locations", "0..*", "h:participant/h:participantRole", shared.serviceDeliveryLocation],
        ['procedure_type', "1..1", "h:templateId/@root"]
      ]);

      entry.cleanupStep(function () {
        var typeMap = {
          "2.16.840.1.113883.10.20.22.4.12": "act", // ccda
          "2.16.840.1.113883.10.20.22.4.13": "observation",
          "2.16.840.1.113883.10.20.22.4.14": "procedure",
          "2.16.840.1.113883.10.20.1.29": "procedure" // ccda-r1
        };
        var t = this.js['procedure_type'];
        this.js['procedure_type'] = typeMap[t];
      });

      var proceduresSection = component.define('proceduresSection');
      proceduresSection.templateRoot([sectionIDs.ProceduresSection, sectionIDs.ProceduresSectionEntriesOptional]);
      proceduresSection.fields([
        ["entry", "0..*", entry.xpath(), entry]
      ]);
      proceduresSection.cleanupStep(cleanup.replaceWithField('entry'));
      return [proceduresSection, entry];
    };

    exports.proceduresSection = exportProceduresSection;
    exports.proceduresEntry = exportProceduresSection;

  }, { "../cleanup": 15, "../shared": 29, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 26: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportResultsSection = function (version) {
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];
      var sectionIDs = bbm.CCDA["sections" + version];

      var referenceRange = component.define('referenceRange')
        .fields([
          ["low", "0..1", "h:value/h:low/@value"],
          ["high", "0..1", "h:value/h:high/@value"],
          ["unit", "0..1", "h:value/h:low/@unit"],
          ["range", "0..1", "h:text/text()"]
        ]);

      var ResultObservation = component.define("ResultObservation")
        .templateRoot(clinicalStatementsIDs["ResultObservation"])
        .fields([
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["result", "1..1", "h:code", shared.ConceptDescriptor],
          ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
          ["physicalQuantity", "1..1", "h:value[@xsi:type='PQ']", shared.PhysicalQuantity],
          ["status", "1..1", "h:statusCode/@code"],
          ["text", "1..1", "h:value[@xsi:type='ST']", shared.TextWithReference],
          ["reference_range", "0..1", "h:referenceRange/h:observationRange", referenceRange],
          //["codedValue", "0..1", "h:value[@xsi:type='CD']", shared.ConceptDescriptor],
          //["freeTextValue", "0..1", "h:text", shared.TextWithReference],
          ["interpretations", "0..*", "h:interpretationCode[@codeSystem='2.16.840.1.113883.5.83']", shared.SimplifiedCode]
        ]);
      //ResultObservation.cleanupStep(cleanup.extractAllFields(['resultName']));

      // TODO: Accomodating both PQ and CD values needed
      ResultObservation.cleanupStep(cleanup.extractAllFields(['physicalQuantity']));
      //ResultObservation.cleanupStep(cleanup.extractAllFields(['codedValue']));

      var ResultsOrganizer = component.define("ResultsOrganizer")
        .templateRoot(clinicalStatementsIDs["ResultOrganizer"])
        .fields([
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["result_set", "0..1", "h:code", shared.ConceptDescriptor],
          ["results", "1..*", ResultObservation.xpath(), ResultObservation]
        ]);
      //ResultsOrganizer.cleanupStep(cleanup.extractAllFields(['panelName']));

      var resultsSection = component.define("resultsSection");
      resultsSection.templateRoot([sectionIDs.ResultsSection, sectionIDs.ResultsSectionEntriesOptional]); // .1 for "entries required"
      resultsSection.fields([
        ["panels", "0..*", ResultsOrganizer.xpath(), ResultsOrganizer]
      ]);
      resultsSection.cleanupStep(cleanup.replaceWithField('panels'));

      return [resultsSection, ResultsOrganizer];
    };

    exports.resultsSection = exportResultsSection;
    exports.resultsEntry = exportResultsSection;

  }, { "../cleanup": 15, "../shared": 29, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 27: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportSocialHistorySection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      var socialHistoryObservation = component.define("socialHistoryObservation")
        .templateRoot([
          clinicalStatementsIDs.SocialHistoryObservation, // the correct templateId (smoking status)
          clinicalStatementsIDs.SmokingStatusObservation,
          "2.16.840.1.113883.10.22.4.78", // incorrect id published in 1.1 DSTU
        ])
        .fields([
          //["value", "1..1", "h:code[@code!='ASSERTION']/@displayName"],//, shared.SimpleCode("2.16.840.1.113883.11.20.9.38")],
          //["value2", "1..1", "h:code[@code='ASSERTION']/@codeSystem"],//, shared.SimpleCode("2.16.840.1.113883.11.20.9.38")],
          ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["code", "0..1", "h:code", shared.ConceptDescriptor],
          ["code2", "0..1", "h:code[@code='ASSERTION']/@codeSystem"],
          //["observation_value", "0..1", "h:value/@xsi:type"]
          ["value", "0..1", "h:value[@xsi:type='ST']/text() | h:value[@xsi:type='CD']/@displayName"]
          //["observation_value2", "0..1", "h:value[@xsi:type='CD']/@displayName"]
        ]).cleanupStep(cleanup.replaceWithObject("code2", {
          "name": "Smoking Status"
        })).cleanupStep(cleanup.renameField("code2", "code"));

      // when other flavors of social history is implemented (pregnancy, social observation, tobacco use) 
      // this should probably be structured similar to procedures with types.  if another structure
      // is chosen procedures need to be updated as well.
      var socialHistorySection = component.define("socialHistorySection")
        .templateRoot([sectionIDs.SocialHistorySection, sectionIDs.SocialHistorySectionEntriesOptional])
        .fields([
          ["smoking_statuses", "0..*", socialHistoryObservation.xpath(), socialHistoryObservation]
        ]);
      socialHistorySection.cleanupStep(cleanup.replaceWithField('smoking_statuses'));

      return [socialHistorySection, socialHistoryObservation];
    };
    exports.socialHistorySection = exportSocialHistorySection;

  }, { "../cleanup": 15, "../shared": 29, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 28: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportVitalSignsSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      var VitalSignObservation = component.define("VitalSignObservation")
        .templateRoot(clinicalStatementsIDs.VitalSignObservation)
        .fields([
          ["identifiers", "0..*", "h:id", shared.Identifier], //this one is stripped out by "paredown" cleanup step in component.js
          ["vital", "1..1", "h:code", shared.ConceptDescriptor],
          //["identifiers","0..*", "h:id", shared.Identifier], //dup with first line
          ["status", "1..1", "h:statusCode/@code"],
          ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
          ["physicalQuantity", "1..1", "h:value[@xsi:type='PQ']", shared.PhysicalQuantity],
          //["freeTextValue", "0..1", "h:text", shared.TextWithReference],
          ["interpretations", "0..*", "h:interpretationCode[@codeSystem='2.16.840.1.113883.5.83']", shared.SimplifiedCode]
        ]);
      //VitalSignObservation.cleanupStep(cleanup.extractAllFields(['code']));
      VitalSignObservation.cleanupStep(cleanup.extractAllFields(['physicalQuantity']));

      var vitalSignsSection = component.define("vitalSignsSection");
      vitalSignsSection.templateRoot([sectionIDs.VitalSignsSection, sectionIDs.VitalSignsSectionEntriesOptional]);
      vitalSignsSection.fields([
        ["entry", "0..*", VitalSignObservation.xpath(), VitalSignObservation]
      ]);
      vitalSignsSection.cleanupStep(cleanup.replaceWithField('entry'));
      return [vitalSignsSection, VitalSignObservation];
    };

    // var VitalSignObservation = component.define("VitalSignObservation")
    //     .templateRoot(clinicalStatementsIDs.VitalSignObservation)
    //     .fields([
    //         ["identifiers", "0..*", "h:id", shared.Identifier], //this one is stripped out by "paredown" cleanup step in component.js
    //         ["vital", "1..1", "h:code", shared.ConceptDescriptor],
    //         //["identifiers","1..*", "h:id", shared.Identifier], //dup with first line
    //         ["status", "1..1", "h:statusCode/@code"],
    //         ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
    //         ["physicalQuantity", "1..1", "h:value[@xsi:type='PQ']", shared.PhysicalQuantity],
    //         //["freeTextValue", "0..1", "h:text", shared.TextWithReference],
    //         ["interpretations", "0..*", "h:interpretationCode[@codeSystem='2.16.840.1.113883.5.83']", shared.SimplifiedCode]
    //     ]);
    //   //VitalSignObservation.cleanupStep(cleanup.extractAllFields(['code']));
    //   VitalSignObservation.cleanupStep(cleanup.extractAllFields(['physicalQuantity']));

    /*
      //Vitals organizer is not used (flattened out in JSON model)
      var VitalSignsOrganizer = component.define("VitalSignsOrganizer")
      .templateRoot("2.16.840.1.113883.10.20.22.4.26")
      .fields([
        ["panelName","0..1", "h:code", shared.ConceptDescriptor],
        ["sourceIds","1..*", "h:id", shared.Identifier],
        ["vitals", "1..*", VitalSignObservation.xpath(), VitalSignObservation]
      ]);
      
      
      exports.VitalSignsSection = Component.define("VitalSignsSection")
      .templateRoot("2.16.840.1.113883.10.20.22.2.4.1")
      .fields([
        //["name","0..1", "h:code", shared.ConceptDescriptor],
        //["panels","0..*", VitalSignsOrganizer.xpath(), VitalSignsOrganizer],
        ["vitals","0..*", VitalSignObservation.xpath(), VitalSignObservation],
      ]);
      */

    exports.vitalSignsSection = exportVitalSignsSection;

    exports.vitalSignsEntry = exportVitalSignsSection;

  }, { "../cleanup": 15, "../shared": 29, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 29: [function (require, module, exports) {
    "use strict";

    var component = require("@amida-tech/blue-button-xml").component;
    var processor = require("@amida-tech/blue-button-xml").processor;
    var cleanup = require("./cleanup");
    var common = require("@amida-tech/blue-button-xml").common;

    var commonShared = require('../common/shared');

    var shared = module.exports = Object.create(commonShared);

    var TextWithReference = shared.TextWithReference = component.define("TextWithReference");
    TextWithReference.fields([
      ["text", "0..*", "text()"],
      ["reference", "0..1", "./h:reference/@value"],
    ])
      .cleanupStep(cleanup.resolveReference);

    var NegationIndicator = shared.NegationIndicator = component.define("NegationIndicator");
    NegationIndicator.fields([
      ["negation_indicator", "0..1", "@negationInd", processor.asBoolean]
    ]).cleanupStep(function () {
      //Flag missing negations as false.
      if (this.js) {
        if (!common.exists(this.js)) {
          this.js.negation_indicator = false;
        }
        if (this.js.negation_indicator === 'true') {
          this.js.negation_indicator = true;
        }
      }
    })
      .cleanupStep(cleanup.replaceWithField('negation_indicator'));

    var conceptWoutTranslation = component.define("conceptWoutTranslation");
    conceptWoutTranslation.fields([
      ["name", "0..1", "@displayName"],
      ["code", "1..1", "@code"],
      ["system", "1..1", "@codeSystem"],
      ["code_system_name", "0..1", "@codeSystemName"],
      ["nullFlavor", "0..1", "@nullFlavor"],
    ]);
    conceptWoutTranslation.cleanupStep(cleanup.augmentConcept);
    conceptWoutTranslation.cleanupStep(cleanup.removeField('system'));

    var ConceptDescriptor = shared.ConceptDescriptor = conceptWoutTranslation.define("ConceptDescriptor");
    ConceptDescriptor.fields([
      ["translations", "0..*", "h:translation", conceptWoutTranslation],
    ]);

    var AgeDescriptor = shared.AgeDescriptor = component.define("AgeDescriptor");
    AgeDescriptor.fields([
      ["units", "0..1", "@unit"],
    ])
      .cleanupStep(cleanup.augmentAge);

    var SimplifiedCode = shared.SimplifiedCode = ConceptDescriptor.define("SimpifiedCode")
      .cleanupStep(cleanup.augmentSimplifiedCode);

    var PhysicalQuantity = shared.PhysicalQuantity = component.define("PhysicalQuantity")
      .fields([
        ["value", "1..1", "@value", processor.asFloat],
        ["unit", "0..1", "@unit"]
      ]);

    var EventOffset = shared.EventOffset = component.define("EventOffset")
      .fields([
        ["low", "0..1", "h:/low", PhysicalQuantity],
        ["high", "0..1", "h:/high", PhysicalQuantity],
        ["center", "0..1", "h:/center", PhysicalQuantity],
        ["width", "0..1", "h:/width", PhysicalQuantity],
      ]);

    var EffectiveTime = shared.EffectiveTime = component.define("EffectiveTime")
      .fields([
        ["point", "0..1", "@value", processor.asTimestamp],
        ["point_resolution", "0..1", "@value", processor.asTimestampResolution],
        ["low", "0..1", "h:low/@value", processor.asTimestamp],
        ["low_resolution", "0..1", "h:low/@value", processor.asTimestampResolution],
        ["high", "0..1", "h:high/@value", processor.asTimestamp],
        ["high_resolution", "0..1", "h:high/@value", processor.asTimestampResolution],
        ["center", "0..1", "h:center/@value", processor.asTimestamp],
        ["center_resolution", "0..1", "h:center/@value", processor.asTimestampResolution]
      ])
      .cleanupStep(cleanup.augmentEffectiveTime);

    var IndividualName = shared.IndividualName = component.define('IndividualName')
      .fields([
        ["prefix", "0..1", "h:prefix/text()"],
        ["middle", "0..*", "h:given/text()"],
        ["last", "0..1", "h:family/text()"],
        ["suffix", "0..1", "h:suffix/text()"],
        ["freetext_name", "0..1", "../h:name/text()", processor.asString]
      ]).cleanupStep(cleanup.augmentIndividualName);

    var Address = shared.Address = component.define("Address")
      .fields([
        ["street_lines", "1..4", "h:streetAddressLine/text()"],
        ["city", "1..1", "h:city/text()", processor.asString],
        ["state", "0..1", "h:state/text()"],
        ["zip", "0..1", "h:postalCode/text()"],
        ["country", "0..1", "h:country/text()"],
        ["use", "0..1", "@use", shared.SimpleCode("2.16.840.1.113883.5.1119")]
      ]);

    var Organization = shared.Organization = component.define("Organization")
      .fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["name", "0..*", "h:name/text()"],
        ["address", "0..*", "h:addr", Address],
        ["email", "0..*", shared.email.xpath(), shared.email],
        ["phone", "0..*", shared.phone.xpath(), shared.phone]
      ]);

    var assignedEntity = shared.assignedEntity = component.define("assignedEntity")
      .fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["name", "0..*", "h:assignedPerson/h:name", IndividualName],
        ["address", "0..*", "h:addr", Address],
        ["email", "0..*", shared.email.xpath(), shared.email],
        ["phone", "0..*", shared.phone.xpath(), shared.phone],
        ["organization", "0..*", "h:representedOrganization", Organization],
        ["code", "0..*", "h:code", ConceptDescriptor],
      ]);

    shared.serviceDeliveryLocation = component.define('serviceDeliveryLocation')
      .fields([
        ["name", "0:1", "h:playingEntity/h:name/text()"],
        ["location_type", "1..1", "h:code", ConceptDescriptor],
        ["address", "0..*", "h:addr", Address],
        ["email", "0..*", shared.email.xpath(), shared.email],
        ["phone", "0..*", shared.phone.xpath(), shared.phone]
      ]);

  }, { "../common/shared": 42, "./cleanup": 15, "blue-button-xml": "blue-button-xml" }], 30: [function (require, module, exports) {
    "use strict";

    var component = require("@amida-tech/blue-button-xml").component;
    var shared = require("./shared");

    var exportCCD = function (version) {
      var patient = require("./demographics").patient;
      var resultsSection = require("./sections/results").resultsSection(version)[0];
      var problemsSection = require("./sections/problems").problemsSection(version)[0];
      var encountersSection = require("./sections/encounters").encountersSection(version)[0];
      var proceduresSection = require("./sections/procedures").proceduresSection(version)[0];
      var medicationsSection = require("./sections/medications").medicationsSection(version)[0];
      var providersSection = require("./sections/providers").providersSection(version)[0];
      var payers_section = require("./sections/payers").payers_section(version)[0];

      return component.define("CCD")
        .fields([
          ["meta", "0..1", ".", shared.metaData],
          ["demographics", "1..1", "(/ | //h:recordTarget/h:patientRole)[last()]", patient],
          ["providers", "0..*", "//h:documentationOf/h:serviceEvent/h:performer", providersSection],
          ["problems", "0..1", problemsSection.xpath(), problemsSection],
          ["encounters", "0..1", encountersSection.xpath(), encountersSection],
          ["medications", "0..1", medicationsSection.xpath(), medicationsSection],
          ["procedures", "0..1", proceduresSection.xpath(), proceduresSection],
          ["results", "0..1", resultsSection.xpath(), resultsSection],
          ["payers", "0..1", payers_section.xpath(), payers_section],
        ]);

    };

    exports.CCD = exportCCD;

  }, { "./demographics": 32, "./sections/encounters": 33, "./sections/medications": 34, "./sections/payers": 35, "./sections/problems": 36, "./sections/procedures": 37, "./sections/providers": 38, "./sections/results": 39, "./shared": 40, "blue-button-xml": "blue-button-xml" }], 31: [function (require, module, exports) {
    "use strict";

    var includeCleanup = require("../common/cleanup");

    var cleanup = module.exports = Object.create(includeCleanup);

    cleanup.augmentObservation = function () {

      if (this.js.problem_text) {
        if (this.js.problem_text.js) {
          if (!this.js.code.js.name) {
            this.js.code.js.name = this.js.problem_text.js;
          }
        }
      }

    };

  }, { "../common/cleanup": 41 }], 32: [function (require, module, exports) {
    arguments[4][4][0].apply(exports, arguments)
  }, { "./shared": 40, "blue-button-xml": "blue-button-xml", "dup": 4 }], 33: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportEncountersSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      var finding = component.define("finding");
      finding.templateRoot("2.16.840.1.113883.10.20.1.28");
      finding.fields([
        ["identifiers", "1..*", "h:id", shared.Identifier],
        ["value", "1..1", "h:value", shared.ConceptDescriptor],
        ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime]
      ]);

      // Iff needed add this later by refactoring Problem Observation from Problems.  They should share.
      //var diagnosis = component.define("diagnosis");
      //finding.templateRoot(['2.16.840.1.113883.10.20.22.4.80']);
      //finding.fields([
      //  ["code", "1..1", "h:code", shared.ConceptDescriptor]
      //]);
      //finding.cleanupStep(cleanup.extractAllFields(['code']));

      var activity = component.define('activity');
      activity.templateRoot(["2.16.840.1.113883.10.20.1.21"]);
      activity.fields([
        ["encounter", "1..1", "h:code", shared.ConceptDescriptor],
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
        ["performers", "0..*", "h:performer/h:assignedEntity", shared.assignedEntity],
        ["locations", "0..*", "h:participant/h:participantRole", shared.serviceDeliveryLocation],
        ["findings", "0..*", finding.xpath(), finding]
        //["diagnoses", "0..*", diagnosis.xpath(), diagnosis]
      ]);

      var encountersSection = component.define('encountersSection');
      encountersSection.templateRoot(["2.16.840.1.113883.10.20.1.3"]);
      encountersSection.fields([
        ["activity", "0..*", activity.xpath(), activity]
      ]);
      encountersSection.cleanupStep(cleanup.replaceWithField(["activity"]));
      return [encountersSection, activity];
    };
    exports.encountersSection = exportEncountersSection;
    exports.encountersEntry = exportEncountersSection;

  }, { "../cleanup": 31, "../shared": 40, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 34: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var processor = require("@amida-tech/blue-button-xml").processor;
    var bbm = require("@amida-tech/blue-button-meta");
    var _ = require("lodash");

    var exportMedicationsSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      var MedicationInterval = component.define("MedicationInterval")
        .fields([
          ["phase", "0..1", "./h:phase", shared.EffectiveTime],
          ["period", "0..1", "./h:period", shared.PhysicalQuantity],
          ["alignment", "0..1", "./@alignment"],
          ["frequency", "0..1", "./@institutionSpecified", processor.asBoolean],
          ["event", "0..1", "./h:event/@code", shared.SimpleCode("2.16.840.1.113883.5.139")],
          ["event_offset", "0..1", "./h:offset", shared.EventOffset]
        ]);

      var MedicationAdministration = component.define("MedicationAdministration")
        .fields([
          ["route", "0..1", "h:routeCode", shared.ConceptDescriptor],
          ["site", "0..1", "h:approachSiteCode", shared.ConceptDescriptor],
          ["form", "0..1", "h:administrationUnitCode", shared.ConceptDescriptor],
          ["dose", "0..1", "h:doseQuantity", shared.PhysicalQuantity],
          ["rate", "0..1", "h:rateQuantity", shared.PhysicalQuantity],
          ["dose_restriction", "0..1", "h:maxDoseQuantity", shared.PhysicalQuantity],
          ["interval", "0..1", "h:effectiveTime[@operator='A']", MedicationInterval],
        ]);

      var MedicationIndication = component.define("MedicationIndication")
        .fields([
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["code", "0..1", "h:code", shared.ConceptDescriptor],
          ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
          ["value", "0..1", "h:value", shared.ConceptDescriptor]
        ]);

      var MedicationPrecondition = component.define("MedicationPrecondition")
        .fields([
          ["code", "0..1", "h:code", shared.ConceptDescriptor],
          ["text", "0..1", "h:text"],
          ["value", "0..1", "h:value", shared.ConceptDescriptor]
        ]);

      var author = component.define("author")
        .fields([
          ["date_time", "0..1", "h:time", shared.EffectiveTime],
          ["identifiers", "0..*", "h:assignedAuthor/h:id", shared.Identifier],
          ["organization", "0..1", "h:assignedAuthor/h:representedOrganization", shared.Organization]
        ]);

      var MedicationInformation = component.define("MedicationInformation")
        .templateRoot("2.16.840.1.113883.10.20.22.4.23")
        .fields([
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["unencoded_name", "0..1", "h:manufacturedMaterial/h:code/h:originalText", shared.TextWithReference],
          ["product", "1..1", "h:manufacturedMaterial/h:code", shared.ConceptDescriptor],
          ["manufacturer", "0..1", "h:manufacturerOrganization/h:name"]
        ]);

      var MedicationSupplyOrder = component.define("MedicationSupplyOrder")
        .fields([
          ["identifiers", "0..*", "h:assignedEntity/h:id", shared.Identifier],
          ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
          ["repeatNumber", "0..1", "h:repeatNumber/@value"],
          ["quantity", "0..1", "h:quantity/@value"],
          ["status", "0..1", "h:status/@code"],
          ["author", "0..1", "h:author", author] //, instructions use references, which are not supported (also samples don't have good data for it)
          //["instructions", "0..1", "h:entryRelationship[@typeCode='SUBJ']/h:act", MedicationInstructions]
        ]);

      var MedicationPerformer = component.define("MedicationPerformer")
        .fields([
          ["identifiers", "0..*", "h:assignedEntity/h:id", shared.Identifier],
          ["address", "0..*", "h:assignedEntity/h:addr", shared.Address],
          ["phone", "0..1", "h:assignedEntity/" + shared.phone.xpath(), shared.phone],
          ["organization", "0..*", "h:assignedEntity/h:representedOrganization", shared.Organization]
        ]);
      /*
          var MedicationDrugVehicle = component.define("MedicationDrugVehicle")
              .templateRoot("2.16.840.1.113883.10.20.22.4.24")
              .fields([
                  ["playingEntity", "0..1", "h:playingEntity/h:code", shared.ConceptDescriptor]
              ]).cleanupStep(cleanup.extractAllFields(["drug_vehicle"]));
  */
      var MedicationInstructions = component.define("MedicationInstructions")
        .fields([
          ["code", "0..1", "../h:code", shared.ConceptDescriptor],
          ["freeText", "0..1", "../h:text", shared.TextWithReference]
        ]);

      var MedicationDispense = component.define("MedicationDispense")
        .templateRoot("2.16.840.1.113883.10.20.22.4.18")
        .fields([
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["performer", "0..1", "h:performer", MedicationPerformer],
          ["supply", "0..1", "h:entryRelationship[@typeCode='REFR']/h:supply", MedicationSupplyOrder]
        ]);

      var MedicationActivity = component.define("MedicationActivity")
        .templateRoot("2.16.840.1.113883.10.20.1.34")
        .fields([
          ["date_time", "0..1", "h:effectiveTime[not (@operator='A')]", shared.EffectiveTime],
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["status", "1..1", "./../h:supply/@moodCode"],
          //["sig", "0..1", "h:text", shared.TextWithReference],
          ["product", "1..1", "h:product/h:manufacturedProduct", MedicationInformation],
          ["supply", "0..1", "./../h:supply", MedicationSupplyOrder],
          //["administration", "0..1", "../h:substanceAdministration", MedicationAdministration],
          //["performer", "0..1", "h:performer", MedicationPerformer],
          //["drug_vehicle", "0..1", "h:participant[@typeCode='CSM']/h:participantRole/h:playingEntity[@classCode='MMAT']/h:code", shared.ConceptDescriptor],
          //["precondition", "1..1", "h:precondition/h:criterion", MedicationPrecondition],
          //["indication", "0..1", "h:entryRelationship[@typeCode='RSON']/h:observation", MedicationIndication],
          //["instructions", "0..1", "h:entryRelationship[@typeCode='REFR']/h:supply/*/*/h:templateId[@root='2.16.840.1.113883.10.20.22.4.20']", MedicationInstructions],
          //["dispense", "0..1", MedicationDispense.xpath(), MedicationDispense]
        ])
        //.cleanupStep(Cleanup.extractAllFields(["medicationName"]))
        .cleanupStep(function () {

          //Cleanup Status.

          if (_.get(this, "js.status") === "EVN") {
            this.js.status = "Completed";
          }
          if (_.get(this, "js.status") === "INT") {
            this.js.status = "Prescribed";
          }

          // separate out two effectiveTimes

          /*
        // 1.  startDate --- endDate
        var range = this.js.times.filter(function(t){
          return -1 === ['PIVL_TS', 'EIVL_TS'].indexOf(t.js.xsitype);
        });

        // 2.  dosing interval
        var period= this.js.times.filter(function(t){
          return -1 !== ['PIVL_TS', 'EIVL_TS'].indexOf(t.js.xsitype);
        });

        delete this.js.times;

        if (range.length > 0) {
          this.js.dateRange = range[0];
        }

        if (period.length > 0) {
          this.js.dosePeriod = period[0].js.period;
        }*/

        });

      var medicationsSection = component.define("medicationsSection");
      medicationsSection.templateRoot(["2.16.840.1.113883.10.20.1.8"]);
      medicationsSection.fields([
        ["medications", "0..*", MedicationActivity.xpath(), MedicationActivity]
      ]);
      medicationsSection.cleanupStep(cleanup.replaceWithField('medications'));
      return [medicationsSection, MedicationActivity];

    };

    exports.medicationsSection = exportMedicationsSection;
    exports.medicationsEntry = exportMedicationsSection;

  }, { "../cleanup": 31, "../shared": 40, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml", "lodash": 95 }], 35: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportPayersSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      var procedure = component.define('procedure');
      procedure.fields([
        ["code", "1..1", "h:code", shared.ConceptDescriptor]
      ]);

      var authorization = component.define('authorization');
      authorization.fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["procedure", "1..1", "h:entryRelationship/h:procedure", procedure]
      ]);

      var policy_holder = component.define('policy_holder');
      policy_holder.fields([
        ["performer", "1..1", "h:participantRole", shared.assignedEntity]
      ]);

      var participant = component.define('participant');
      participant.fields([
        ["date_time", "0..1", "h:time", shared.EffectiveTime],
        ["code", "1..1", "h:participantRole/h:code", shared.ConceptDescriptor],
        ["performer", "1..1", "h:participantRole", shared.assignedEntity],
        ["name", "0..*", "h:participantRole/h:playingEntity/h:name", shared.IndividualName]
      ]);

      var guarantor = component.define('guarantor');
      guarantor.fields([
        ["code", "1..1", "../h:assignedEntity/h:code", shared.ConceptDescriptor],
        ["identifiers", "0..*", "../h:assignedEntity/h:id", shared.Identifier],
        ["name", "0..*", "../h:assignedEntity/h:assignedPerson/h:name", shared.IndividualName],
        ["address", "0..*", "../h:assignedEntity/h:addr", shared.Address],
        ["email", "0..*", "../h:assignedEntity/" + shared.email.xpath(), shared.email],
        ["phone", "0..*", "../h:assignedEntity/" + shared.phone.xpath(), shared.phone]
      ]);

      var organization = component.define('organization');
      organization.fields([
        ["address", "0..1", "h:addr", shared.Address],
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["phone", "0..*", shared.phone.xpath(), shared.phone],
        ["email", "0..*", shared.email.xpath(), shared.email]
      ]);

      var insurance = component.define('insurance');
      insurance.fields([
        ["code", "1..1", "h:assignedEntity/h:code", shared.ConceptDescriptor],
        ["performer", "0..1", "h:assignedEntity", shared.assignedEntity]
      ]);

      var policy = component.define('policy');
      policy.fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["code", "1..1", "h:code", shared.ConceptDescriptor],
        ["insurance", "1..1", "h:performer", insurance]
      ]);

      var entry = component.define('entry');
      entry.templateRoot("2.16.840.1.113883.10.20.1.20");
      entry.fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["policy", "1..1", "h:entryRelationship/h:act", policy],
        ["guarantor", "1..1", "h:entryRelationship/h:act/h:performer/h:templateId[not (@root='2.16.840.1.113883.10.20.22.4.87')]", guarantor],
        ["participant", "1..1", "h:entryRelationship/h:act/h:participant", participant],
        ["policy_holder", "1..1", "h:entryRelationship/h:act/h:participant[not (@typeCode='COV')]", policy_holder],
        ["authorization", "1..1", "h:entryRelationship/h:act/h:entryRelationship/h:act", authorization]
      ]);

      var payers_section = component.define('payers_section');
      payers_section.templateRoot("2.16.840.1.113883.10.20.1.9");
      payers_section.fields([
        ["entry", "0..*", entry.xpath(), entry]
      ]);
      payers_section.cleanupStep(cleanup.replaceWithField('entry'));

      return [payers_section, entry];
    };

    exports.payers_section = exportPayersSection;
    exports.payers_entry = exportPayersSection;

  }, { "../cleanup": 31, "../shared": 40, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 36: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportProblemsSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      //These three elements aren't used right now, but can be refactored to use in standardized way.
      var AgeObservation = component.define("AgeObservation")
        .templateRoot("2.16.840.1.113883.10.20.1.38");

      var ProblemStatus = component.define("ProblemStatus")
        .templateRoot("2.16.840.1.113883.10.20.1.50")
        .fields([
          ["name", "0..1", "h:value/@displayName"],
          ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
        ]);

      var ProblemObservation = component.define("ProblemObservation")
        .fields([
          ["code", "0..1", "../h:value", shared.ConceptDescriptor],
          ["problem_text", "0..1", "../h:text", shared.TextWithReference],
          ["date_time", "0..1", "../h:effectiveTime", shared.EffectiveTime],
        ]).cleanupStep(cleanup.augmentObservation).cleanupStep(cleanup.removeField("problem_text"));

      //TODO:  Cleanup/investigate negation status.
      var ProblemConcernAct = component.define("ProblemConcernAct")
        .fields([
          ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
          ["identifiers", "0..*", "h:entryRelationship/h:observation/h:id", shared.Identifier],
          ["negation_indicator", "0..1", "h:entryRelationship/h:observation", shared.NegationIndicator],
          ["problem", "1:1", "h:entryRelationship/h:observation/h:value", ProblemObservation],
          ["onset_age", "0..1", "h:entryRelationship/h:observation/h:entryRelationship/h:observation/h:templateId[@root='2.16.840.1.1 13883.10.20.1.38']/../h:value/@value"],
          ["onset_age_unit", "0..1", "h:entryRelationship/h:observation/h:entryRelationship/h:observation/h:templateId[@root='2.16.840.1.1 13883.10.20.1.38']/../h:value", shared.AgeDescriptor],
          ["status", "0..1", ProblemStatus.xpath(), ProblemStatus],
          //Patient Status not supported.
          //["patient_status", "0..1", "h:entryRelationship/h:observation/h:entryRelationship/h:observation/h:templateId[@root='2.16.840.1.113883.10.20.22.4.5']/../h:value/@displayName"],
          ["source_list_identifiers", "0..*", "h:id", shared.Identifier],
        ]);

      var NonProblemObservation = ProblemConcernAct
        .define("ProblemObservation");

      var ProblemOrganizer = component.define("ProblemOrganizer")
        .templateRoot(["2.16.840.1.113883.10.20.1.27"]);

      var problemsSection = component.define("problemsSection");
      problemsSection.templateRoot(["2.16.840.1.113883.10.20.1.11"]); // coded entries required
      problemsSection.fields([
        ["problems", "0..*", ProblemOrganizer.xpath(), ProblemConcernAct],
      ]);

      problemsSection.cleanupStep(cleanup.replaceWithField("problems"));
      return [problemsSection, ProblemConcernAct];
    };

    exports.problemsSection = exportProblemsSection;
    exports.problemsEntry = exportProblemsSection;

  }, { "../cleanup": 31, "../shared": 40, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 37: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportProceduresSection = function (version) {
      var sectionIDs = bbm.CCDA["sections" + version];
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];

      var entry = component.define('entry');
      entry.templateRoot(["2.16.840.1.113883.10.20.1.29"]);
      entry.fields([
        ["procedure", "1..1", "h:code", shared.ConceptDescriptor],
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["status", "1..1", "h:statusCode", shared.simplifiedCodeOID('2.16.840.1.113883.11.20.9.22')],
        ["date_time", "0..1", "h:effectiveTime", shared.EffectiveTime],
        ["body_sites", "0..*", "h:targetSiteCode", shared.ConceptDescriptor],

        //Doesn't appear in sample data.
        //["specimen", "0..1", "h:specimen", ProcedureSpecimen],
        //Doesn't appear in sample data.
        //["priority", "0..1", "h:priorityCode", shared.ConceptDescriptor],
        ["performers", "0..*", "h:performer/h:assignedEntity", shared.assignedEntity],
        //Doesn't appear in sample data.
        //["locations", "0..*", "h:participant/h:participantRole", shared.serviceDeliveryLocation],
        ['procedure_type', "1..1", "h:templateId/@root"]
      ]);

      entry.cleanupStep(function () {
        var typeMap = {
          "2.16.840.1.113883.10.20.1.29": "procedure" // ccda-r1
        };
        var t = this.js['procedure_type'];
        this.js['procedure_type'] = typeMap[t];
      });

      var proceduresSection = component.define('proceduresSection');
      proceduresSection.templateRoot(["2.16.840.1.113883.10.20.1.12"]);
      proceduresSection.fields([
        ["entry", "0..*", entry.xpath(), entry]
      ]);
      proceduresSection.cleanupStep(cleanup.replaceWithField('entry'));
      return [proceduresSection, entry];
    };

    exports.proceduresSection = exportProceduresSection;
    exports.proceduresEntry = exportProceduresSection;

  }, { "../cleanup": 31, "../shared": 40, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 38: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportProvidersSection = function (version) {

      var providers = component.define("providers")
        .templateRoot(["2.16.840.1.113883.5.90"])
        .fields([
          ["date_time", "0..1", "h:time", shared.EffectiveTime],
          ["identifiers", "0..*", "h:assignedEntity/h:id", shared.Identifier],
          ["type", "0..1", "h:assignedEntity/h:code", shared.ConceptDescriptor],
          ["role", "0..1", "h:functionCode/h:code", shared.ConceptDescriptor],
          ["name", "0..1", "h:assignedEntity/h:assignedPerson/h:name", shared.IndividualName],
          ["addresses", "0..*", "h:assignedEntity/h:addr", shared.Address],
          ["phone", "0..*", "h:assignedEntity/" + shared.phone.xpath(), shared.phone],
          ["email", "0..*", "h:assignedEntity/" + shared.email.xpath(), shared.email],
          ["organization", "0..1", "h:assignedEntity/h:representedOrganization", shared.Organization]
        ]);

      return [providers];
    };

    exports.providersSection = exportProvidersSection;

  }, { "../cleanup": 31, "../shared": 40, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 39: [function (require, module, exports) {
    "use strict";

    var shared = require("../shared");
    var component = require("@amida-tech/blue-button-xml").component;
    var cleanup = require("../cleanup");
    var bbm = require("@amida-tech/blue-button-meta");

    var exportResultsSection = function (version) {
      var clinicalStatementsIDs = bbm.CCDA["statements" + version];
      var sectionIDs = bbm.CCDA["sections" + version];

      var referenceRange = component.define('referenceRange')
        .fields([
          ["low", "0..1", "h:value/h:low/@value"],
          ["high", "0..1", "h:value/h:high/@value"],
          ["unit", "0..1", "h:value/h:low/@unit"],
          ["range", "0..1", "h:text/text()"]
        ]);

      var ResultObservation = component.define("ResultObservation")
        .templateRoot("2.16.840.1.113883.10.20.1.31")
        .fields([
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["result", "1..1", "h:code", shared.ConceptDescriptor],
          ["date_time", "1..1", "h:effectiveTime", shared.EffectiveTime],
          ["physicalQuantity", "1..1", "h:value[@xsi:type='PQ']", shared.PhysicalQuantity],
          ["status", "1..1", "h:statusCode/@code"],
          ["text", "0..1", "h:value[@xsi:type='ST']"],
          ["reference_range", "0..1", "h:referenceRange/h:observationRange", referenceRange],
          //["codedValue", "0..1", "h:value[@xsi:type='CD']", shared.ConceptDescriptor],
          //["freeTextValue", "0..1", "h:text", shared.TextWithReference],
          ["interpretations", "0..*", "h:interpretationCode[@codeSystem='2.16.840.1.113883.5.83']", shared.SimplifiedCode]
        ]);
      //ResultObservation.cleanupStep(cleanup.extractAllFields(['resultName']));

      // TODO: Accomodating both PQ and CD values needed
      ResultObservation.cleanupStep(cleanup.extractAllFields(['physicalQuantity']));
      //ResultObservation.cleanupStep(cleanup.extractAllFields(['codedValue']));

      var ResultsOrganizer = component.define("ResultsOrganizer")
        .templateRoot("2.16.840.1.113883.10.20.1.32")
        .fields([
          ["identifiers", "0..*", "h:id", shared.Identifier],
          ["result_set", "0..1", "h:code", shared.ConceptDescriptor],
          ["results", "1..*", ResultObservation.xpath(), ResultObservation]
        ]);
      //ResultsOrganizer.cleanupStep(cleanup.extractAllFields(['panelName']));

      var resultsSection = component.define("resultsSection");
      resultsSection.templateRoot(['2.16.840.1.113883.10.20.1.14']); // .1 for "entries required"
      resultsSection.fields([
        ["panels", "0..*", ResultsOrganizer.xpath(), ResultsOrganizer]
      ]);
      resultsSection.cleanupStep(cleanup.replaceWithField('panels'));

      return [resultsSection, ResultsOrganizer];
    };

    exports.resultsSection = exportResultsSection;
    exports.resultsEntry = exportResultsSection;

  }, { "../cleanup": 31, "../shared": 40, "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 40: [function (require, module, exports) {
    "use strict";

    var component = require("@amida-tech/blue-button-xml").component;
    var processor = require("@amida-tech/blue-button-xml").processor;
    var cleanup = require("./cleanup");
    var common = require("@amida-tech/blue-button-xml").common;

    var commonShared = require('../common/shared');

    var shared = module.exports = Object.create(commonShared);

    var TextWithReference = shared.TextWithReference = component.define("TextWithReference");
    TextWithReference.fields([
      ["text", "0..*", "text()"],
      ["reference", "0..1", "./h:reference/@value"],
    ])
      .cleanupStep(cleanup.resolveReference);

    var NegationIndicator = shared.NegationIndicator = component.define("NegationIndicator");
    NegationIndicator.fields([
      ["negation_indicator", "0..1", "@negationInd", processor.asBoolean]
    ]).cleanupStep(function () {
      //Flag missing negations as false.
      if (this.js) {
        if (!common.exists(this.js)) {
          this.js.negation_indicator = false;
        }
        if (this.js.negation_indicator === 'true') {
          this.js.negation_indicator = true;
        }
      } else {
        this.js = {
          negation_indicator: false
        };
      }
    })
      .cleanupStep(cleanup.replaceWithField('negation_indicator'));

    var conceptWoutTranslation = component.define("conceptWoutTranslation");
    conceptWoutTranslation.fields([
      ["name", "0..1", "@displayName"],
      ["code", "1..1", "@code"],
      ["system", "1..1", "@codeSystem"],
      ["code_system_name", "0..1", "@codeSystemName"],
      ["nullFlavor", "0..1", "@nullFlavor"],
      ["original_text", "0..1", "h:originalText", TextWithReference]
    ]);
    conceptWoutTranslation.cleanupStep(cleanup.augmentConcept);
    conceptWoutTranslation.cleanupStep(cleanup.removeField('system'));

    var ConceptDescriptor = shared.ConceptDescriptor = conceptWoutTranslation.define("ConceptDescriptor");
    ConceptDescriptor.fields([
      ["translations", "0..*", "h:translation", conceptWoutTranslation],
    ]);

    var AgeDescriptor = shared.AgeDescriptor = component.define("AgeDescriptor");
    AgeDescriptor.fields([
      ["units", "0..1", "@unit"],
    ])
      .cleanupStep(cleanup.augmentAge);

    var SimplifiedCode = shared.SimplifiedCode = ConceptDescriptor.define("SimpifiedCode")
      .cleanupStep(cleanup.augmentSimplifiedCode);

    var PhysicalQuantity = shared.PhysicalQuantity = component.define("PhysicalQuantity")
      .fields([
        ["value", "1..1", "@value", processor.asFloat],
        ["unit", "0..1", "@unit"]
      ]);

    var EventOffset = shared.EventOffset = component.define("EventOffset")
      .fields([
        ["low", "0..1", "h:/low", PhysicalQuantity],
        ["high", "0..1", "h:/high", PhysicalQuantity],
        ["center", "0..1", "h:/center", PhysicalQuantity],
        ["width", "0..1", "h:/width", PhysicalQuantity],
      ]);

    var EffectiveTime = shared.EffectiveTime = component.define("EffectiveTime")
      .fields([
        ["point", "0..1", "@value", processor.asTimestamp],
        ["point_resolution", "0..1", "@value", processor.asTimestampResolution],
        ["low", "0..1", "h:low/@value", processor.asTimestamp],
        ["low_resolution", "0..1", "h:low/@value", processor.asTimestampResolution],
        ["high", "0..1", "h:high/@value", processor.asTimestamp],
        ["high_resolution", "0..1", "h:high/@value", processor.asTimestampResolution],
        ["center", "0..1", "h:center/@value", processor.asTimestamp],
        ["center_resolution", "0..1", "h:center/@value", processor.asTimestampResolution]
      ])
      .cleanupStep(cleanup.augmentEffectiveTime);

    var IndividualName = shared.IndividualName = component.define('IndividualName')
      .fields([
        ["prefix", "0..1", "h:prefix/text()"],
        ["middle", "0..*", "h:given/text()"],
        ["last", "0..1", "h:family/text()"],
        ["suffix", "0..1", "h:suffix/text()"],
        ["freetext_name", "0..1", "../h:name/text()", processor.asString]
      ]).cleanupStep(cleanup.augmentIndividualName);

    var Address = shared.Address = component.define("Address")
      .fields([
        ["street_lines", "1..4", "h:streetAddressLine/text()"],
        ["city", "1..1", "h:city/text()", processor.asString],
        ["state", "0..1", "h:state/text()"],
        ["zip", "0..1", "h:postalCode/text()"],
        ["country", "0..1", "h:country/text()"],
        ["use", "0..1", "@use", shared.SimpleCode("2.16.840.1.113883.5.1119")]
      ]);

    var Organization = shared.Organization = component.define("Organization")
      .fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["name", "0..*", "h:name/text()"],
        ["address", "0..*", "h:addr", Address],
        ["email", "0..*", shared.email.xpath(), shared.email],
        ["phone", "0..*", shared.phone.xpath(), shared.phone]
      ]);

    var assignedEntity = shared.assignedEntity = component.define("assignedEntity")
      .fields([
        ["identifiers", "0..*", "h:id", shared.Identifier],
        ["name", "0..*", "h:assignedPerson/h:name", IndividualName],
        ["address", "0..*", "h:addr", Address],
        ["email", "0..*", shared.email.xpath(), shared.email],
        ["phone", "0..*", shared.phone.xpath(), shared.phone],
        ["organization", "0..*", "h:representedOrganization", Organization],
        ["code", "0..*", "h:code", ConceptDescriptor],
      ]);

    shared.serviceDeliveryLocation = component.define('serviceDeliveryLocation')
      .fields([
        ["name", "0:1", "h:playingEntity/h:name/text()"],
        ["location_type", "1..1", "h:code", ConceptDescriptor],
        ["address", "0..*", "h:addr", Address],
        ["email", "0..*", shared.email.xpath(), shared.email],
        ["phone", "0..*", shared.phone.xpath(), shared.phone]
      ]);

  }, { "../common/shared": 42, "./cleanup": 31, "blue-button-xml": "blue-button-xml" }], 41: [function (require, module, exports) {
    "use strict";

    var bbxml = require("@amida-tech/blue-button-xml");
    var bbm = require("@amida-tech/blue-button-meta");

    var css = bbm.code_systems;

    var includeCleanup = bbxml.cleanup;
    var processor = bbxml.processor;
    var common = bbxml.common;
    var xmlUtil = bbxml.xmlUtil;

    var cleanup = module.exports = Object.create(includeCleanup);

    var resolveReference = cleanup.resolveReference = function () {
      if (!common.exists(this.js)) {
        return;
      }

      var r = this.js.reference && this.js.reference.match(/#(.*)/);
      var resolved = null;
      if (r && r.length === 2) {
        resolved = xmlUtil.xpath(this.node, "//*[@ID='" + r[1] + "']/text()");
      }
      var ret = null;
      if (resolved && resolved.length === 1) {
        ret = processor.asString(resolved[0]);
      } else {
        this.js.text = this.js.text && this.js.text.join("").match(/\s*(.*)\s*/)[1];
        ret = this.js.text;
      }

      this.js = ret || null;
    };

    var augmentAge = cleanup.augmentAge = function () {
      var units = this.js.units;
      if (units) {
        var cs = css.find("2.16.840.1.113883.11.20.9.21");
        if (cs) {
          var value = cs.codeDisplayName(units);
          if (value) {
            this.js = value;
          }
        }
      }
    };

    cleanup.augmentSimpleCode = function (oid) {
      var f = function () {
        if (this.js) {
          var cs = css.find(oid);
          if (cs) {
            this.js = cs.codeDisplayName(this.js);
          }
        }
      };
      return f;
    };

    var augmentIndividualName = cleanup.augmentIndividualName = function () {
      if (this.js) {
        if (this.js.middle && this.js.middle.length > 0) {
          this.js.first = this.js.middle[0];
          if (this.js.middle.length > 1) {
            this.js.middle.splice(0, 1);
          } else {
            delete this.js.middle;
          }
        }
        if (!this.js.first && !this.js.last && this.js.freetext_name) {
          var names = this.js.freetext_name.split(' ').filter(function (piece) {
            return piece.length > 0;
          });
          var n = names.length;
          if (n > 0) {
            this.js.last = names[n - 1];
            if (n > 1) {
              this.js.first = names[0];
            }
            if (n > 2) {
              this.js.middle = names.slice(1, n - 1);
            }
          }
        }
        delete this.js.freetext_name;
      }
    };

    cleanup.augmentConcept = function () {
      if (!this.js) {
        this.js = {};
      }

      if (common.exists(this.js.nullFlavor) && !this.js.original_text) {
        this.js = null;
        return;
      }

      if (this.js.system) {
        var cs = css.find(this.js.system);
        if (cs) {
          // Keep existing name if present
          if (!common.exists(this.js.name)) {
            var newName = cs.codeDisplayName(this.js.code);
            if (newName) {
              this.js.name = newName;
            }
          }
          // but preferentially use our canonical names for the coding system
          var systemName = cs.name();
          if (systemName) {
            this.js.code_system_name = systemName;
          }
        }
      }

      //If original text is present w/out name, use it.
      if (this.js.original_text && !this.js.name) {
        this.js.name = this.js.original_text.js;
        delete this.js.original_text;
      } else {
        delete this.js.original_text;
      }

      if (this.js.nullFlavor) {
        delete this.js.nullFlavor;
      }
    };

    cleanup.augmentEffectiveTime = function () {
      if (this.js) {
        var returnArray = {};

        if (this.js.point) {
          returnArray.point = {
            "date": this.js.point,
            "precision": this.js.point_resolution
          };
        }

        if (this.js.low) {
          returnArray.low = {
            "date": this.js.low,
            "precision": this.js.low_resolution
          };
        }

        if (this.js.high) {
          returnArray.high = {
            "date": this.js.high,
            "precision": this.js.high_resolution
          };
        }

        if (this.js.center) {
          returnArray.center = {
            "date": this.js.center,
            "precision": this.js.center_resolution
          };
        }

        this.js = returnArray;
      }
    };

    cleanup.augmentSimplifiedCode = function () {
      if (this.js) {
        // TODO: look up; don't trust the name to be present...
        this.js = this.js.name;
      }
    };

    cleanup.augmentSimplifiedCodeOID = function (oid) {
      var f = function () {
        if (this.js) {
          if (this.js.name) {
            this.js = this.js.name;
          } else if (this.js.code) {
            var cs = css.find(oid);
            if (cs) {
              var name = cs.codeDisplayName(this.js.code);
              if (name) {
                this.js = name;
              }
            }
          } else {
            this.js = null;
          }
        }
      };
      return f;
    };

    cleanup.allergiesProblemStatusToHITSP = (function () {
      var dict = {};
      dict.active = {
        "name": "Active",
        "code": "55561003",
        "code_system_name": "SNOMED CT"
      };
      dict.suspended = dict.aborted = {
        "name": "Inactive",
        "code": "73425007",
        "code_system_name": "SNOMED CT"
      };
      dict.completed = {
        "name": "Resolved",
        "code": "413322009",
        "code_system_name": "SNOMED CT"
      };

      return function () {
        var status = this.js && this.js.problemStatus;
        if (status) {
          var value = dict[status];
          if (value) {
            var observation = this.js.observation;
            if (!observation) {
              this.js.observation = {
                status: value
              };
            } else if (!observation.js) {
              observation.js = {
                status: value
              };
            } else if (!observation.js.status) {
              observation.js.status = value;
            }
          }
          delete this.js.problemStatus;
        }
      };
    })();

  }, { "blue-button-meta": 45, "blue-button-xml": "blue-button-xml" }], 42: [function (require, module, exports) {
    "use strict";

    var bbxml = require("@amida-tech/blue-button-xml");

    var component = bbxml.component;
    var processor = bbxml.processor;

    var cleanup = require('./cleanup');

    var shared = module.exports = {};

    var Identifier = shared.Identifier = component.define("Identifier")
      .fields([
        ["identifier", "1..1", "@root"],
        ["extension", "0..1", "@extension"],
      ]);

    var simpleCode = shared.SimpleCode = function (oid) {
      var r = component.define("SimpleCode." + oid);
      r.fields([]);
      r.cleanupStep(cleanup.augmentSimpleCode(oid));
      return r;
    };

    var email = shared.email = component.define("email");
    email.fields([
      ["address", "1..1", "@value"],
      ["type", "0..1", "@use", simpleCode("2.16.840.1.113883.5.1119")]
    ]);
    email.cleanupStep(function () {
      if (this.js && this.js.address) {
        this.js.address = this.js.address.substring(7);

        //NOTE: type for email should be empty (per PragueExpat)
        if (this.js.type) {
          this.js.type = '';
        }
      }
    });
    email.setXPath("h:telecom[starts-with(@value, 'mailto:')]");

    var phone = shared.phone = component.define("phone");
    phone.fields([
      ["number", "1..1", "@value"],
      ["type", "0..1", "@use", simpleCode("2.16.840.1.113883.5.1119")]
    ]);
    phone.cleanupStep(function () {
      if (this.js && this.js.number) {
        if (this.js.number.substring(0, 4) === "tel:") {
          this.js.number = this.js.number.substring(4);
        }
      }
    });
    phone.setXPath("h:telecom[@value and @value!='' and not(starts-with(@value, 'mailto:'))]");

    var simplifiedCodeOID = shared.simplifiedCodeOID = function (oid) {
      var r = component.define("SC " + oid);
      r.fields([
        ["name", "0..1", "@displayName"],
        ["code", "1..1", "@code"],
      ]);
      r.cleanupStep(cleanup.augmentSimplifiedCodeOID(oid));
      return r;
    };

    shared.metaData = component.define("metaData")
      .fields([
        ["identifiers", "0..*", "h:id", Identifier],
        ["confidentiality", '0..1', "h:confidentialityCode", simplifiedCodeOID("2.16.840.1.113883.5.25")],
        ["set_id", "0..1", "h:setId", Identifier]
      ]);

  }, { "./cleanup": 41, "blue-button-xml": "blue-button-xml" }], 43: [function (require, module, exports) {
    //CCDA to JSON parser.

    "use strict";

    var generateComponents = function (version) {

      version = version.indexOf("-") > -1 ? "_" + version.split("-")[1] : "";

      return {

        //Base CCD Object.
        cda_ccd: require("./cda/ccd").CCD(version),

        //Base C32 Object.
        c32_ccd: require("./c32/ccd").C32(version),
        c32_demographics: require("./c32/demographics").patient,
        c32_vitals: require("./c32/sections/vitals").vitalSignsSection,
        c32_medications: require("./c32/sections/medications").medicationsSection,
        c32_problems: require("./c32/sections/problems").problemsSection,
        c32_immunizations: require("./c32/sections/immunizations").immunizationsSection,
        c32_results: require("./c32/sections/results").resultsSection,
        c32_allergies: require("./c32/sections/allergies").allergiesSection,
        c32_encounters: require("./c32/sections/encounters").encountersSection,
        c32_procedures: require("./c32/sections/procedures").proceduresSection,

        //exposing individual entries just in case
        c32_vitals_entry: require("./c32/sections/vitals").vitalSignsEntry,
        c32_medications_entry: require("./c32/sections/medications").medicationsEntry,
        c32_problems_entry: require("./c32/sections/problems").problemsEntry,
        c32_immunizations_entry: require("./c32/sections/immunizations").immunizationsEntry,
        c32_results_entry: require("./c32/sections/results").resultsEntry,
        c32_allergies_entry: require("./c32/sections/allergies").allergiesEntry,
        c32_encounters_entry: require("./c32/sections/encounters").encountersEntry,
        c32_procedures_entry: require("./c32/sections/procedures").proceduresEntry,

        //CCDA domains.
        ccda_ccd: require("./ccda/ccd").CCD(version),
        ccda_demographics: require("./ccda/demographics").patient,
        ccda_header: require("./ccda/header").header,
        ccda_vitals: require("./ccda/sections/vitals").vitalSignsSection(version)[0],
        ccda_medications: require("./ccda/sections/medications").medicationsSection(version)[0],
        ccda_problems: require("./ccda/sections/problems").problemsSection(version)[0],
        ccda_immunizations: require("./ccda/sections/immunizations").immunizationsSection(version)[0],
        ccda_results: require("./ccda/sections/results").resultsSection(version)[0],
        ccda_allergies: require("./ccda/sections/allergies").allergiesSection(version)[0],
        ccda_encounters: require("./ccda/sections/encounters").encountersSection(version)[0],
        ccda_procedures: require("./ccda/sections/procedures").proceduresSection(version)[0],
        ccda_social_history: require("./ccda/sections/social_history").socialHistorySection(version)[0],
        ccda_plan_of_care: require("./ccda/sections/plan_of_care").plan_of_care_section(version)[0],
        ccda_payers: require("./ccda/sections/payers").payers_section(version)[0],

        //exposing individual entries just in case
        ccda_vitals_entry: require("./ccda/sections/vitals").vitalSignsEntry(version)[1],
        ccda_medications_entry: require("./ccda/sections/medications").medicationsEntry(version)[1],
        ccda_problems_entry: require("./ccda/sections/problems").problemsEntry(version)[1],
        ccda_immunizations_entry: require("./ccda/sections/immunizations").immunizationsEntry(version)[1],
        ccda_results_entry: require("./ccda/sections/results").resultsEntry(version)[1],
        ccda_allergies_entry: require("./ccda/sections/allergies").allergiesEntry(version)[1],
        ccda_encounters_entry: require("./ccda/sections/encounters").encountersEntry(version)[1],
        ccda_procedures_entry: require("./ccda/sections/procedures").proceduresEntry(version)[1],
        ccda_plan_of_care_entry: require("./ccda/sections/plan_of_care").plan_of_care_entry(version)[1],
        ccda_payers_entry: require("./ccda/sections/payers").payers_entry(version)[1],

      };
    };

    var componentRouter = function (componentName, type) {

      if (componentName) {
        return generateComponents(type["type"])[componentName];
      } else {

        if (type["type"] === 'c32') {
          return generateComponents(type["type"]).c32_ccd;
        } else if (type["type"] === 'cda') {
          return generateComponents(type["type"]).cda_ccd;
        } else {
          return generateComponents(type["type"]).ccda_ccd;
        }
      }
    };

    module.exports.componentRouter = componentRouter;

  }, { "./c32/ccd": 2, "./c32/demographics": 4, "./c32/sections/allergies": 5, "./c32/sections/encounters": 6, "./c32/sections/immunizations": 7, "./c32/sections/medications": 8, "./c32/sections/problems": 9, "./c32/sections/procedures": 10, "./c32/sections/results": 11, "./c32/sections/vitals": 12, "./ccda/ccd": 14, "./ccda/demographics": 16, "./ccda/header": 17, "./ccda/sections/allergies": 18, "./ccda/sections/encounters": 19, "./ccda/sections/immunizations": 20, "./ccda/sections/medications": 21, "./ccda/sections/payers": 22, "./ccda/sections/plan_of_care": 23, "./ccda/sections/problems": 24, "./ccda/sections/procedures": 25, "./ccda/sections/results": 26, "./ccda/sections/social_history": 27, "./ccda/sections/vitals": 28, "./cda/ccd": 30 }], 44: [function (require, module, exports) {
    //sense.js - Determining file content type e.g. CCDA or C32 or BB.json/JSON or text/other formats.

    "use strict";

    var xml = require("@amida-tech/blue-button-xml").xmlUtil;

    //Sense document type based on XML object
    var senseXml = function (doc) {
      //data must be an object
      if (!doc || typeof (doc) !== "object") {
        //TODO: throw a proper error here
        return null;
      }

      var c32Result = xml.xpath(doc, 'h:templateId[@root=\"2.16.840.1.113883.3.88.11.32.1\"]');
      if (c32Result && c32Result.length > 0) {
        return {
          type: "c32"
        };
      }

      var cdaResult = xml.xpath(doc, 'h:templateId[@root=\"2.16.840.1.113883.10.20.1\"]');
      var cdaTemplateResult = xml.xpath(doc, 'h:code[@code=\"34133-9\"][@codeSystem=\"2.16.840.1.113883.6.1\"]');
      if ((cdaResult && cdaResult.length > 0) && (cdaTemplateResult && cdaTemplateResult.length > 0)) {
        return {
          type: "cda"
        };
      }

      var ccdResult = xml.xpath(doc, 'h:templateId[@root=\"2.16.840.1.113883.10.20.22.1.1\"] | h:templateId[@root=\"2.16.840.1.113883.10.20.22.1.2\"]');
      if (ccdResult && ccdResult.length > 0) {
        return {
          type: "ccda"
        };
      }

      var ncpdpResult = xml.xpath(doc, '//Message/Body/*');
      if (ncpdpResult && ncpdpResult.length > 0) {
        try {
          require.resolve("blue-button-ncpdp"); // check if the module is present
          return {
            type: "ncpdp"
          };
        } catch (ex) { }
      }

      return {
        type: "xml"
      };
    };

    //Sense document type based on String
    var senseString = function (data) {
      //data must be a string

      if (!data || typeof (data) !== "string") {
        //TODO: throw a proper error here
        return null;
      }

      //console.log(data);
      var doc;
      var result;
      var version = "";
      var reg_exp_v;

      //TODO: better xml detection needed
      if (data.indexOf("<?xml") !== -1 || data.indexOf("<ClinicalDocument") !== -1) {
        //parse xml object...
        try {
          doc = xml.parse(data);
        } catch (ex) {
          return {
            type: "unknown",
            error: ex
          };
        }

        result = senseXml(doc);
        result.xml = doc;

        return result;

      } else if (data.trim().indexOf("<") === 0) {
        //sensing xml with no xml declaration
        //TODO: there should be a better way (like comparing first and last tags and see if they match)

        doc;
        try {
          doc = xml.parse(data);
        } catch (ex) {
          return {
            type: "unknown",
            error: ex
          };
        }

        result = senseXml(doc);
        result.xml = doc;

        return result;
      } else {
        //parse json or determine if text object...
        try {
          var json = JSON.parse(data); // {}

          if (json.data && json.meta) {
            return {
              type: "blue-button.js",
              json: json
            };

          } else {

            return {
              type: "json",
              json: json
            };
          }
        } catch (e) {
          //console.error("Parsing error:", e);

          if (data.indexOf("MYMEDICARE.GOV PERSONAL HEALTH INFORMATION") > 0 &&
            data.indexOf("Produced by the Blue Button") > 0) {
            version = "";

            reg_exp_v = /Produced by the Blue Button \(v(\d+\.\d+)\)/g;
            version = reg_exp_v.exec(data)[1];

            return {
              type: "cms",
              version: version
            };
          } else if (data.indexOf("MY HEALTHEVET PERSONAL INFORMATION REPORT") > 0) {
            version = "";

            reg_exp_v = /utton \(v(\d+.\d+|\d+)\)/g;
            version = reg_exp_v.exec(data)[1];

            return {
              type: "va",
              version: version
            };
          } else if (data.indexOf("%PDF") === 0) {
            return {
              type: "pdf"
            };
          } else if (data.indexOf("+\n  Disclaimer:") > 0) {
            return {
              type: "format-x"
            };
          }

          return {
            type: "unknown"
          };
        }
      }

      return {
        type: "unknown"
      };
    };

    module.exports = {
      senseXml: senseXml,
      senseString: senseString
    };

  }, { "blue-button-xml": "blue-button-xml" }], 45: [function (require, module, exports) {
    var CCDA = require("./lib/CCDA/index.js");

    //CCDA metadata stuff
    var meta = {};
    meta.CCDA = CCDA;

    meta.supported_sections = [
      'allergies',
      'procedures',
      'immunizations',
      'medications',
      'encounters',
      'vitals',
      'results',
      'social_history',
      'demographics',
      'problems',
      'insurance',
      'claims',
      'plan_of_care',
      'payers',
      'providers',
      'organizations'
    ];

    meta.code_systems = require("./lib/code-systems");

    module.exports = exports = meta;

  }, { "./lib/CCDA/index.js": 48, "./lib/code-systems": 53 }], 46: [function (require, module, exports) {
    var clinicalstatements = {
      "AdmissionMedication": "2.16.840.1.113883.10.20.22.4.36",
      "AdvanceDirectiveObservation": "2.16.840.1.113883.10.20.22.4.48",
      "AgeObservation": "2.16.840.1.113883.10.20.22.4.31",
      "AllergyObservation": "2.16.840.1.113883.10.20.22.4.7",
      "AllergyProblemAct": "2.16.840.1.113883.10.20.22.4.30",
      "AllergyStatusObservation": "2.16.840.1.113883.10.20.22.4.28",
      "AssessmentScaleObservation": "2.16.840.1.113883.10.20.22.4.69",
      "AssessmentScaleSupportingObservation": "2.16.840.1.113883.10.20.22.4.86",
      "AuthorizationActivity": "2.16.840.1.113883.10.20.1.19",
      "BoundaryObservation": "2.16.840.1.113883.10.20.6.2.11",
      "CaregiverCharacteristics": "2.16.840.1.113883.10.20.22.4.72",
      "CodeObservations": "2.16.840.1.113883.10.20.6.2.13",
      "CognitiveStatusProblemObservation": "2.16.840.1.113883.10.20.22.4.73",
      "CognitiveStatusResultObservation": "2.16.840.1.113883.10.20.22.4.74",
      "CognitiveStatusResultOrganizer": "2.16.840.1.113883.10.20.22.4.75",
      "CommentActivity": "2.16.840.1.113883.10.20.22.4.64",
      "CoverageActivity": "2.16.840.1.113883.10.20.22.4.60",
      "DeceasedObservation": "2.16.840.1.113883.10.20.22.4.79",
      "DischargeMedication": "2.16.840.1.113883.10.20.22.4.35",
      "EncounterActivities": "2.16.840.1.113883.10.20.22.4.49",
      "EncounterDiagnosis": "2.16.840.1.113883.10.20.22.4.80",
      "EstimatedDateOfDelivery": "2.16.840.1.113883.10.20.15.3.1",
      "FamilyHistoryDeathObservation": "2.16.840.1.113883.10.20.22.4.47",
      "FamilyHistoryObservation": "2.16.840.1.113883.10.20.22.4.46",
      "FamilyHistoryOrganizer": "2.16.840.1.113883.10.20.22.4.45",
      "FunctionalStatusProblemObservation": "2.16.840.1.113883.10.20.22.4.68",
      "FunctionalStatusResultObservation": "2.16.840.1.113883.10.20.22.4.67",
      "FunctionalStatusResultOrganizer": "2.16.840.1.113883.10.20.22.4.66",
      "HealthStatusObservation": "2.16.840.1.113883.10.20.22.4.5",
      "HighestPressureUlcerStage": "2.16.840.1.113883.10.20.22.4.77",
      "HospitalAdmissionDiagnosis": "2.16.840.1.113883.10.20.22.4.34",
      "HospitalDischargeDiagnosis": "2.16.840.1.113883.10.20.22.4.33",
      "ImmunizationActivity": "2.16.840.1.113883.10.20.22.4.52",
      "ImmunizationRefusalReason": "2.16.840.1.113883.10.20.22.4.53",
      "Indication": "2.16.840.1.113883.10.20.22.4.19",
      "Instructions": "2.16.840.1.113883.10.20.22.4.20",
      "MedicationActivity": "2.16.840.1.113883.10.20.22.4.16",
      "MedicationDispense": "2.16.840.1.113883.10.20.22.4.18",
      "MedicationSupplyOrder": "2.16.840.1.113883.10.20.22.4.17",
      "MedicationUseNoneKnown": "2.16.840.1.113883.10.20.22.4.29",
      "NonMedicinalSupplyActivity": "2.16.840.1.113883.10.20.22.4.50",
      "NumberOfPressureUlcersObservation": "2.16.840.1.113883.10.20.22.4.76",
      "PlanOfCareActivityAct": "2.16.840.1.113883.10.20.22.4.39",
      "PlanOfCareActivityEncounter": "2.16.840.1.113883.10.20.22.4.40",
      "PlanOfCareActivityObservation": "2.16.840.1.113883.10.20.22.4.44",
      "PlanOfCareActivityProcedure": "2.16.840.1.113883.10.20.22.4.41",
      "PlanOfCareActivitySubstanceAdministration": "2.16.840.1.113883.10.20.22.4.42",
      "PlanOfCareActivitySupply": "2.16.840.1.113883.10.20.22.4.43",
      "PolicyActivity": "2.16.840.1.113883.10.20.22.4.61",
      "PostprocedureDiagnosis": "2.16.840.1.113883.10.20.22.4.51",
      "PregnancyObservation": "2.16.840.1.113883.10.20.15.3.8",
      "PreoperativeDiagnosis": "2.16.840.1.113883.10.20.22.4.65",
      "PressureUlcerObservation": "2.16.840.1.113883.10.20.22.4.70",
      "ProblemConcernAct": "2.16.840.1.113883.10.20.22.4.3",
      "ProblemObservation": "2.16.840.1.113883.10.20.22.4.4",
      "ProblemStatus": "2.16.840.1.113883.10.20.22.4.6",
      "ProcedureActivityAct": "2.16.840.1.113883.10.20.22.4.12",
      "ProcedureActivityObservation": "2.16.840.1.113883.10.20.22.4.13",
      "ProcedureActivityProcedure": "2.16.840.1.113883.10.20.22.4.14",
      "ProcedureContext": "2.16.840.1.113883.10.20.6.2.5",
      "PurposeofReferenceObservation": "2.16.840.1.113883.10.20.6.2.9",
      "QuantityMeasurementObservation": "2.16.840.1.113883.10.20.6.2.14",
      "ReactionObservation": "2.16.840.1.113883.10.20.22.4.9",
      "ReferencedFramesObservation": "2.16.840.1.113883.10.20.6.2.10",
      "ResultObservation": "2.16.840.1.113883.10.20.22.4.2",
      "ResultOrganizer": "2.16.840.1.113883.10.20.22.4.1",
      "SeriesAct": "2.16.840.1.113883.10.20.22.4.63",
      "SeverityObservation": "2.16.840.1.113883.10.20.22.4.8",
      "SmokingStatusObservation": "2.16.840.1.113883.10.20.22.4.78",
      "SocialHistoryObservation": "2.16.840.1.113883.10.20.22.4.38",
      "SOPInstanceObservation": "2.16.840.1.113883.10.20.6.2.8",
      "StudyAct": "2.16.840.1.113883.10.20.6.2.6",
      "TextObservation": "2.16.840.1.113883.10.20.6.2.12",
      "TobaccoUse": "2.16.840.1.113883.10.20.22.4.85",
      "VitalSignObservation": "2.16.840.1.113883.10.20.22.4.27",
      "VitalSignsOrganizer": "2.16.840.1.113883.10.20.22.4.26"
    };

    var clinicalstatements_r1 = {
      "AdvanceDirectiveObservation": "2.16.840.1.113883.10.20.1.17",
      "AlertObservation": "2.16.840.1.113883.10.20.1.18",
      "AuthorizationActivity": "2.16.840.1.113883.10.20.1.19",
      "CoverageActivity": "2.16.840.1.113883.10.20.1.20",
      "EncounterActivity": "2.16.840.1.113883.10.20.1.21",
      "FamilyHistoryObservation": "2.16.840.1.113883.10.20.1.22",
      "FamilyHistoryOrganizer": "2.16.840.1.113883.10.20.1.23",
      "MedicationActivity": "2.16.840.1.113883.10.20.1.24",
      "PlanOfCareActivity": "2.16.840.1.113883.10.20.1.25",
      "PolicyActivity": "2.16.840.1.113883.10.20.1.26",
      "ProblemAct": "2.16.840.1.113883.10.20.1.27",
      "ProblemObservation": "2.16.840.1.113883.10.20.1.28",
      "ProcedureActivity": "2.16.840.1.113883.10.20.1.29",
      "PurposeActivity": "2.16.840.1.113883.10.20.1.30",
      "ResultObservation": "2.16.840.1.113883.10.20.1.31",
      "ResultOrganizer": "2.16.840.1.113883.10.20.1.32",
      "SocialHistoryObservation": "2.16.840.1.113883.10.20.1.33",
      "SupplyActivity": "2.16.840.1.113883.10.20.1.34",
      "VitalSignObservation": "2.16.840.1.113883.10.20.1.31",
      "Indication": "2.16.840.1.113883.10.20.22.4.19",
      "VitalSignsOrganizer": "2.16.840.1.113883.10.20.1.35",
      "AdvanceDirectiveReference": "2.16.840.1.113883.10.20.1.36",
      "AdvanceDirectiveStatusObservation": "2.16.840.1.113883.10.20.1.37",
      "AgeObservation": "2.16.840.1.113883.10.20.1.38",
      "AlertStatusObservation": "2.16.840.1.113883.10.20.1.39",
      "Comment": "2.16.840.1.113883.10.20.1.40",
      "EpisodeObservation": "2.16.840.1.113883.10.20.1.41",
      "FamilyHistoryCauseOfDeathObservation": "2.16.840.1.113883.10.20.1.42",
      "FulfillmentInstruction": "2.16.840.1.113883.10.20.1.43",
      "LocationParticipation": "2.16.840.1.113883.10.20.1.45",
      "MedicationSeriesNumberObservation": "2.16.840.1.113883.10.20.1.46",
      "MedicationStatusObservation": "2.16.840.1.113883.10.20.1.47",
      "PatientAwareness": "2.16.840.1.113883.10.20.1.48",
      "PatientInstruction": "2.16.840.1.113883.10.20.1.49",
      "ProblemHealthstatusObservation": "2.16.840.1.113883.10.20.1.51",
      "ProblemStatusObservation": "2.16.840.1.113883.10.20.1.50",
      "Product": "2.16.840.1.113883.10.20.1.53",
      "ProductInstance": "2.16.840.1.113883.10.20.1.52",
      "ReactionObservation": "2.16.840.1.113883.10.20.1.54",
      "SeverityObservation": "2.16.840.1.113883.10.20.1.55",
      "SocialHistoryStatusObservation": "2.16.840.1.113883.10.20.1.56",
      "StatusObservation": "2.16.840.1.113883.10.20.1.57",
      "StatusOfFunctionalStatusObservation": "2.16.840.1.113883.10.20.1.44",
      "VerificationOfAnAdvanceDirectiveObservation": "2.16.840.1.113883.10.20.1.58"
    };

    module.exports.clinicalstatements = clinicalstatements;
    module.exports.clinicalstatements_r1 = clinicalstatements_r1;

  }, {}], 47: [function (require, module, exports) {
    var codeSystems = {
      "LOINC": ["2.16.840.1.113883.6.1", "8716-3"],
      "SNOMED CT": ["2.16.840.1.113883.6.96", "46680005"],
      "RXNORM": ["2.16.840.1.113883.6.88"],
      "ActCode": ["2.16.840.1.113883.5.4"],
      "CPT-4": ["2.16.840.1.113883.6.12"],
      "CVX": ["2.16.840.1.113883.12.292"],
      "HL7 Role": ["2.16.840.1.113883.5.111"],
      "HL7 RoleCode": ["2.16.840.1.113883.5.110"],
      "UNII": ["2.16.840.1.113883.4.9"],
      "Observation Interpretation": ["2.16.840.1.113883.1.11.78"],
      "CPT": ["2.16.840.1.113883.6.12"],
      "HealthcareServiceLocation": ["2.16.840.1.113883.6.259"],
      "HL7 Result Interpretation": ["2.16.840.1.113883.5.83"],
      "Act Reason": ["2.16.840.1.113883.5.8"],
      "Medication Route FDA": ["2.16.840.1.113883.3.26.1.1"],
      "Body Site Value Set": ["2.16.840.1.113883.3.88.12.3221.8.9"],
      "MediSpan DDID": ["2.16.840.1.113883.6.253"],
      "ActPriority": ["2.16.840.1.113883.5.7"],
      "InsuranceType Code": ["2.16.840.1.113883.6.255.1336"],
      "ICD-9-CM": ["2.16.840.1.113883.6.103"]
    };

    var sections_entries_codes = {
      "codes": {
        "AdvanceDirectivesSectionEntriesOptional": {
          "code": "42348-3",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Advance Directives"
        },
        "AdvanceDirectivesSection": {
          "code": "42348-3",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Advance Directives"
        },
        "AllergiesSectionEntriesOptional": {
          "code": "48765-2",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Allergies, adverse reactions, alerts"
        },
        "AllergiesSection": {
          "code": "48765-2",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Allergies, adverse reactions, alerts"
        },
        "AnesthesiaSection": {
          "code": "59774-0",
          "code_system": "",
          "code_system_name": "",
          "name": "Anesthesia"
        },
        "AssessmentAndPlanSection": {
          "code": "51847-2",
          "code_system": "",
          "code_system_name": "",
          "name": "Assessment and Plan"
        },
        "AssessmentSection": {
          "code": "51848-0",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Assessments"
        },
        "ChiefComplaintAndReasonForVisitSection": {
          "code": "46239-0",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Chief Complaint and Reason for Visit"
        },
        "ChiefComplaintSection": {
          "code": "10154-3",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Chief Complaint"
        },
        "undefined": "",
        "ComplicationsSection": {
          "code": "55109-3",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Complications"
        },
        "DICOMObjectCatalogSection": {
          "code": "121181",
          "code_system": "1.2.840.10008.2.16.4",
          "code_system_name": "DCM",
          "name": "Dicom Object Catalog"
        },
        "DischargeDietSection": {
          "code": "42344-2",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Discharge Diet"
        },
        "EncountersSectionEntriesOptional": {
          "code": "46240-8",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Encounters"
        },
        "EncountersSection": {
          "code": "46240-8",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Encounters"
        },
        "FamilyHistorySection": {
          "code": "10157-6",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Family History"
        },
        "FindingsSection": "",
        "FunctionalStatusSection": {
          "code": "47420-5",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Functional Status"
        },
        "GeneralStatusSection": {
          "code": "10210-3",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "General Status"
        },
        "HistoryOfPastIllnessSection": {
          "code": "11348-0",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "History of Past Illness"
        },
        "HistoryOfPresentIllnessSection": {
          "code": "10164-2",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "History Of Present Illness Section"
        },
        "HospitalAdmissionDiagnosisSection": {
          "code": "46241-6",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Hospital Admission Diagnosis"
        },
        "HospitalAdmissionMedicationsSectionEntriesOptional": {
          "code": "42346-7",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Medications on Admission"
        },
        "HospitalConsultationsSection": {
          "code": "18841-7",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Hospital Consultations Section"
        },
        "HospitalCourseSection": {
          "code": "8648-8",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Hospital Course"
        },
        "HospitalDischargeDiagnosisSection": {
          "code": "11535-2",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Hospital Discharge Diagnosis"
        },
        "HospitalDischargeInstructionsSection": {
          "code": "8653-8",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Hospital Discharge Instructions"
        },
        "HospitalDischargeMedicationsSectionEntriesOptional": {
          "code": "10183-2",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Hospital Discharge Medications"
        },
        "HospitalDischargePhysicalSection": {
          "code": "10184-0",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Hospital Discharge Physical"
        },
        "HospitalDischargeStudiesSummarySection": {
          "code": "11493-4",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Hospital Discharge Studies Summary"
        },
        "ImmunizationsSectionEntriesOptional": {
          "code": "11369-6",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Immunizations"
        },
        "ImmunizationsSection": {
          "code": "11369-6",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Immunizations"
        },
        "InstructionsSection": {
          "code": "69730-0",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Instructions"
        },
        "InterventionsSection": {
          "code": "62387-6",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Interventions Provided"
        },
        "MedicalHistorySection": {
          "code": "11329-0",
          "code_system": "",
          "code_system_name": "",
          "name": "Medical"
        },
        "MedicalEquipmentSection": {
          "code": "46264-8",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Medical Equipment"
        },
        "MedicationsAdministeredSection": {
          "code": "29549-3",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Medications Administered"
        },
        "MedicationsSectionEntriesOptional": {
          "code": "10160-0",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "History of medication use"
        },
        "MedicationsSection": {
          "code": "10160-0",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "History of medication use"
        },
        "ObjectiveSection": {
          "code": "61149-1",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Objective"
        },
        "OperativeNoteFluidSection": {
          "code": "10216-0",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Operative Note Fluids"
        },
        "OperativeNoteSurgicalProcedureSection": {
          "code": "10223-6",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Operative Note Surgical Procedure"
        },
        "PayersSection": {
          "code": "48768-6",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Payers"
        },
        "PhysicalExamSection": {
          "code": "29545-1",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Physical Findings"
        },
        "PlanOfCareSection": {
          "code": "18776-5",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Plan of Care"
        },
        "PlannedProcedureSection": {
          "code": "59772-4",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Planned Procedure"
        },
        "PostoperativeDiagnosisSection": {
          "code": "10218-6",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Postoperative Diagnosis"
        },
        "PostprocedureDiagnosisSection": {
          "code": "59769-0",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Postprocedure Diagnosis"
        },
        "PreoperativeDiagnosisSection": {
          "code": "10219-4",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Preoperative Diagnosis"
        },
        "ProblemSectionEntriesOptional": {
          "code": "11450-4",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Problem List"
        },
        "ProblemSection": {
          "code": "11450-4",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Problem List"
        },
        "ProcedureDescriptionSection": {
          "code": "29554-3",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Procedure Description"
        },
        "ProcedureDispositionSection": {
          "code": "59775-7",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Procedure Disposition"
        },
        "ProcedureEstimatedBloodLossSection": {
          "code": "59770-8",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Procedure Estimated Blood Loss"
        },
        "ProcedureFindingsSection": {
          "code": "59776-5",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Procedure Findings"
        },
        "ProcedureImplantsSection": {
          "code": "59771-6",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Procedure Implants"
        },
        "ProcedureIndicationsSection": {
          "code": "59768-2",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Procedure Indications"
        },
        "ProcedureSpecimensTakenSection": {
          "code": "59773-2",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Procedure Specimens Taken"
        },
        "ProceduresSectionEntriesOptional": {
          "code": "47519-4",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "History of Procedures"
        },
        "ProceduresSection": {
          "code": "47519-4",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "History of Procedures"
        },
        "ReasonForReferralSection": {
          "code": "42349-1",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Reason for Referral"
        },
        "ReasonForVisitSection": {
          "code": "29299-5",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Reason for Visit"
        },
        "ResultsSectionEntriesOptional": {
          "code": "30954-2",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Relevant diagnostic tests and/or laboratory data"
        },
        "ResultsSection": {
          "code": "30954-2",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Relevant diagnostic tests and/or laboratory data"
        },
        "ReviewOfSystemsSection": {
          "code": "10187-3",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Review of Systems"
        },
        "SocialHistorySection": {
          "code": "29762-2",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Social History"
        },
        "SubjectiveSection": {
          "code": "61150-9",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Subjective"
        },
        "SurgicalDrainsSection": {
          "code": "11537-8",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Surgical Drains"
        },
        "VitalSignsSectionEntriesOptional": {
          "code": "8716-3",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Vital Signs"
        },
        "VitalSignsSection": {
          "code": "8716-3",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Vital Signs"
        },
        "AdmissionMedication": {
          "code": "42346-7",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Medications on Admission"
        },
        "AdvanceDirectiveObservation": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "AgeObservation": {
          "code": "445518008",
          "code_system": "2.16.840.1.113883.6.96",
          "code_system_name": "SNOMED-CT",
          "name": "Age At Onset"
        },
        "AllergyObservation": {
          "code": "ASSERTION",
          "code_system": "2.16.840.1.113883.5.4",
          "code_system_name": "ActCode",
          "name": "Assertion"
        },
        "AllergyProblemAct": {
          "code": "48765-2",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Allergies, adverse reactions, alerts"
        },
        "AllergyStatusObservation": {
          "code": "33999-4",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Status"
        },
        "AssessmentScaleObservation": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "AssessmentScaleSupportingObservation": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "AuthorizationActivity": "",
        "BoundaryObservation": {
          "code": "113036",
          "code_system": "1.2.840.10008.2.16.4",
          "code_system_name": "DCM",
          "name": "Frames for Display"
        },
        "CaregiverCharacteristics": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "CodeObservations": "",
        "CognitiveStatusProblemObservation": {
          "code": "373930000",
          "code_system": "2.16.840.1.113883.6.96",
          "code_system_name": "SNOMED-CT",
          "name": "Cognitive function finding"
        },
        "CognitiveStatusResultObservation": {
          "code": "373930000",
          "code_system": "2.16.840.1.113883.6.96",
          "code_system_name": "SNOMED-CT",
          "name": "Cognitive function finding"
        },
        "CognitiveStatusResultOrganizer": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "CommentActivity": {
          "code": "48767-8",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Annotation Comment"
        },
        "CoverageActivity": {
          "code": "48768-6",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Payment sources"
        },
        "DeceasedObservation": {
          "code": "ASSERTION",
          "code_system": "2.16.840.1.113883.5.4",
          "code_system_name": "ActCode",
          "name": "Assertion"
        },
        "DischargeMedication": {
          "code": "10183-2",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Discharge medication"
        },
        "EncounterActivities": "",
        "EncounterDiagnosis": {
          "code": "29308-4",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Diagnosis"
        },
        "EstimatedDateOfDelivery": {
          "code": "11778-8",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Estimated date of delivery"
        },
        "FamilyHistoryDeathObservation": {
          "code": "ASSERTION",
          "code_system": "2.16.840.1.113883.5.4",
          "code_system_name": "ActCode",
          "name": "Assertion"
        },
        "FamilyHistoryObservation": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "FamilyHistoryOrganizer": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "FunctionalStatusProblemObservation": {
          "code": "248536006",
          "code_system": "2.16.840.1.113883.6.96",
          "code_system_name": "SNOMED-CT",
          "name": "finding of functional performance and activity"
        },
        "FunctionalStatusResultObservation": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "FunctionalStatusResultOrganizer": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "HealthStatusObservation": {
          "code": "11323-3",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Health status"
        },
        "HighestPressureUlcerStage": {
          "code": "420905001",
          "code_system": "2.16.840.1.113883.6.96",
          "code_system_name": "SNOMED-CT",
          "name": "Highest Pressure Ulcer Stage"
        },
        "HospitalAdmissionDiagnosis": {
          "code": "46241-6",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Admission diagnosis"
        },
        "HospitalDischargeDiagnosis": {
          "code": "11535-2",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Hospital discharge diagnosis"
        },
        "ImmunizationActivity": "",
        "ImmunizationRefusalReason": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "Indication": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "Instructions": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "MedicationActivity": "",
        "MedicationDispense": "",
        "MedicationSupplyOrder": "",
        "MedicationUseNoneKnown": {
          "code": "ASSERTION",
          "code_system": "2.16.840.1.113883.5.4",
          "code_system_name": "ActCode",
          "name": "Assertion"
        },
        "NonMedicinalSupplyActivity": "",
        "NumberOfPressureUlcersObservation": {
          "code": "2264892003",
          "code_system": "",
          "code_system_name": "",
          "name": "number of pressure ulcers"
        },
        "PlanOfCareActivityAct": "",
        "PlanOfCareActivityEncounter": "",
        "PlanOfCareActivityObservation": "",
        "PlanOfCareActivityProcedure": "",
        "PlanOfCareActivitySubstanceAdministration": "",
        "PlanOfCareActivitySupply": "",
        "PolicyActivity": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "PostprocedureDiagnosis": {
          "code": "59769-0",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Postprocedure diagnosis"
        },
        "PregnancyObservation": {
          "code": "ASSERTION",
          "code_system": "2.16.840.1.113883.5.4",
          "code_system_name": "ActCode",
          "name": "Assertion"
        },
        "PreoperativeDiagnosis": {
          "code": "10219-4",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Preoperative Diagnosis"
        },
        "PressureUlcerObservation": {
          "code": "ASSERTION",
          "code_system": "2.16.840.1.113883.5.4",
          "code_system_name": "ActCode",
          "name": "Assertion"
        },
        "ProblemConcernAct": {
          "code": "CONC",
          "code_system": "2.16.840.1.113883.5.6",
          "code_system_name": "HL7ActClass",
          "name": "Concern"
        },
        "ProblemObservation": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "ProblemStatus": {
          "code": "33999-4",
          "code_system": "2.16.840.1.113883.6.1",
          "code_system_name": "LOINC",
          "name": "Status"
        },
        "ProcedureActivityAct": "",
        "ProcedureActivityObservation": "",
        "ProcedureActivityProcedure": "",
        "ProcedureContext": "",
        "PurposeofReferenceObservation": {
          "code": "ASSERTION",
          "code_system": "2.16.840.1.113883.5.4",
          "code_system_name": "ActCode",
          "name": "Assertion"
        },
        "QuantityMeasurementObservation": "",
        "ReactionObservation": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "ReferencedFramesObservation": {
          "code": "121190",
          "code_system": "1.2.840.10008.2.16.4",
          "code_system_name": "DCM",
          "name": "Referenced Frames"
        },
        "ResultObservation": "",
        "ResultOrganizer": "",
        "SeriesAct": {
          "code": "113015",
          "code_system": "1.2.840.10008.2.16.4",
          "code_system_name": "DCM",
          "name": "Series Act"
        },
        "SeverityObservation": {
          "code": "SEV",
          "code_system": "2.16.840.1.113883.5.4",
          "code_system_name": "ActCode",
          "name": "Severity Observation"
        },
        "SmokingStatusObservation": {
          "code": "ASSERTION",
          "code_system": "2.16.840.1.113883.5.4",
          "code_system_name": "ActCode",
          "name": "Assertion"
        },
        "SocialHistoryObservation": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "SOPInstanceObservation": "",
        "StudyAct": {
          "code": "113014",
          "code_system": "1.2.840.10008.2.16.4",
          "code_system_name": "DCM",
          "name": "Study Act"
        },
        "TextObservation": "",
        "TobaccoUse": {
          "code": "ASSERTION",
          "code_system": "2.16.840.1.113883.5.4",
          "code_system_name": "ActCode",
          "name": "Assertion"
        },
        "VitalSignObservation": {
          "code": "completed",
          "code_system": "2.16.840.1.113883.5.14",
          "code_system_name": "ActStatus",
          "name": "Completed"
        },
        "VitalSignsOrganizer": {
          "code": "46680005",
          "code_system": "2.16.840.1.113883.6.96",
          "code_system_name": "SNOMED-CT",
          "name": "Vital signs"
        }
      }
    };
    module.exports.codeSystems = codeSystems;
    module.exports.sections_entries_codes = sections_entries_codes;

  }, {}], 48: [function (require, module, exports) {
    var templates = require("./templates.js");
    var sections = require("./sections.js");
    var statements = require("./clinicalstatements.js");

    var templatesconstraints = require("./templates-constraints.js");
    var sectionsconstraints = require("./sections-constraints.js");
    var codeSystems = require("./code-systems.js");

    //General Header Constraints
    var CCDA = {
      "document": {
        "name": "CCDA",
        "templateId": "2.16.840.1.113883.10.20.22.1.1"
      },
      "templates": templates,
      "sections": sections.sections,
      "sections_r1": sections.sections_r1,
      "statements": statements.clinicalstatements,
      "statements_r1": statements.clinicalstatements_r1,
      "constraints": {
        "sections": sectionsconstraints,
        "templates": templatesconstraints
      },
      "codeSystems": codeSystems.codeSystems,
      "sections_entries_codes": codeSystems.sections_entries_codes

      /*
      ,
      //DOCUMENT-LEVEL TEMPLATES
      "templates":[
      {
        "name":"Consultation Note",
        "templateId":"2.16.840.1.113883.10.20.22.1.4"
      },
      {
        "name":"Continuity Of Care Document",
        "templateId":"2.16.840.1.113883.10.20.22.1.2"
      },
      {
        "name":"Diagnostic Imaging Report",
        "templateId":"2.16.840.1.113883.10.20.22.1.5"
      },
      {
        "name":"Discharge Summary",
        "templateId":"2.16.840.1.113883.10.20.22.1.8"
      },
      {
        "name":"History And Physical Note",
        "templateId":"2.16.840.1.113883.10.20.22.1.3"
      },
      {
        "name":"Operative Note",
        "templateId":"2.16.840.1.113883.10.20.22.1.7"
      },
      {
        "name":"Procedure Note",
        "templateId":"2.16.840.1.113883.10.20.22.1.6"
      },
      {
        "name":"Progress Note",
        "templateId":"2.16.840.1.113883.10.20.22.1.9"
      },
      {
        "name":"Unstructured Document",
        "templateId":"2.16.840.1.113883.10.20.21.1.10"
      },
      ],
      //Sections
      "sections":[
      {"name": "Allergies",
        "templateIds": ['2.16.840.1.113883.10.20.22.2.6', '2.16.840.1.113883.10.20.22.2.6.1']
      },
      {"name": "Encounters",
        "templateIds": ['2.16.840.1.113883.10.20.22.2.22', '2.16.840.1.113883.10.20.22.2.22.1']
      },
      {"name": "Immunizations",
        "templateIds": ["2.16.840.1.113883.10.20.22.2.2", "2.16.840.1.113883.10.20.22.2.2.1"]
      },
      {"name": "Medications",
        "templateIds": ["2.16.840.1.113883.10.20.22.2.1", "2.16.840.1.113883.10.20.22.2.1.1"]
      },
      {"name": "Problems",
        "templateIds": ["2.16.840.1.113883.10.20.22.2.5.1"]
      },
      {"name": "Procedures",
        "templateIds": ['2.16.840.1.113883.10.20.22.2.7', '2.16.840.1.113883.10.20.22.2.7.1']
      },
      {"name": "Results",
        "templateIds": ['2.16.840.1.113883.10.20.22.2.3', '2.16.840.1.113883.10.20.22.2.3.1']
      },
      {"name": "Vital Signs",
        "templateIds": ["2.16.840.1.113883.10.20.22.2.4","2.16.840.1.113883.10.20.22.2.4.1"]
      },
      {"name": "Social History",
        "templateIds": ["2.16.840.1.113883.10.20.22.2.17"]
      }		
      ]
      */
    };

    //Good source http://cdatools.org/SectionMatrix.html
    //and http://cdatools.org/ClinicalStatementMatrix.html

    module.exports = exports = CCDA;

  }, { "./clinicalstatements.js": 46, "./code-systems.js": 47, "./sections-constraints.js": 49, "./sections.js": 50, "./templates-constraints.js": 51, "./templates.js": 52 }], 49: [function (require, module, exports) {
    var sectionsconstraints = {
      "VitalSignsSection": {
        "full": {
          "VitalSignsOrganizer": {
            "id": [
              "7276",
              "7277"
            ],
            "constraint": "shall"
          }
        },
        "shall": {
          "VitalSignsOrganizer": [
            "7276",
            "7277"
          ]
        }
      },
      "DICOMObjectCatalogSection": {
        "full": {
          "StudyAct": {
            "id": [
              "8530",
              "15458"
            ],
            "constraint": "shall"
          }
        },
        "shall": {
          "StudyAct": [
            "8530",
            "15458"
          ]
        }
      },
      "PayersSection": {
        "full": {
          "CoverageActivity": {
            "id": [
              "7959",
              "8905"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "CoverageActivity": [
            "7959",
            "8905"
          ]
        }
      },
      "HospitalDischargeDiagnosisSection": {
        "full": {
          "HospitalDischargeDiagnosis": {
            "id": [
              "7984"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "HospitalDischargeDiagnosis": [
            "7984"
          ]
        }
      },
      "SocialHistorySection": {
        "may": {
          "TobaccoUse": [
            "16816",
            "16817"
          ],
          "PregnancyObservation": [
            "9133",
            "9132"
          ],
          "SocialHistoryObservation": [
            "7954",
            "7953"
          ]
        },
        "full": {
          "SmokingStatusObservation": {
            "id": [
              "14824",
              "14823"
            ],
            "constraint": "should"
          },
          "TobaccoUse": {
            "id": [
              "16816",
              "16817"
            ],
            "constraint": "may"
          },
          "PregnancyObservation": {
            "id": [
              "9133",
              "9132"
            ],
            "constraint": "may"
          },
          "SocialHistoryObservation": {
            "id": [
              "7954",
              "7953"
            ],
            "constraint": "may"
          }
        },
        "should": {
          "SmokingStatusObservation": [
            "14824",
            "14823"
          ]
        }
      },
      "AssessmentAndPlanSection": {
        "may": {
          "PlanOfCareActivityAct": [
            "8798"
          ]
        },
        "full": {
          "PlanOfCareActivityAct": {
            "id": [
              "8798"
            ],
            "constraint": "may"
          }
        }
      },
      "ResultsSection": {
        "full": {
          "ResultOrganizer": {
            "id": [
              "7113",
              "7112"
            ],
            "constraint": "shall"
          }
        },
        "shall": {
          "ResultOrganizer": [
            "7113",
            "7112"
          ]
        }
      },
      "HospitalAdmissionMedicationsSectionEntriesOptional": {
        "full": {
          "AdmissionMedication": {
            "id": [
              "10110",
              "10102"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "AdmissionMedication": [
            "10110",
            "10102"
          ]
        }
      },
      "AllergiesSection": {
        "full": {
          "AllergyProblemAct": {
            "id": [
              "7531",
              "7532"
            ],
            "constraint": "shall"
          }
        },
        "shall": {
          "AllergyProblemAct": [
            "7531",
            "7532"
          ]
        }
      },
      "ComplicationsSection": {
        "may": {
          "ProblemObservation": [
            "8796",
            "8795"
          ]
        },
        "full": {
          "ProblemObservation": {
            "id": [
              "8796",
              "8795"
            ],
            "constraint": "may"
          }
        }
      },
      "AdvanceDirectivesSection": {
        "full": {
          "AdvanceDirectiveObservation": {
            "id": [
              "8801",
              "8647"
            ],
            "constraint": "shall"
          }
        },
        "shall": {
          "AdvanceDirectiveObservation": [
            "8801",
            "8647"
          ]
        }
      },
      "MedicationsSectionEntriesOptional": {
        "full": {
          "MedicationActivity": {
            "id": [
              "7795",
              "7573"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "MedicationActivity": [
            "7795",
            "7573"
          ]
        }
      },
      "MedicationsAdministeredSection": {
        "may": {
          "MedicationActivity": [
            "8156"
          ]
        },
        "full": {
          "MedicationActivity": {
            "id": [
              "8156"
            ],
            "constraint": "may"
          }
        }
      },
      "MedicalEquipmentSection": {
        "full": {
          "NonMedicinalSupplyActivity": {
            "id": [
              "7948.",
              "8755"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "NonMedicinalSupplyActivity": [
            "7948.",
            "8755"
          ]
        }
      },
      "MedicationsSection": {
        "full": {
          "MedicationActivity": {
            "id": [
              "7573",
              "7572"
            ],
            "constraint": "shall"
          }
        },
        "shall": {
          "MedicationActivity": [
            "7573",
            "7572"
          ]
        }
      },
      "ImmunizationsSection": {
        "full": {
          "ImmunizationActivity": {
            "id": [
              "9019",
              "9020"
            ],
            "constraint": "shall"
          }
        },
        "shall": {
          "ImmunizationActivity": [
            "9019",
            "9020"
          ]
        }
      },
      "AdvanceDirectivesSectionEntriesOptional": {
        "may": {
          "AdvanceDirectiveObservation": [
            "8800",
            "7957"
          ]
        },
        "full": {
          "AdvanceDirectiveObservation": {
            "id": [
              "8800",
              "7957"
            ],
            "constraint": "may"
          }
        }
      },
      "ResultsSectionEntriesOptional": {
        "full": {
          "ResultOrganizer": {
            "id": [
              "7119",
              "7120"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "ResultOrganizer": [
            "7119",
            "7120"
          ]
        }
      },
      "AnesthesiaSection": {
        "may": {
          "ProcedureActivityProcedure": [
            "8092"
          ],
          "MedicationActivity": [
            "8094"
          ]
        },
        "full": {
          "ProcedureActivityProcedure": {
            "id": [
              "8092"
            ],
            "constraint": "may"
          },
          "MedicationActivity": {
            "id": [
              "8094"
            ],
            "constraint": "may"
          }
        }
      },
      "VitalSignsSectionEntriesOptional": {
        "full": {
          "VitalSignsOrganizer": {
            "id": [
              "7271",
              "7272"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "VitalSignsOrganizer": [
            "7271",
            "7272"
          ]
        }
      },
      "ImmunizationsSectionEntriesOptional": {
        "full": {
          "ImmunizationActivity": {
            "id": [
              "7969",
              "7970"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "ImmunizationActivity": [
            "7969",
            "7970"
          ]
        }
      },
      "FunctionalStatusSection": {
        "may": {
          "PressureUlcerObservation": [
            "16778",
            "16777"
          ],
          "FunctionalStatusProblemObservation": [
            "14422",
            "14423"
          ],
          "CognitiveStatusResultObservation": [
            "14421",
            "14420"
          ],
          "NumberOfPressureUlcersObservation": [
            "16779",
            "16780"
          ],
          "HighestPressureUlcerStage": [
            "16781",
            "16782"
          ],
          "AssessmentScaleObservation": [
            "14581",
            "14580"
          ],
          "FunctionalStatusResultObservation": [
            "14418",
            "14419"
          ],
          "CognitiveStatusProblemObservation": [
            "14425",
            "14424"
          ],
          "FunctionalStatusResultOrganizer": [
            "14414",
            "14415"
          ],
          "CaregiverCharacteristics": [
            "14426",
            "14427"
          ],
          "CognitiveStatusResultOrganizer": [
            "14416",
            "14417"
          ],
          "NonMedicinalSupplyActivity": [
            "14583",
            "14582"
          ]
        },
        "full": {
          "PressureUlcerObservation": {
            "id": [
              "16778",
              "16777"
            ],
            "constraint": "may"
          },
          "FunctionalStatusProblemObservation": {
            "id": [
              "14422",
              "14423"
            ],
            "constraint": "may"
          },
          "CognitiveStatusResultObservation": {
            "id": [
              "14421",
              "14420"
            ],
            "constraint": "may"
          },
          "NumberOfPressureUlcersObservation": {
            "id": [
              "16779",
              "16780"
            ],
            "constraint": "may"
          },
          "HighestPressureUlcerStage": {
            "id": [
              "16781",
              "16782"
            ],
            "constraint": "may"
          },
          "AssessmentScaleObservation": {
            "id": [
              "14581",
              "14580"
            ],
            "constraint": "may"
          },
          "FunctionalStatusResultObservation": {
            "id": [
              "14418",
              "14419"
            ],
            "constraint": "may"
          },
          "CognitiveStatusProblemObservation": {
            "id": [
              "14425",
              "14424"
            ],
            "constraint": "may"
          },
          "FunctionalStatusResultOrganizer": {
            "id": [
              "14414",
              "14415"
            ],
            "constraint": "may"
          },
          "CaregiverCharacteristics": {
            "id": [
              "14426",
              "14427"
            ],
            "constraint": "may"
          },
          "CognitiveStatusResultOrganizer": {
            "id": [
              "14416",
              "14417"
            ],
            "constraint": "may"
          },
          "NonMedicinalSupplyActivity": {
            "id": [
              "14583",
              "14582"
            ],
            "constraint": "may"
          }
        }
      },
      "PreoperativeDiagnosisSection": {
        "full": {
          "PreoperativeDiagnosis": {
            "id": [
              "10097",
              "10096"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "PreoperativeDiagnosis": [
            "10097",
            "10096"
          ]
        }
      },
      "HospitalAdmissionDiagnosisSection": {
        "full": {
          "HospitalAdmissionDiagnosis": {
            "id": [
              "9935",
              "9934"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "HospitalAdmissionDiagnosis": [
            "9935",
            "9934"
          ]
        }
      },
      "AllergiesSectionEntriesOptional": {
        "full": {
          "AllergyProblemAct": {
            "id": [
              "7805",
              "7804"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "AllergyProblemAct": [
            "7805",
            "7804"
          ]
        }
      },
      "PlannedProcedureSection": {
        "may": {
          "PlanOfCareActivityProcedure": [
            "8766",
            "8744"
          ]
        },
        "full": {
          "PlanOfCareActivityProcedure": {
            "id": [
              "8766",
              "8744"
            ],
            "constraint": "may"
          }
        }
      },
      "ProblemSection": {
        "full": {
          "ProblemConcernAct": {
            "id": [
              "9183"
            ],
            "constraint": "shall"
          }
        },
        "shall": {
          "ProblemConcernAct": [
            "9183"
          ]
        }
      },
      "EncountersSectionEntriesOptional": {
        "full": {
          "EncounterActivities": {
            "id": [
              "7951",
              "8802"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "EncounterActivities": [
            "7951",
            "8802"
          ]
        }
      },
      "HospitalDischargeMedicationsSectionEntriesOptional": {
        "full": {
          "DischargeMedication": {
            "id": [
              "7883"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "DischargeMedication": [
            "7883"
          ]
        }
      },
      "ProcedureFindingsSection": {
        "may": {
          "ProblemObservation": [
            "8090",
            "8091"
          ]
        },
        "full": {
          "ProblemObservation": {
            "id": [
              "8090",
              "8091"
            ],
            "constraint": "may"
          }
        }
      },
      "PlanOfCareSection": {
        "may": {
          "PlanOfCareActivityAct": [
            "7726.",
            "8804"
          ],
          "PlanOfCareActivityProcedure": [
            "8810",
            "8809"
          ],
          "PlanOfCareActivitySubstanceAdministration": [
            "8811",
            "8812"
          ],
          "PlanOfCareActivitySupply": [
            "14756",
            "8813"
          ],
          "PlanOfCareActivityEncounter": [
            "8806",
            "8805"
          ],
          "PlanOfCareActivityObservation": [
            "8808",
            "8807"
          ],
          "Instructions": [
            "14695",
            "16751"
          ]
        },
        "full": {
          "PlanOfCareActivityAct": {
            "id": [
              "7726.",
              "8804"
            ],
            "constraint": "may"
          },
          "PlanOfCareActivityProcedure": {
            "id": [
              "8810",
              "8809"
            ],
            "constraint": "may"
          },
          "PlanOfCareActivitySubstanceAdministration": {
            "id": [
              "8811",
              "8812"
            ],
            "constraint": "may"
          },
          "PlanOfCareActivitySupply": {
            "id": [
              "14756",
              "8813"
            ],
            "constraint": "may"
          },
          "PlanOfCareActivityEncounter": {
            "id": [
              "8806",
              "8805"
            ],
            "constraint": "may"
          },
          "PlanOfCareActivityObservation": {
            "id": [
              "8808",
              "8807"
            ],
            "constraint": "may"
          },
          "Instructions": {
            "id": [
              "14695",
              "16751"
            ],
            "constraint": "may"
          }
        }
      },
      "InstructionsSection": {
        "full": {
          "Instructions": {
            "id": [
              "10116",
              "10117"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "Instructions": [
            "10116",
            "10117"
          ]
        }
      },
      "ProceduresSection": {
        "may": {
          "ProcedureActivityProcedure": [
            "7896",
            "7895"
          ],
          "ProcedureActivityAct": [
            "8020",
            "8019"
          ],
          "ProcedureActivityObservation": [
            "8018",
            "8017"
          ]
        },
        "full": {
          "ProcedureActivityProcedure": {
            "id": [
              "7896",
              "7895"
            ],
            "constraint": "may"
          },
          "ProcedureActivityAct": {
            "id": [
              "8020",
              "8019"
            ],
            "constraint": "may"
          },
          "ProcedureActivityObservation": {
            "id": [
              "8018",
              "8017"
            ],
            "constraint": "may"
          }
        }
      },
      "HospitalDischargeMedicationsSection": {
        "full": {
          "DischargeMedication": {
            "id": [
              "7827"
            ],
            "constraint": "shall"
          }
        },
        "shall": {
          "DischargeMedication": [
            "7827"
          ]
        }
      },
      "PostprocedureDiagnosisSection": {
        "full": {
          "PostprocedureDiagnosis": {
            "id": [
              "8762",
              "8764"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "PostprocedureDiagnosis": [
            "8762",
            "8764"
          ]
        }
      },
      "HistoryOfPastIllnessSection": {
        "may": {
          "ProblemObservation": [
            "8792"
          ]
        },
        "full": {
          "ProblemObservation": {
            "id": [
              "8792"
            ],
            "constraint": "may"
          }
        }
      },
      "ProblemSectionEntriesOptional": {
        "full": {
          "ProblemConcernAct": {
            "id": [
              "7882"
            ],
            "constraint": "should"
          }
        },
        "should": {
          "ProblemConcernAct": [
            "7882"
          ]
        }
      },
      "FamilyHistorySection": {
        "may": {
          "FamilyHistoryOrganizer": [
            "7955"
          ]
        },
        "full": {
          "FamilyHistoryOrganizer": {
            "id": [
              "7955"
            ],
            "constraint": "may"
          }
        }
      },
      "ProcedureIndicationsSection": {
        "may": {
          "Indication": [
            "8765",
            "8743"
          ]
        },
        "full": {
          "Indication": {
            "id": [
              "8765",
              "8743"
            ],
            "constraint": "may"
          }
        }
      },
      "ProceduresSectionEntriesOptional": {
        "may": {
          "ProcedureActivityProcedure": [
            "15509",
            "6274"
          ],
          "ProcedureActivityAct": [
            "8533",
            "15511"
          ],
          "ProcedureActivityObservation": [
            "6278",
            "15510"
          ]
        },
        "full": {
          "ProcedureActivityProcedure": {
            "id": [
              "15509",
              "6274"
            ],
            "constraint": "may"
          },
          "ProcedureActivityAct": {
            "id": [
              "8533",
              "15511"
            ],
            "constraint": "may"
          },
          "ProcedureActivityObservation": {
            "id": [
              "6278",
              "15510"
            ],
            "constraint": "may"
          }
        }
      },
      "PhysicalExamSection": {
        "may": {
          "PressureUlcerObservation": [
            "17094",
            "17095"
          ],
          "NumberOfPressureUlcersObservation": [
            "17096",
            "17097"
          ],
          "HighestPressureUlcerStage": [
            "17098",
            "17099"
          ]
        },
        "full": {
          "PressureUlcerObservation": {
            "id": [
              "17094",
              "17095"
            ],
            "constraint": "may"
          },
          "NumberOfPressureUlcersObservation": {
            "id": [
              "17096",
              "17097"
            ],
            "constraint": "may"
          },
          "HighestPressureUlcerStage": {
            "id": [
              "17098",
              "17099"
            ],
            "constraint": "may"
          }
        }
      },
      "EncountersSection": {
        "full": {
          "EncounterActivities": {
            "id": [
              "8709",
              "8803"
            ],
            "constraint": "shall"
          }
        },
        "shall": {
          "EncounterActivities": [
            "8709",
            "8803"
          ]
        }
      }
    };

    module.exports = exports = sectionsconstraints;

  }, {}], 50: [function (require, module, exports) {
    var sections = {
      "AdvanceDirectivesSection": "2.16.840.1.113883.10.20.22.2.21.1",
      "AdvanceDirectivesSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.21",
      "AllergiesSection": "2.16.840.1.113883.10.20.22.2.6.1",
      "AllergiesSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.6",
      "AnesthesiaSection": "2.16.840.1.113883.10.20.22.2.25",
      "AssessmentAndPlanSection": "2.16.840.1.113883.10.20.22.2.9",
      "AssessmentSection": "2.16.840.1.113883.10.20.22.2.8",
      "ChiefComplaintAndReasonForVisitSection": "2.16.840.1.113883.10.20.22.2.13",
      "ChiefComplaintSection": "1.3.6.1.4.1.19376.1.5.3.1.1.13.2.1",
      "ComplicationsSection": "2.16.840.1.113883.10.20.22.2.37",
      "DICOMObjectCatalogSection": "2.16.840.1.113883.10.20.6.1.1",
      "DischargeDietSection": "1.3.6.1.4.1.19376.1.5.3.1.3.33",
      "EncountersSection": "2.16.840.1.113883.10.20.22.2.22.1",
      "EncountersSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.22",
      "FamilyHistorySection": "2.16.840.1.113883.10.20.22.2.15",
      "FindingsSection": "2.16.840.1.113883.10.20.6.1.2",
      "FunctionalStatusSection": "2.16.840.1.113883.10.20.22.2.14",
      "GeneralStatusSection": "2.16.840.1.113883.10.20.2.5",
      "HistoryOfPastIllnessSection": "2.16.840.1.113883.10.20.22.2.20",
      "HistoryOfPresentIllnessSection": "1.3.6.1.4.1.19376.1.5.3.1.3.4",
      "HospitalAdmissionDiagnosisSection": "2.16.840.1.113883.10.20.22.2.43",
      "HospitalAdmissionMedicationsSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.44",
      "HospitalConsultationsSection": "2.16.840.1.113883.10.20.22.2.42",
      "HospitalCourseSection": "1.3.6.1.4.1.19376.1.5.3.1.3.5",
      "HospitalDischargeDiagnosisSection": "2.16.840.1.113883.10.20.22.2.24",
      "HospitalDischargeInstructionsSection": "2.16.840.1.113883.10.20.22.2.41",
      "HospitalDischargeMedicationsSection": "2.16.840.1.113883.10.20.22.2.11.1",
      "HospitalDischargeMedicationsSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.11",
      "HospitalDischargePhysicalSection": "1.3.6.1.4.1.19376.1.5.3.1.3.26",
      "HospitalDischargeStudiesSummarySection": "2.16.840.1.113883.10.20.22.2.16",
      "ImmunizationsSection": "2.16.840.1.113883.10.20.22.2.2.1",
      "ImmunizationsSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.2",
      "InstructionsSection": "2.16.840.1.113883.10.20.22.2.45",
      "InterventionsSection": "2.16.840.1.113883.10.20.21.2.3",
      "MedicalEquipmentSection": "2.16.840.1.113883.10.20.22.2.23",
      "MedicalHistorySection": "2.16.840.1.113883.10.20.22.2.39",
      "MedicationsAdministeredSection": "2.16.840.1.113883.10.20.22.2.38",
      "MedicationsSection": "2.16.840.1.113883.10.20.22.2.1.1",
      "MedicationsSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.1",
      "ObjectiveSection": "2.16.840.1.113883.10.20.21.2.1",
      "OperativeNoteFluidSection": "2.16.840.1.113883.10.20.7.12",
      "OperativeNoteSurgicalProcedureSection": "2.16.840.1.113883.10.20.7.14",
      "PayersSection": "2.16.840.1.113883.10.20.22.2.18",
      "PhysicalExamSection": "2.16.840.1.113883.10.20.2.10",
      "PlannedProcedureSection": "2.16.840.1.113883.10.20.22.2.30",
      "PlanOfCareSection": "2.16.840.1.113883.10.20.22.2.10",
      "PostoperativeDiagnosisSection": "2.16.840.1.113883.10.20.22.2.35",
      "PostprocedureDiagnosisSection": "2.16.840.1.113883.10.20.22.2.36",
      "PreoperativeDiagnosisSection": "2.16.840.1.113883.10.20.22.2.34",
      "ProblemSection": "2.16.840.1.113883.10.20.22.2.5.1",
      "ProblemSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.5",
      "ProcedureDescriptionSection": "2.16.840.1.113883.10.20.22.2.27",
      "ProcedureDispositionSection": "2.16.840.1.113883.10.20.18.2.12",
      "ProcedureEstimatedBloodLossSection": "2.16.840.1.113883.10.20.18.2.9",
      "ProcedureFindingsSection": "2.16.840.1.113883.10.20.22.2.28",
      "ProcedureImplantsSection": "2.16.840.1.113883.10.20.22.2.40",
      "ProcedureIndicationsSection": "2.16.840.1.113883.10.20.22.2.29",
      "ProcedureSpecimensTakenSection": "2.16.840.1.113883.10.20.22.2.31",
      "ProceduresSection": "2.16.840.1.113883.10.20.22.2.7.1",
      "ProceduresSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.7",
      "ReasonForReferralSection": "1.3.6.1.4.1.19376.1.5.3.1.3.1",
      "ReasonForVisitSection": "2.16.840.1.113883.10.20.22.2.12",
      "ResultsSection": "2.16.840.1.113883.10.20.22.2.3.1",
      "ResultsSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.3",
      "ReviewOfSystemsSection": "1.3.6.1.4.1.19376.1.5.3.1.3.18",
      "SocialHistorySection": "2.16.840.1.113883.10.20.22.2.17",
      "SubjectiveSection": "2.16.840.1.113883.10.20.21.2.2",
      "SurgicalDrainsSection": "2.16.840.1.113883.10.20.7.13",
      "VitalSignsSection": "2.16.840.1.113883.10.20.22.2.4.1",
      "VitalSignsSectionEntriesOptional": "2.16.840.1.113883.10.20.22.2.4"
    };

    var sections_r1 = {
      "AdvanceDirectivesSection": "2.16.840.1.113883.10.20.1.1",
      "AlertsSection": "2.16.840.1.113883.10.20.1.2",
      "EncountersSection": "2.16.840.1.113883.10.20.1.3",
      "FamilyHistorySection": "2.16.840.1.113883.10.20.1.4",
      "FunctionalStatusSection": "2.16.840.1.113883.10.20.1.5",
      "ImmunizationsSection": "2.16.840.1.113883.10.20.1.6",
      "MedicalEquipmentSection": "2.16.840.1.113883.10.20.1.7",
      "MedicationsSection": "2.16.840.1.113883.10.20.1.8",
      "PayersSection": "2.16.840.1.113883.10.20.1.9",
      "PlanOfCareSection": "2.16.840.1.113883.10.20.1.10",
      "ProblemSection": "2.16.840.1.113883.10.20.1.11",
      "ProceduresSection": "2.16.840.1.113883.10.20.1.12",
      "PurposeSection": "2.16.840.1.113883.10.20.1.13",
      "ResultsSection": "2.16.840.1.113883.10.20.1.14",
      "SocialHistorySection": "2.16.840.1.113883.10.20.1.15",
      "VitalSignsSection": "2.16.840.1.113883.10.20.1.16"
    };

    module.exports.sections = sections;
    module.exports.sections_r1 = sections_r1;

  }, {}], 51: [function (require, module, exports) {
    var templatesconstraints = {
      "ContinuityOfCareDocument": {
        "may": {
          "AdvanceDirectivesSection": "9455",
          "PayersSection": "9468",
          "SocialHistorySection": "9472",
          "ImmunizationsSectionEntriesOptional": "9463",
          "MedicalEquipmentSection": "9466",
          "FamilyHistorySection": "9459",
          "PlanOfCareSection": "9470",
          "FunctionalStatusSection": "9461",
          "VitalSignsSectionEntriesOptional": "9474",
          "EncountersSection": "9457"
        },
        "full": {
          "AdvanceDirectivesSection": {
            "id": "9455",
            "constraint": "may"
          },
          "PayersSection": {
            "id": "9468",
            "constraint": "may"
          },
          "MedicationsSection": {
            "id": "9447",
            "constraint": "shall"
          },
          "ProblemSection": {
            "id": "9449",
            "constraint": "shall"
          },
          "ImmunizationsSectionEntriesOptional": {
            "id": "9463",
            "constraint": "may"
          },
          "SocialHistorySection": {
            "id": "9472",
            "constraint": "may"
          },
          "MedicalEquipmentSection": {
            "id": "9466",
            "constraint": "may"
          },
          "FamilyHistorySection": {
            "id": "9459",
            "constraint": "may"
          },
          "ProceduresSection": {
            "id": "9451",
            "constraint": "shall"
          },
          "PlanOfCareSection": {
            "id": "9470",
            "constraint": "may"
          },
          "FunctionalStatusSection": {
            "id": "9461",
            "constraint": "may"
          },
          "VitalSignsSectionEntriesOptional": {
            "id": "9474",
            "constraint": "may"
          },
          "AllergiesSection": {
            "id": "9445",
            "constraint": "shall"
          },
          "EncountersSection": {
            "id": "9457",
            "constraint": "may"
          },
          "ResultsSection": {
            "id": "9453",
            "constraint": "shall"
          }
        },
        "shall": {
          "ProblemSection": "9449",
          "ResultsSection": "9453",
          "AllergiesSection": "9445",
          "ProceduresSection": "9451",
          "MedicationsSection": "9447"
        }
      },
      "HistoryAndPhysicalNote": {
        "may": {
          "ChiefComplaintSection": "9611",
          "ImmunizationsSectionEntriesOptional": "9637",
          "ProblemSectionEntriesOptional": "9639",
          "ReasonForVisitSection": "9627",
          "ProceduresSectionEntriesOptional": "9641",
          "AssessmentAndPlanSection": "9987",
          "ChiefComplaintAndReasonForVisitSection": "9613",
          "PlanOfCareSection": "9607",
          "InstructionsSection": "16807",
          "AssessmentSection": "9605"
        },
        "should": {
          "HistoryOfPresentIllnessSection": "9621"
        },
        "full": {
          "ChiefComplaintSection": {
            "id": "9611",
            "constraint": "may"
          },
          "ProblemSectionEntriesOptional": {
            "id": "9639",
            "constraint": "may"
          },
          "AllergiesSectionEntriesOptional": {
            "id": "9602",
            "constraint": "shall"
          },
          "FamilyHistorySection": {
            "id": "9615",
            "constraint": "shall"
          },
          "ResultsSectionEntriesOptional": {
            "id": "9629",
            "constraint": "shall"
          },
          "HistoryOfPastIllnessSection": {
            "id": "9619",
            "constraint": "shall"
          },
          "SocialHistorySection": {
            "id": "9633",
            "constraint": "shall"
          },
          "PlanOfCareSection": {
            "id": "9607",
            "constraint": "may"
          },
          "MedicationsSectionEntriesOptional": {
            "id": "9623",
            "constraint": "shall"
          },
          "ReasonForVisitSection": {
            "id": "9627",
            "constraint": "may"
          },
          "ProceduresSectionEntriesOptional": {
            "id": "9641",
            "constraint": "may"
          },
          "AssessmentAndPlanSection": {
            "id": "9987",
            "constraint": "may"
          },
          "GeneralStatusSection": {
            "id": "9617",
            "constraint": "shall"
          },
          "ChiefComplaintAndReasonForVisitSection": {
            "id": "9613",
            "constraint": "may"
          },
          "ImmunizationsSectionEntriesOptional": {
            "id": "9637",
            "constraint": "may"
          },
          "ReviewOfSystemsSection": {
            "id": "9631",
            "constraint": "shall"
          },
          "InstructionsSection": {
            "id": "16807",
            "constraint": "may"
          },
          "PhysicalExamSection": {
            "id": "9625",
            "constraint": "shall"
          },
          "VitalSignsSectionEntriesOptional": {
            "id": "9635",
            "constraint": "shall"
          },
          "AssessmentSection": {
            "id": "9605",
            "constraint": "may"
          },
          "HistoryOfPresentIllnessSection": {
            "id": "9621",
            "constraint": "should"
          }
        },
        "shall": {
          "MedicationsSectionEntriesOptional": "9623",
          "AllergiesSectionEntriesOptional": "9602",
          "ResultsSectionEntriesOptional": "9629",
          "HistoryOfPastIllnessSection": "9619",
          "VitalSignsSectionEntriesOptional": "9635",
          "FamilyHistorySection": "9615",
          "GeneralStatusSection": "9617",
          "ReviewOfSystemsSection": "9631",
          "PhysicalExamSection": "9625",
          "SocialHistorySection": "9633"
        }
      },
      "DischargeSummary": {
        "may": {
          "VitalSignsSectionEntriesOptional": "9584",
          "ChiefComplaintSection": "9554",
          "HospitalDischargePhysicalSection": "9568",
          "HospitalConsultationsSection": "9924",
          "SocialHistorySection": "9582",
          "HistoryOfPastIllnessSection": "9564",
          "HospitalDischargeInstructionsSection": "9926",
          "ProblemSectionEntriesOptional": "9574",
          "HospitalDischargeStudiesSummarySection": "9570",
          "ProceduresSectionEntriesOptional": "9576",
          "FamilyHistorySection": "9560",
          "ReasonForVisitSection": "9578",
          "ChiefComplaintAndReasonForVisitSection": "9556",
          "ImmunizationsSectionEntriesOptional": "9572",
          "FunctionalStatusSection": "9562",
          "HospitalAdmissionMedicationsSectionEntriesOptional": "10111",
          "HistoryOfPresentIllnessSection": "9566",
          "ReviewOfSystemsSection": "9580",
          "DischargeDietSection": "9558"
        },
        "full": {
          "HospitalDischargeDiagnosisSection": {
            "id": "9546",
            "constraint": "shall"
          },
          "SocialHistorySection": {
            "id": "9582",
            "constraint": "may"
          },
          "HospitalDischargeStudiesSummarySection": {
            "id": "9570",
            "constraint": "may"
          },
          "ChiefComplaintAndReasonForVisitSection": {
            "id": "9556",
            "constraint": "may"
          },
          "HospitalAdmissionMedicationsSectionEntriesOptional": {
            "id": "10111",
            "constraint": "may"
          },
          "HistoryOfPresentIllnessSection": {
            "id": "9566",
            "constraint": "may"
          },
          "HospitalConsultationsSection": {
            "id": "9924",
            "constraint": "may"
          },
          "FunctionalStatusSection": {
            "id": "9562",
            "constraint": "may"
          },
          "DischargeDietSection": {
            "id": "9558",
            "constraint": "may"
          },
          "HospitalAdmissionDiagnosisSection": {
            "id": "9928",
            "constraint": "shall"
          },
          "AllergiesSectionEntriesOptional": {
            "id": "9542",
            "constraint": "shall"
          },
          "HospitalDischargePhysicalSection": {
            "id": "9568",
            "constraint": "may"
          },
          "ImmunizationsSectionEntriesOptional": {
            "id": "9572",
            "constraint": "may"
          },
          "ReasonForVisitSection": {
            "id": "9578",
            "constraint": "may"
          },
          "HospitalDischargeMedicationsSectionEntriesOptional": {
            "id": "9548",
            "constraint": "shall"
          },
          "PlanOfCareSection": {
            "id": "9550",
            "constraint": "shall"
          },
          "VitalSignsSectionEntriesOptional": {
            "id": "9584",
            "constraint": "may"
          },
          "HospitalCourseSection": {
            "id": "9544",
            "constraint": "shall"
          },
          "ChiefComplaintSection": {
            "id": "9554",
            "constraint": "may"
          },
          "ProceduresSectionEntriesOptional": {
            "id": "9576",
            "constraint": "may"
          },
          "HospitalDischargeInstructionsSection": {
            "id": "9926",
            "constraint": "may"
          },
          "ProblemSectionEntriesOptional": {
            "id": "9574",
            "constraint": "may"
          },
          "FamilyHistorySection": {
            "id": "9560",
            "constraint": "may"
          },
          "HistoryOfPastIllnessSection": {
            "id": "9564",
            "constraint": "may"
          },
          "ReviewOfSystemsSection": {
            "id": "9580",
            "constraint": "may"
          }
        },
        "shall": {
          "HospitalAdmissionDiagnosisSection": "9928",
          "AllergiesSectionEntriesOptional": "9542",
          "HospitalDischargeDiagnosisSection": "9546",
          "HospitalDischargeMedicationsSectionEntriesOptional": "9548",
          "PlanOfCareSection": "9550",
          "HospitalCourseSection": "9544"
        }
      },
      "OperativeNote": {
        "may": {
          "PlannedProcedureSection": "9906",
          "OperativeNoteFluidSection": "9900",
          "OperativeNoteSurgicalProcedureSection": "9902",
          "SurgicalDrainsSection": "9912",
          "ProcedureDispositionSection": "9908",
          "ProcedureImplantsSection": "9898",
          "ProcedureIndicationsSection": "9910",
          "PlanOfCareSection": "9904"
        },
        "full": {
          "ProcedureSpecimensTakenSection": {
            "id": "9894",
            "constraint": "shall"
          },
          "PlannedProcedureSection": {
            "id": "9906",
            "constraint": "may"
          },
          "OperativeNoteFluidSection": {
            "id": "9900",
            "constraint": "may"
          },
          "OperativeNoteSurgicalProcedureSection": {
            "id": "9902",
            "constraint": "may"
          },
          "ProcedureIndicationsSection": {
            "id": "9910",
            "constraint": "may"
          },
          "SurgicalDrainsSection": {
            "id": "9912",
            "constraint": "may"
          },
          "PostoperativeDiagnosisSection": {
            "id": "9913",
            "constraint": "shall"
          },
          "ProcedureDispositionSection": {
            "id": "9908",
            "constraint": "may"
          },
          "ProcedureEstimatedBloodLossSection": {
            "id": "9890",
            "constraint": "shall"
          },
          "ProcedureImplantsSection": {
            "id": "9898",
            "constraint": "may"
          },
          "ProcedureDescriptionSection": {
            "id": "9896",
            "constraint": "shall"
          },
          "AnesthesiaSection": {
            "id": "9883",
            "constraint": "shall"
          },
          "ProcedureFindingsSection": {
            "id": "9892",
            "constraint": "shall"
          },
          "PlanOfCareSection": {
            "id": "9904",
            "constraint": "may"
          },
          "PreoperativeDiagnosisSection": {
            "id": "9888",
            "constraint": "shall"
          },
          "ComplicationsSection": {
            "id": "9885",
            "constraint": "shall"
          }
        },
        "shall": {
          "ProcedureSpecimensTakenSection": "9894",
          "ProcedureEstimatedBloodLossSection": "9890",
          "PostoperativeDiagnosisSection": "9913",
          "ProcedureDescriptionSection": "9896",
          "AnesthesiaSection": "9883",
          "ProcedureFindingsSection": "9892",
          "PreoperativeDiagnosisSection": "9888",
          "ComplicationsSection": "9885"
        }
      },
      "ProcedureNote": {
        "may": {
          "SocialHistorySection": "9849",
          "ProcedureDispositionSection": "9833",
          "AssessmentAndPlanSection": "9649",
          "ChiefComplaintAndReasonForVisitSection": "9815",
          "HistoryOfPresentIllnessSection": "9821",
          "ProcedureSpecimensTakenSection": "9841",
          "PlannedProcedureSection": "9831",
          "MedicationsSectionEntriesOptional": "9825",
          "MedicationsAdministeredSection": "9827",
          "ProcedureImplantsSection": "9839",
          "AnesthesiaSection": "9811",
          "MedicalHistorySection": "9823",
          "AllergiesSectionEntriesOptional": "9809",
          "ReasonForVisitSection": "9845",
          "ProcedureFindingsSection": "9837",
          "PlanOfCareSection": "9647",
          "ChiefComplaintSection": "9813",
          "ProcedureEstimatedBloodLossSection": "9835",
          "HistoryOfPastIllnessSection": "9819",
          "FamilyHistorySection": "9817",
          "ProceduresSectionEntriesOptional": "9843",
          "ReviewOfSystemsSection": "9847",
          "PhysicalExamSection": "9829",
          "AssessmentSection": "9645"
        },
        "full": {
          "SocialHistorySection": {
            "id": "9849",
            "constraint": "may"
          },
          "ProcedureDispositionSection": {
            "id": "9833",
            "constraint": "may"
          },
          "AssessmentAndPlanSection": {
            "id": "9649",
            "constraint": "may"
          },
          "ChiefComplaintAndReasonForVisitSection": {
            "id": "9815",
            "constraint": "may"
          },
          "ComplicationsSection": {
            "id": "9802",
            "constraint": "shall"
          },
          "HistoryOfPresentIllnessSection": {
            "id": "9821",
            "constraint": "may"
          },
          "ProcedureSpecimensTakenSection": {
            "id": "9841",
            "constraint": "may"
          },
          "PlannedProcedureSection": {
            "id": "9831",
            "constraint": "may"
          },
          "MedicationsSectionEntriesOptional": {
            "id": "9825",
            "constraint": "may"
          },
          "MedicationsAdministeredSection": {
            "id": "9827",
            "constraint": "may"
          },
          "ProcedureImplantsSection": {
            "id": "9839",
            "constraint": "may"
          },
          "ProcedureDescriptionSection": {
            "id": "9805",
            "constraint": "shall"
          },
          "AnesthesiaSection": {
            "id": "9811",
            "constraint": "may"
          },
          "MedicalHistorySection": {
            "id": "9823",
            "constraint": "may"
          },
          "AllergiesSectionEntriesOptional": {
            "id": "9809",
            "constraint": "may"
          },
          "ReasonForVisitSection": {
            "id": "9845",
            "constraint": "may"
          },
          "ProcedureFindingsSection": {
            "id": "9837",
            "constraint": "may"
          },
          "PlanOfCareSection": {
            "id": "9647",
            "constraint": "may"
          },
          "ChiefComplaintSection": {
            "id": "9813",
            "constraint": "may"
          },
          "ProcedureEstimatedBloodLossSection": {
            "id": "9835",
            "constraint": "may"
          },
          "PostprocedureDiagnosisSection": {
            "id": "9850",
            "constraint": "shall"
          },
          "HistoryOfPastIllnessSection": {
            "id": "9819",
            "constraint": "may"
          },
          "FamilyHistorySection": {
            "id": "9817",
            "constraint": "may"
          },
          "ProcedureIndicationsSection": {
            "id": "9807",
            "constraint": "shall"
          },
          "ProceduresSectionEntriesOptional": {
            "id": "9843",
            "constraint": "may"
          },
          "ReviewOfSystemsSection": {
            "id": "9847",
            "constraint": "may"
          },
          "PhysicalExamSection": {
            "id": "9829",
            "constraint": "may"
          },
          "AssessmentSection": {
            "id": "9645",
            "constraint": "may"
          }
        },
        "shall": {
          "ProcedureDescriptionSection": "9805",
          "PostprocedureDiagnosisSection": "9850",
          "ProcedureIndicationsSection": "9807",
          "ComplicationsSection": "9802"
        }
      },
      "DiagnosticImagingReport": {
        "full": {
          "FindingsSection": {
            "id": "8776",
            "constraint": "shall"
          },
          "DICOMObjectCatalogSection": {
            "id": "15141",
            "constraint": "should"
          }
        },
        "shall": {
          "FindingsSection": "8776"
        },
        "should": {
          "DICOMObjectCatalogSection": "15141"
        }
      },
      "ConsultationNote": {
        "may": {
          "ChiefComplaintSection": "9509",
          "AllergiesSectionEntriesOptional": "9507",
          "FamilyHistorySection": "9513",
          "ResultsSectionEntriesOptional": "9527",
          "HistoryOfPastIllnessSection": "9517",
          "SocialHistorySection": "9531",
          "ProblemSectionEntriesOptional": "9523",
          "MedicationsSectionEntriesOptional": "9521)",
          "ImmunizationsSection": "9519",
          "ProceduresSectionEntriesOptional": "9525",
          "AssessmentAndPlanSection": "9491",
          "GeneralStatusSection": "9515",
          "ReasonForVisitSection": "9500",
          "ChiefComplaintAndReasonForVisitSection": "10029",
          "PlanOfCareSection": "9489",
          "ReviewOfSystemsSection": "9529",
          "ReasonForReferralSection": "9498",
          "VitalSignsSectionEntriesOptional": "9533",
          "AssessmentSection": "9487"
        },
        "should": {
          "PhysicalExamSection": "9495"
        },
        "full": {
          "ChiefComplaintSection": {
            "id": "9509",
            "constraint": "may"
          },
          "AllergiesSectionEntriesOptional": {
            "id": "9507",
            "constraint": "may"
          },
          "FamilyHistorySection": {
            "id": "9513",
            "constraint": "may"
          },
          "ResultsSectionEntriesOptional": {
            "id": "9527",
            "constraint": "may"
          },
          "HistoryOfPastIllnessSection": {
            "id": "9517",
            "constraint": "may"
          },
          "SocialHistorySection": {
            "id": "9531",
            "constraint": "may"
          },
          "ProblemSectionEntriesOptional": {
            "id": "9523",
            "constraint": "may"
          },
          "MedicationsSectionEntriesOptional": {
            "id": "9521)",
            "constraint": "may"
          },
          "ImmunizationsSection": {
            "id": "9519",
            "constraint": "may"
          },
          "ProceduresSectionEntriesOptional": {
            "id": "9525",
            "constraint": "may"
          },
          "AssessmentAndPlanSection": {
            "id": "9491",
            "constraint": "may"
          },
          "GeneralStatusSection": {
            "id": "9515",
            "constraint": "may"
          },
          "ReasonForVisitSection": {
            "id": "9500",
            "constraint": "may"
          },
          "ChiefComplaintAndReasonForVisitSection": {
            "id": "10029",
            "constraint": "may"
          },
          "PlanOfCareSection": {
            "id": "9489",
            "constraint": "may"
          },
          "ReviewOfSystemsSection": {
            "id": "9529",
            "constraint": "may"
          },
          "ReasonForReferralSection": {
            "id": "9498",
            "constraint": "may"
          },
          "PhysicalExamSection": {
            "id": "9495",
            "constraint": "should"
          },
          "VitalSignsSectionEntriesOptional": {
            "id": "9533",
            "constraint": "may"
          },
          "AssessmentSection": {
            "id": "9487",
            "constraint": "may"
          },
          "HistoryOfPresentIllnessSection": {
            "id": "9493",
            "constraint": "shall"
          }
        },
        "shall": {
          "HistoryOfPresentIllnessSection": "9493"
        }
      },
      "ProgressNote": {
        "may": {
          "ChiefComplaintSection": "8772",
          "AllergiesSectionEntriesOptional": "8773",
          "ResultsSectionEntriesOptional": "8782",
          "ProblemSectionEntriesOptional": "8786",
          "MedicationsSectionEntriesOptional": "8771",
          "InterventionsSection": "8778",
          "AssessmentAndPlanSection": "8774",
          "ObjectiveSection": "8770",
          "VitalSignsSectionEntriesOptional": "8784",
          "PlanOfCareSection": "8775",
          "ReviewOfSystemsSection": "8788",
          "InstructionsSection": "16806",
          "PhysicalExamSection": "8780",
          "SubjectiveSection": "8790",
          "AssessmentSection": "8776"
        },
        "full": {
          "ChiefComplaintSection": {
            "id": "8772",
            "constraint": "may"
          },
          "AllergiesSectionEntriesOptional": {
            "id": "8773",
            "constraint": "may"
          },
          "ResultsSectionEntriesOptional": {
            "id": "8782",
            "constraint": "may"
          },
          "ProblemSectionEntriesOptional": {
            "id": "8786",
            "constraint": "may"
          },
          "MedicationsSectionEntriesOptional": {
            "id": "8771",
            "constraint": "may"
          },
          "InterventionsSection": {
            "id": "8778",
            "constraint": "may"
          },
          "AssessmentAndPlanSection": {
            "id": "8774",
            "constraint": "may"
          },
          "ObjectiveSection": {
            "id": "8770",
            "constraint": "may"
          },
          "VitalSignsSectionEntriesOptional": {
            "id": "8784",
            "constraint": "may"
          },
          "PlanOfCareSection": {
            "id": "8775",
            "constraint": "may"
          },
          "ReviewOfSystemsSection": {
            "id": "8788",
            "constraint": "may"
          },
          "InstructionsSection": {
            "id": "16806",
            "constraint": "may"
          },
          "PhysicalExamSection": {
            "id": "8780",
            "constraint": "may"
          },
          "SubjectiveSection": {
            "id": "8790",
            "constraint": "may"
          },
          "AssessmentSection": {
            "id": "8776",
            "constraint": "may"
          }
        }
      }
    };

    module.exports = exports = templatesconstraints;

  }, {}], 52: [function (require, module, exports) {
    var templates = {
      "ConsultationNote": "2.16.840.1.113883.10.20.22.1.4",
      "ContinuityOfCareDocument": "2.16.840.1.113883.10.20.22.1.2",
      "DiagnosticImagingReport": "2.16.840.1.113883.10.20.22.1.5",
      "DischargeSummary": "2.16.840.1.113883.10.20.22.1.8",
      "HistoryAndPhysicalNote": "2.16.840.1.113883.10.20.22.1.3",
      "OperativeNote": "2.16.840.1.113883.10.20.22.1.7",
      "ProcedureNote": "2.16.840.1.113883.10.20.22.1.6",
      "ProgressNote": "2.16.840.1.113883.10.20.22.1.9",
      "UnstructuredDocument": "2.16.840.1.113883.10.20.21.1.10"
    };

    module.exports = exports = templates;

  }, {}], 53: [function (require, module, exports) {
    "use strict";

    var oids = require("./oids");

    var codeSystem = {
      codeDisplayName: function (code) {
        return this.cs.table && this.cs.table[code];
      },
      displayNameCode: (function () {
        var reverseTables = {};

        return function (name) {
          var oid = this.oid;
          var reverseTable = reverseTables[oid];
          if (!reverseTable) {
            var table = this.cs.table || {};
            reverseTable = Object.keys(table).reduce(function (r, code) {
              var name = table[code];
              r[name] = code;
              return r;
            }, {});
            reverseTables[oid] = reverseTable;
          }
          return reverseTable[name];
        };
      })(),
      name: function () {
        return this.cs.name;
      },
      systemId: function () {
        var systemOID = this.cs.code_system;
        if (systemOID) {
          return {
            codeSystem: systemOID,
            codeSystemName: oids[systemOID].name
          };
        } else {
          return {
            codeSystem: this.oid,
            codeSystemName: this.cs.name
          };
        }
      }
    };

    exports.find = function (oid) {
      var cs = oids[oid];
      if (cs) {
        var result = Object.create(codeSystem);
        result.oid = oid;
        result.cs = cs;
        return result;
      } else {
        return null;
      }
    };

    exports.findFromName = (function () {
      var nameIndex;

      return function (name) {
        if (!nameIndex) {
          nameIndex = Object.keys(oids).reduce(function (r, oid) {
            var n = oids[oid].name;
            r[n] = oid;
            return r;
          }, {});
        }
        return nameIndex[name];
      };
    })();

  }, { "./oids": 54 }], 54: [function (require, module, exports) {
    module.exports = OIDs = {
      "2.16.840.1.113883.11.20.9.19": {
        name: "Problem Status",
        table: {
          "active": "active",
          "suspended": "suspended",
          "aborted": "aborted",
          "completed": "completed"
        }
      },
      "2.16.840.1.113883.5.8": {
        name: "Act Reason",
        table: {
          "IMMUNE": "Immunity",
          "MEDPREC": "Medical precaution",
          "OSTOCK": "Out of stock",
          "PATOBJ": "Patient objection",
          "PHILISOP": "Philosophical objection",
          "RELIG": "Religious objection",
          "VACEFF": "Vaccine efficacy concerns",
          "VACSAF": "Vaccine safety concerns"
        }
      },
      "2.16.840.1.113883.6.103": {
        name: "ICD-9-CM",
        uri: "http://www.cms.gov/medicare-coverage-database/staticpages/icd-9-code-lookup.aspx"
      },
      "2.16.840.1.113883.6.233": {
        name: "US Department of Veterans Affairs",
        uri: "http://www.hl7.org/documentcenter/public_temp_36CB0CDC-1C23-BA17-0C356EB233D41682/standards/vocabulary/vocabulary_tables/infrastructure/vocabulary/voc_ExternalSystems.html"
      },
      "2.16.840.1.113883.6.69": {
        name: "NDC-FDA Drug Registration",
        uri: "http://phinvads.cdc.gov/vads/ViewCodeSystem.action?id=2.16.840.1.113883.6.69"
      },
      "2.16.840.1.113883.6.253": {
        name: "MediSpan DDID"
      },
      "2.16.840.1.113883.6.27": {
        name: "Multum",
        uri: "http://multum-look-me-up#"
      },
      "2.16.840.1.113883.6.312": {
        name: "multum-drug-synonym-id",
        uri: "http://multum-drug-synonym-id-look-me-up#"
      },
      "2.16.840.1.113883.6.314": {
        name: "multum-drug-id",
        uri: "http://multum-drug-id-look-me-up#"
      },
      "2.16.840.1.113883.6.59": {
        name: "CVX Vaccine",
        uri: "http://www2a.cdc.gov/vaccines/iis/iisstandards/vaccines.asp?rpt=cvx&code="
      },
      "2.16.840.1.113883.5.112": {
        name: "Route Code",
        uri: "http://hl7.org/codes/RouteCode#"
      },
      "2.16.840.1.113883.6.255.1336": {
        name: "InsuranceType Code"
      },
      "2.16.840.1.113883.6.1": {
        name: "LOINC",
        uri: "http://purl.bioontology.org/ontology/LNC/"
      },
      "2.16.840.1.113883.6.88": {
        name: "RXNORM",
        uri: "http://purl.bioontology.org/ontology/RXNORM/"
      },
      "2.16.840.1.113883.6.96": {
        name: "SNOMED CT",
        uri: "http://purl.bioontology.org/ontology/SNOMEDCT/",
        table: {
          "55561003": "Active",
          "421139008": "On Hold",
          "392521001": "Prior History",
          "73425007": "No Longer Active"
        }
      },
      "2.16.840.1.113883.6.12": {
        name: "CPT",
        uri: "http://purl.bioontology.org/ontology/CPT/"
      },
      "2.16.840.1.113883.5.4": {
        name: "ActCode",
        uri: "http://hl7.org/actcode/"
      },
      "2.16.840.1.113883.4.9": {
        name: "UNII",
      },
      "2.16.840.1.113883.1.11.78": {
        name: "Observation Interpretation"
      },
      "2.16.840.1.113883.19": {
        name: "Good Health Clinic",
        uri: "http://hl7.org/goodhealth/"
      },
      "2.16.840.1.113883.6.259": {
        name: "HealthcareServiceLocation",
        uri: "http://hl7.org/healthcareservice/"
      },
      "2.16.840.1.113883.1.11.19185": {
        name: "HL7 Religion",
        uri: "http://hl7.org/codes/ReligiousAffiliation#"
      },
      "2.16.840.1.113883.5.60": {
        name: "LanguageAbilityMode",
        uri: "http://hl7.org/codes/LanguageAbility#",
        table: {
          ESGN: "Expressed signed",
          ESP: "Expressed spoken",
          EWR: "Expressed written",
          RSGN: "Received signed",
          RSP: "Received spoken",
          RWR: "Received written"
        }
      },
      "2.16.840.1.113883.5.2": {
        name: "HL7 Marital Status",
        uri: "http://hl7.org/codes/MaritalStatus#",
        table: {
          "A": "Annulled",
          "D": "Divorced",
          "I": "Interlocutory",
          "L": "Legally Separated",
          "M": "Married",
          "P": "Polygamous",
          "S": "Never Married",
          "T": "Domestic partner",
          "U": "Unmarried",
          "W": "Widowed"
        }
      },
      "2.16.840.1.113883.5.25": {
        name: "Confidentiality Code",
        table: {
          "N": "Normal",
          "R": "Restricted",
          "V": "Very Restricted",
          "U": "Unrestricted"
        }
      },
      "2.16.840.1.113883.5.83": {
        name: "HL7 Result Interpretation",
        uri: "http://hl7.org/codes/ResultInterpretation#",
        table: {
          "B": "better",
          "D": "decreased",
          "U": "increased",
          "W": "worse",
          "<": "low off scale",
          ">": "high off scale",
          "A": "Abnormal",
          "AA": "abnormal alert",
          "H": "High",
          "HH": "high alert",
          "L": "Low",
          "LL": "low alert",
          "N": "Normal",
          "I": "intermediate",
          "MS": "moderately susceptible",
          "R": "resistent",
          "S": "susceptible",
          "VS": "very susceptible",
          "EX": "outside threshold",
          "HX": "above high threshold",
          "LX": "below low threshold",

        }
      },
      "2.16.840.1.113883.5.111": {
        name: "HL7 Role",
        uri: "http://hl7.org/codes/PersonalRelationship#",
        table: {
          "PRN": "Parent"
        }
      },
      "2.16.840.1.113883.5.110": {
        name: "HL7 RoleCode"
      },
      "2.16.840.1.113883.5.1119": {
        name: "HL7 Address",
        uri: "http://hl7.org/codes/Address#",
        table: {
          "BAD": "bad address",
          "CONF": "confidential",
          "DIR": "direct",
          "H": "home address",
          "HP": "primary home",
          "HV": "vacation home",
          "PHYS": "physical visit address",
          "PST": "postal address",
          "PUB": "public",
          "TMP": "temporary",
          "WP": "work place",
          "MC": "mobile contact",
          "PG": "pager",
          "EC": "emergency contact",
          "AS": "answering service"
        }
      },
      "2.16.840.1.113883.5.45": {
        name: "HL7 EntityName",
        uri: "http://hl7.org/codes/EntityName#",
        table: {
          "A": "Artist/Stage",
          "ABC": "Alphabetic",
          "ASGN": "Assigned",
          "C": "License",
          "I": "Indigenous/Tribal",
          "IDE": "Ideographic",
          "L": "Legal",
          "P": "Pseudonym",
          "PHON": "Phonetic",
          "R": "Religious",
          "SNDX": "Soundex",
          "SRCH": "Search",
          "SYL": "Syllabic"
        }
      },
      "2.16.840.1.113883.5.1": {
        name: "HL7 AdministrativeGender",
        uri: "http://hl7.org/codes/AdministrativeGender#",
        table: {
          "F": "Female",
          "M": "Male",
          "UN": "Undifferentiated"
        }
      },
      "2.16.840.1.113883.3.88.12.3221.6.8": {
        name: "Problem Severity",
        uri: "http://purl.bioontology.org/ontology/SNOMEDCT/",
        code_system: "2.16.840.1.113883.6.96",
        table: {
          "255604002": "Mild",
          "371923003": "Mild to moderate",
          "6736007": "Moderate",
          "371924009": "Moderate to severe",
          "24484000": "Severe",
          "399166001": "Fatal"
        }
      },
      "2.16.840.1.113883.3.88.12.80.68": {
        name: "HITSP Problem Status",
        uri: "http://purl.bioontology.org/ontology/SNOMEDCT/",
        code_system: "2.16.840.1.113883.6.96",
        table: {
          "55561003": "Active",
          "73425007": "Inactive",
          "413322009": "Resolved"
        }
      },
      "2.16.840.1.113883.11.20.9.38": {
        name: "Smoking Status/Social History Observation",
        uri: "http://purl.bioontology.org/ontology/SNOMEDCT/",
        code_system: "2.16.840.1.113883.6.96",
        table: {
          "449868002": "Current every day smoker",
          "428041000124106": "Current some day smoker",
          "8517006": "Former smoker",
          "266919005": "Never smoker",
          "77176002": "Smoker, current status unknown",
          "266927001": "Unknown if ever smoked",
          "230056004": "Smoker, current status unknown",
          "229819007": "Tobacco use and exposure",
          "256235009": "Exercise",
          "160573003": "Alcohol intake",
          "364393001": "Nutritional observable",
          "364703007": "Employment detail",
          "425400000": "Toxic exposure status",
          "363908000": "Details of drug misuse behavior",
          "228272008": "Health-related behavior",
          "105421008": "Educational Achievement"
        }
      },
      "2.16.840.1.113883.11.20.9.21": {
        name: "Age Unified Code for Units of Measure",
        uri: "http://phinvads.cdc.gov/vads/ViewValueSet.action?oid=2.16.840.1.114222.4.11.878",
        table: {
          "min": "Minute",
          "h": "Hour",
          "d": "Day",
          "wk": "Week",
          "mo": "Month",
          "a": "Year"
        }
      },
      "2.16.840.1.113883.12.292": {
        name: "CVX",
        uri: "http://phinvads.cdc.gov/vads/ViewCodeSystem.action?id=2.16.840.1.113883.12.292"
      },
      "2.16.840.1.113883.5.1076": {
        name: "HL7 Religious Affiliation",
        uri: "http://ushik.ahrq.gov/ViewItemDetails?system=mdr&itemKey=83154000",
        table: {
          "1008": "Babi & Baha´I faiths",
          "1009": "Baptist",
          "1010": "Bon",
          "1011": "Cao Dai",
          "1012": "Celticism",
          "1013": "Christian (non-Catholic, non-specific)",
          "1014": "Confucianism",
          "1015": "Cyberculture Religions",
          "1016": "Divination",
          "1017": "Fourth Way",
          "1018": "Free Daism",
          "1019": "Gnosis",
          "1020": "Hinduism",
          "1021": "Humanism",
          "1022": "Independent",
          "1023": "Islam",
          "1024": "Jainism",
          "1025": "Jehovah´s Witnesses",
          "1026": "Judaism",
          "1027": "Latter Day Saints",
          "1028": "Lutheran",
          "1029": "Mahayana",
          "1030": "Meditation",
          "1031": "Messianic Judaism",
          "1032": "Mitraism",
          "1033": "New Age",
          "1034": "non-Roman Catholic",
          "1035": "Occult",
          "1036": "Orthodox",
          "1037": "Paganism",
          "1038": "Pentecostal",
          "1039": "Process, The",
          "1040": "Reformed/Presbyterian",
          "1041": "Roman Catholic Church",
          "1042": "Satanism",
          "1043": "Scientology",
          "1044": "Shamanism",
          "1045": "Shiite (Islam)",
          "1046": "Shinto",
          "1047": "Sikism",
          "1048": "Spiritualism",
          "1049": "Sunni (Islam)",
          "1050": "Taoism",
          "1051": "Theravada",
          "1052": "Unitarian-Universalism",
          "1053": "Universal Life Church",
          "1054": "Vajrayana (Tibetan)",
          "1055": "Veda",
          "1056": "Voodoo",
          "1057": "Wicca",
          "1058": "Yaohushua",
          "1059": "Zen Buddhism",
          "1060": "Zoroastrianism",
          "1062": "Brethren",
          "1063": "Christian Scientist",
          "1064": "Church of Christ",
          "1065": "Church of God",
          "1066": "Congregational",
          "1067": "Disciples of Christ",
          "1068": "Eastern Orthodox",
          "1069": "Episcopalian",
          "1070": "Evangelical Covenant",
          "1071": "Friends",
          "1072": "Full Gospel",
          "1073": "Methodist",
          "1074": "Native American",
          "1075": "Nazarene",
          "1076": "Presbyterian",
          "1077": "Protestant",
          "1078": "Protestant, No Denomination",
          "1079": "Reformed",
          "1080": "Salvation Army",
          "1081": "Unitarian Universalist",
          "1082": "United Church of Christ"
        }
      },
      "2.16.840.1.113883.1.11.11526": {
        "name": "Internet Society Language",
        "uri": "http://www.loc.gov/standards/iso639-2/php/English_list.php"
      },
      "2.16.840.1.113883.11.20.9.22": {
        name: "ActStatus",
        table: {
          "completed": "Completed",
          "active": "Active",
          "aborted": "Aborted",
          "cancelled": "Cancelled"
        }
      },
      "2.16.840.1.113883.6.238": {
        name: "Race and Ethnicity - CDC",
        uri: "http://phinvads.cdc.gov/vads/ViewCodeSystemConcept.action?oid=2.16.840.1.113883.6.238&code=",
        table: {
          "1002-5": "American Indian or Alaska Native",
          "2028-9": "Asian",
          "2054-5": "Black or African American",
          "2076-8": "Native Hawaiian or Other Pacific Islander",
          "2106-3": "White",
          "2131-1": "Other Race",
          "1004-1": "American Indian",
          "1735-0": "Alaska Native",
          "2029-7": "Asian Indian",
          "2030-5": "Bangladeshi",
          "2031-3": "Bhutanese",
          "2032-1": "Burmese",
          "2033-9": "Cambodian",
          "2034-7": "Chinese",
          "2035-4": "Taiwanese",
          "2036-2": "Filipino",
          "2037-0": "Hmong",
          "2038-8": "Indonesian",
          "2039-6": "Japanese",
          "2040-4": "Korean",
          "2041-2": "Laotian",
          "2042-0": "Malaysian",
          "2043-8": "Okinawan",
          "2044-6": "Pakistani",
          "2045-3": "Sri Lankan",
          "2046-1": "Thai",
          "2047-9": "Vietnamese",
          "2048-7": "Iwo Jiman",
          "2049-5": "Maldivian",
          "2050-3": "Nepalese",
          "2051-1": "Singaporean",
          "2052-9": "Madagascar",
          "2056-0": "Black",
          "2058-6": "African American",
          "2060-2": "African",
          "2067-7": "Bahamian",
          "2068-5": "Barbadian",
          "2069-3": "Dominican",
          "2070-1": "Dominica Islander",
          "2071-9": "Haitian",
          "2072-7": "Jamaican",
          "2073-5": "Tobagoan",
          "2074-3": "Trinidadian",
          "2075-0": "West Indian",
          "2078-4": "Polynesian",
          "2085-9": "Micronesian",
          "2100-6": "Melanesian",
          "2500-7": "Other Pacific Islander",
          "2108-9": "European",
          "2118-8": "Middle Eastern or North African",
          "2129-5": "Arab",
          "1006-6": "Abenaki",
          "1008-2": "Algonquian",
          "1010-8": "Apache",
          "1021-5": "Arapaho",
          "1026-4": "Arikara",
          "1028-0": "Assiniboine",
          "1030-6": "Assiniboine Sioux",
          "1033-0": "Bannock",
          "1035-5": "Blackfeet",
          "1037-1": "Brotherton",
          "1039-7": "Burt Lake Band",
          "1041-3": "Caddo",
          "1044-7": "Cahuilla",
          "1053-8": "California Tribes",
          "1068-6": "Canadian and Latin American Indian",
          "1076-9": "Catawba",
          "1078-5": "Cayuse",
          "1080-1": "Chehalis",
          "1082-7": "Chemakuan",
          "1086-8": "Chemehuevi",
          "1088-4": "Cherokee",
          "1100-7": "Cherokee Shawnee",
          "1102-3": "Cheyenne",
          "1106-4": "Cheyenne-Arapaho",
          "1108-0": "Chickahominy",
          "1112-2": "Chickasaw",
          "1114-8": "Chinook",
          "1123-9": "Chippewa",
          "1150-2": "Chippewa Cree",
          "1153-6": "Chitimacha",
          "1155-1": "Choctaw",
          "1162-7": "Chumash",
          "1165-0": "Clear Lake",
          "1167-6": "Coeur D'Alene",
          "1169-2": "Coharie",
          "1171-8": "Colorado River",
          "1173-4": "Colville",
          "1175-9": "Comanche",
          "1178-3": "Coos, Lower Umpqua, Siuslaw",
          "1180-9": "Coos",
          "1182-5": "Coquilles",
          "1184-1": "Costanoan",
          "1186-6": "Coushatta",
          "1189-0": "Cowlitz",
          "1191-6": "Cree",
          "1193-2": "Creek",
          "1207-0": "Croatan",
          "1209-6": "Crow",
          "1211-2": "Cupeno",
          "1214-6": "Delaware",
          "1222-9": "Diegueno",
          "1233-6": "Eastern Tribes",
          "1250-0": "Esselen",
          "1252-6": "Fort Belknap",
          "1254-2": "Fort Berthold",
          "1256-7": "Fort Mcdowell",
          "1258-3": "Fort Hall",
          "1260-9": "Gabrieleno",
          "1262-5": "Grand Ronde",
          "1264-1": "Gros Ventres",
          "1267-4": "Haliwa",
          "1269-0": "Hidatsa",
          "1271-6": "Hoopa",
          "1275-7": "Hoopa Extension",
          "1277-3": "Houma",
          "1279-9": "Inaja-Cosmit",
          "1281-5": "Iowa",
          "1285-6": "Iroquois",
          "1297-1": "Juaneno",
          "1299-7": "Kalispel",
          "1301-1": "Karuk",
          "1303-7": "Kaw",
          "1305-2": "Kickapoo",
          "1309-4": "Kiowa",
          "1312-8": "Klallam",
          "1317-7": "Klamath",
          "1319-3": "Konkow",
          "1321-9": "Kootenai",
          "1323-5": "Lassik",
          "1325-0": "Long Island",
          "1331-8": "Luiseno",
          "1340-9": "Lumbee",
          "1342-5": "Lummi",
          "1344-1": "Maidu",
          "1348-2": "Makah",
          "1350-8": "Maliseet",
          "1352-4": "Mandan",
          "1354-0": "Mattaponi",
          "1356-5": "Menominee",
          "1358-1": "Miami",
          "1363-1": "Miccosukee",
          "1365-6": "Micmac",
          "1368-0": "Mission Indians",
          "1370-6": "Miwok",
          "1372-2": "Modoc",
          "1374-8": "Mohegan",
          "1376-3": "Mono",
          "1378-9": "Nanticoke",
          "1380-5": "Narragansett",
          "1382-1": "Navajo",
          "1387-0": "Nez Perce",
          "1389-6": "Nomalaki",
          "1391-2": "Northwest Tribes",
          "1403-5": "Omaha",
          "1405-0": "Oregon Athabaskan",
          "1407-6": "Osage",
          "1409-2": "Otoe-Missouria",
          "1411-8": "Ottawa",
          "1416-7": "Paiute",
          "1439-9": "Pamunkey",
          "1441-5": "Passamaquoddy",
          "1445-6": "Pawnee",
          "1448-0": "Penobscot",
          "1450-6": "Peoria",
          "1453-0": "Pequot",
          "1456-3": "Pima",
          "1460-5": "Piscataway",
          "1462-1": "Pit River",
          "1464-7": "Pomo",
          "1474-6": "Ponca",
          "1478-7": "Potawatomi",
          "1487-8": "Powhatan",
          "1489-4": "Pueblo",
          "1518-0": "Puget Sound Salish",
          "1541-2": "Quapaw",
          "1543-8": "Quinault",
          "1545-3": "Rappahannock",
          "1547-9": "Reno-Sparks",
          "1549-5": "Round Valley",
          "1551-1": "Sac and Fox",
          "1556-0": "Salinan",
          "1558-6": "Salish",
          "1560-2": "Salish and Kootenai",
          "1562-8": "Schaghticoke",
          "1564-4": "Scott Valley",
          "1566-9": "Seminole",
          "1573-5": "Serrano",
          "1576-8": "Shasta",
          "1578-4": "Shawnee",
          "1582-6": "Shinnecock",
          "1584-2": "Shoalwater Bay",
          "1586-7": "Shoshone",
          "1602-2": "Shoshone Paiute",
          "1607-1": "Siletz",
          "1609-7": "Sioux",
          "1643-6": "Siuslaw",
          "1645-1": "Spokane",
          "1647-7": "Stewart",
          "1649-3": "Stockbridge",
          "1651-9": "Susanville",
          "1653-5": "Tohono O'Odham",
          "1659-2": "Tolowa",
          "1661-8": "Tonkawa",
          "1663-4": "Tygh",
          "1665-9": "Umatilla",
          "1667-5": "Umpqua",
          "1670-9": "Ute",
          "1675-8": "Wailaki",
          "1677-4": "Walla-Walla",
          "1679-0": "Wampanoag",
          "1683-2": "Warm Springs",
          "1685-7": "Wascopum",
          "1687-3": "Washoe",
          "1692-3": "Wichita",
          "1694-9": "Wind River",
          "1696-4": "Winnebago",
          "1700-4": "Winnemucca",
          "1702-0": "Wintun",
          "1704-6": "Wiyot",
          "1707-9": "Yakama",
          "1709-5": "Yakama Cowlitz",
          "1711-1": "Yaqui",
          "1715-2": "Yavapai Apache",
          "1717-8": "Yokuts",
          "1722-8": "Yuchi",
          "1724-4": "Yuman",
          "1732-7": "Yurok",
          "1737-6": "Alaska Indian",
          "1840-8": "Eskimo",
          "1966-1": "Aleut",
          "2061-0": "Botswanan",
          "2062-8": "Ethiopian",
          "2063-6": "Liberian",
          "2064-4": "Namibian",
          "2065-1": "Nigerian",
          "2066-9": "Zairean",
          "2079-2": "Native Hawaiian",
          "2080-0": "Samoan",
          "2081-8": "Tahitian",
          "2082-6": "Tongan",
          "2083-4": "Tokelauan",
          "2086-7": "Guamanian or Chamorro",
          "2087-5": "Guamanian",
          "2088-3": "Chamorro",
          "2089-1": "Mariana Islander",
          "2090-9": "Marshallese",
          "2091-7": "Palauan",
          "2092-5": "Carolinian",
          "2093-3": "Kosraean",
          "2094-1": "Pohnpeian",
          "2095-8": "Saipanese",
          "2096-6": "Kiribati",
          "2097-4": "Chuukese",
          "2098-2": "Yapese",
          "2101-4": "Fijian",
          "2102-2": "Papua New Guinean",
          "2103-0": "Solomon Islander",
          "2104-8": "New Hebrides",
          "2109-7": "Armenian",
          "2110-5": "English",
          "2111-3": "French",
          "2112-1": "German",
          "2113-9": "Irish",
          "2114-7": "Italian",
          "2115-4": "Polish",
          "2116-2": "Scottish",
          "2119-6": "Assyrian",
          "2120-4": "Egyptian",
          "2121-2": "Iranian",
          "2122-0": "Iraqi",
          "2123-8": "Lebanese",
          "2124-6": "Palestinian",
          "2125-3": "Syrian",
          "2126-1": "Afghanistani",
          "2127-9": "Israeili",
          "1011-6": "Chiricahua",
          "1012-4": "Fort Sill Apache",
          "1013-2": "Jicarilla Apache",
          "1014-0": "Lipan Apache",
          "1015-7": "Mescalero Apache",
          "1016-5": "Oklahoma Apache",
          "1017-3": "Payson Apache",
          "1018-1": "San Carlos Apache",
          "1019-9": "White Mountain Apache",
          "1022-3": "Northern Arapaho",
          "1023-1": "Southern Arapaho",
          "1024-9": "Wind River Arapaho",
          "1031-4": "Fort Peck Assiniboine Sioux",
          "1042-1": "Oklahoma Cado",
          "1045-4": "Agua Caliente Cahuilla",
          "1046-2": "Augustine",
          "1047-0": "Cabazon",
          "1048-8": "Los Coyotes",
          "1049-6": "Morongo",
          "1050-4": "Santa Rosa Cahuilla",
          "1051-2": "Torres-Martinez",
          "1054-6": "Cahto",
          "1055-3": "Chimariko",
          "1056-1": "Coast Miwok",
          "1057-9": "Digger",
          "1058-7": "Kawaiisu",
          "1059-5": "Kern River",
          "1060-3": "Mattole",
          "1061-1": "Red Wood",
          "1062-9": "Santa Rosa",
          "1063-7": "Takelma",
          "1064-5": "Wappo",
          "1065-2": "Yana",
          "1066-0": "Yuki",
          "1069-4": "Canadian Indian",
          "1070-2": "Central American Indian",
          "1071-0": "French American Indian",
          "1072-8": "Mexican American Indian",
          "1073-6": "South American Indian",
          "1074-4": "Spanish American Indian",
          "1083-5": "Hoh",
          "1084-3": "Quileute",
          "1089-2": "Cherokee Alabama",
          "1090-0": "Cherokees of Northeast Alabama",
          "1091-8": "Cherokees of Southeast Alabama",
          "1092-6": "Eastern Cherokee",
          "1093-4": "Echota Cherokee",
          "1094-2": "Etowah Cherokee",
          "1095-9": "Northern Cherokee",
          "1096-7": "Tuscola",
          "1097-5": "United Keetowah Band of Cherokee",
          "1098-3": "Western Cherokee",
          "1103-1": "Northern Cheyenne",
          "1104-9": "Southern Cheyenne",
          "1109-8": "Eastern Chickahominy",
          "1110-6": "Western Chickahominy",
          "1115-5": "Clatsop",
          "1116-3": "Columbia River Chinook",
          "1117-1": "Kathlamet",
          "1118-9": "Upper Chinook",
          "1119-7": "Wakiakum Chinook",
          "1120-5": "Willapa Chinook",
          "1121-3": "Wishram",
          "1124-7": "Bad River",
          "1125-4": "Bay Mills Chippewa",
          "1126-2": "Bois Forte",
          "1127-0": "Burt Lake Chippewa",
          "1128-8": "Fond du Lac",
          "1129-6": "Grand Portage",
          "1130-4": "Grand Traverse Band of Ottawa/Chippewa",
          "1131-2": "Keweenaw",
          "1132-0": "Lac Courte Oreilles",
          "1133-8": "Lac du Flambeau",
          "1134-6": "Lac Vieux Desert Chippewa",
          "1135-3": "Lake Superior",
          "1136-1": "Leech Lake",
          "1137-9": "Little Shell Chippewa",
          "1138-7": "Mille Lacs",
          "1139-5": "Minnesota Chippewa",
          "1140-3": "Ontonagon",
          "1141-1": "Red Cliff Chippewa",
          "1142-9": "Red Lake Chippewa",
          "1143-7": "Saginaw Chippewa",
          "1144-5": "St. Croix Chippewa",
          "1145-2": "Sault Ste. Marie Chippewa",
          "1146-0": "Sokoagon Chippewa",
          "1147-8": "Turtle Mountain",
          "1148-6": "White Earth",
          "1151-0": "Rocky Boy's Chippewa Cree",
          "1156-9": "Clifton Choctaw",
          "1157-7": "Jena Choctaw",
          "1158-5": "Mississippi Choctaw",
          "1159-3": "Mowa Band of Choctaw",
          "1160-1": "Oklahoma Choctaw",
          "1163-5": "Santa Ynez",
          "1176-7": "Oklahoma Comanche",
          "1187-4": "Alabama Coushatta",
          "1194-0": "Alabama Creek",
          "1195-7": "Alabama Quassarte",
          "1196-5": "Eastern Creek",
          "1197-3": "Eastern Muscogee",
          "1198-1": "Kialegee",
          "1199-9": "Lower Muscogee",
          "1200-5": "Machis Lower Creek Indian",
          "1201-3": "Poarch Band",
          "1202-1": "Principal Creek Indian Nation",
          "1203-9": "Star Clan of Muscogee Creeks",
          "1204-7": "Thlopthlocco",
          "1205-4": "Tuckabachee",
          "1212-0": "Agua Caliente",
          "1215-3": "Eastern Delaware",
          "1216-1": "Lenni-Lenape",
          "1217-9": "Munsee",
          "1218-7": "Oklahoma Delaware",
          "1219-5": "Rampough Mountain",
          "1220-3": "Sand Hill",
          "1223-7": "Campo",
          "1224-5": "Capitan Grande",
          "1225-2": "Cuyapaipe",
          "1226-0": "La Posta",
          "1227-8": "Manzanita",
          "1228-6": "Mesa Grande",
          "1229-4": "San Pasqual",
          "1230-2": "Santa Ysabel",
          "1231-0": "Sycuan",
          "1234-4": "Attacapa",
          "1235-1": "Biloxi",
          "1236-9": "Georgetown (Eastern Tribes)",
          "1237-7": "Moor",
          "1238-5": "Nansemond",
          "1239-3": "Natchez",
          "1240-1": "Nausu Waiwash",
          "1241-9": "Nipmuc",
          "1242-7": "Paugussett",
          "1243-5": "Pocomoke Acohonock",
          "1244-3": "Southeastern Indians",
          "1245-0": "Susquehanock",
          "1246-8": "Tunica Biloxi",
          "1247-6": "Waccamaw-Siousan",
          "1248-4": "Wicomico",
          "1265-8": "Atsina",
          "1272-4": "Trinity",
          "1273-2": "Whilkut",
          "1282-3": "Iowa of Kansas-Nebraska",
          "1283-1": "Iowa of Oklahoma",
          "1286-4": "Cayuga",
          "1287-2": "Mohawk",
          "1288-0": "Oneida",
          "1289-8": "Onondaga",
          "1290-6": "Seneca",
          "1291-4": "Seneca Nation",
          "1292-2": "Seneca-Cayuga",
          "1293-0": "Tonawanda Seneca",
          "1294-8": "Tuscarora",
          "1295-5": "Wyandotte",
          "1306-0": "Oklahoma Kickapoo",
          "1307-8": "Texas Kickapoo",
          "1310-2": "Oklahoma Kiowa",
          "1313-6": "Jamestown",
          "1314-4": "Lower Elwha",
          "1315-1": "Port Gamble Klallam",
          "1326-8": "Matinecock",
          "1327-6": "Montauk",
          "1328-4": "Poospatuck",
          "1329-2": "Setauket",
          "1332-6": "La Jolla",
          "1333-4": "Pala",
          "1334-2": "Pauma",
          "1335-9": "Pechanga",
          "1336-7": "Soboba",
          "1337-5": "Twenty-Nine Palms",
          "1338-3": "Temecula",
          "1345-8": "Mountain Maidu",
          "1346-6": "Nishinam",
          "1359-9": "Illinois Miami",
          "1360-7": "Indiana Miami",
          "1361-5": "Oklahoma Miami",
          "1366-4": "Aroostook",
          "1383-9": "Alamo Navajo",
          "1384-7": "Canoncito Navajo",
          "1385-4": "Ramah Navajo",
          "1392-0": "Alsea",
          "1393-8": "Celilo",
          "1394-6": "Columbia",
          "1395-3": "Kalapuya",
          "1396-1": "Molala",
          "1397-9": "Talakamish",
          "1398-7": "Tenino",
          "1399-5": "Tillamook",
          "1400-1": "Wenatchee",
          "1401-9": "Yahooskin",
          "1412-6": "Burt Lake Ottawa",
          "1413-4": "Michigan Ottawa",
          "1414-2": "Oklahoma Ottawa",
          "1417-5": "Bishop",
          "1418-3": "Bridgeport",
          "1419-1": "Burns Paiute",
          "1420-9": "Cedarville",
          "1421-7": "Fort Bidwell",
          "1422-5": "Fort Independence",
          "1423-3": "Kaibab",
          "1424-1": "Las Vegas",
          "1425-8": "Lone Pine",
          "1426-6": "Lovelock",
          "1427-4": "Malheur Paiute",
          "1428-2": "Moapa",
          "1429-0": "Northern Paiute",
          "1430-8": "Owens Valley",
          "1431-6": "Pyramid Lake",
          "1432-4": "San Juan Southern Paiute",
          "1433-2": "Southern Paiute",
          "1434-0": "Summit Lake",
          "1435-7": "Utu Utu Gwaitu Paiute",
          "1436-5": "Walker River",
          "1437-3": "Yerington Paiute",
          "1442-3": "Indian Township",
          "1443-1": "Pleasant Point Passamaquoddy",
          "1446-4": "Oklahoma Pawnee",
          "1451-4": "Oklahoma Peoria",
          "1454-8": "Marshantucket Pequot",
          "1457-1": "Gila River Pima-Maricopa",
          "1458-9": "Salt River Pima-Maricopa",
          "1465-4": "Central Pomo",
          "1466-2": "Dry Creek",
          "1467-0": "Eastern Pomo",
          "1468-8": "Kashia",
          "1469-6": "Northern Pomo",
          "1470-4": "Scotts Valley",
          "1471-2": "Stonyford",
          "1472-0": "Sulphur Bank",
          "1475-3": "Nebraska Ponca",
          "1476-1": "Oklahoma Ponca",
          "1479-5": "Citizen Band Potawatomi",
          "1480-3": "Forest County",
          "1481-1": "Hannahville",
          "1482-9": "Huron Potawatomi",
          "1483-7": "Pokagon Potawatomi",
          "1484-5": "Prairie Band",
          "1485-2": "Wisconsin Potawatomi",
          "1490-2": "Acoma",
          "1491-0": "Arizona Tewa",
          "1492-8": "Cochiti",
          "1493-6": "Hopi",
          "1494-4": "Isleta",
          "1495-1": "Jemez",
          "1496-9": "Keres",
          "1497-7": "Laguna",
          "1498-5": "Nambe",
          "1499-3": "Picuris",
          "1500-8": "Piro",
          "1501-6": "Pojoaque",
          "1502-4": "San Felipe",
          "1503-2": "San Ildefonso",
          "1504-0": "San Juan Pueblo",
          "1505-7": "San Juan De",
          "1506-5": "San Juan",
          "1507-3": "Sandia",
          "1508-1": "Santa Ana",
          "1509-9": "Santa Clara",
          "1510-7": "Santo Domingo",
          "1511-5": "Taos",
          "1512-3": "Tesuque",
          "1513-1": "Tewa",
          "1514-9": "Tigua",
          "1515-6": "Zia",
          "1516-4": "Zuni",
          "1519-8": "Duwamish",
          "1520-6": "Kikiallus",
          "1521-4": "Lower Skagit",
          "1522-2": "Muckleshoot",
          "1523-0": "Nisqually",
          "1524-8": "Nooksack",
          "1525-5": "Port Madison",
          "1526-3": "Puyallup",
          "1527-1": "Samish",
          "1528-9": "Sauk-Suiattle",
          "1529-7": "Skokomish",
          "1530-5": "Skykomish",
          "1531-3": "Snohomish",
          "1532-1": "Snoqualmie",
          "1533-9": "Squaxin Island",
          "1534-7": "Steilacoom",
          "1535-4": "Stillaguamish",
          "1536-2": "Suquamish",
          "1537-0": "Swinomish",
          "1538-8": "Tulalip",
          "1539-6": "Upper Skagit",
          "1552-9": "Iowa Sac and Fox",
          "1553-7": "Missouri Sac and Fox",
          "1554-5": "Oklahoma Sac and Fox",
          "1567-7": "Big Cypress",
          "1568-5": "Brighton",
          "1569-3": "Florida Seminole",
          "1570-1": "Hollywood Seminole",
          "1571-9": "Oklahoma Seminole",
          "1574-3": "San Manual",
          "1579-2": "Absentee Shawnee",
          "1580-0": "Eastern Shawnee",
          "1587-5": "Battle Mountain",
          "1588-3": "Duckwater",
          "1589-1": "Elko",
          "1590-9": "Ely",
          "1591-7": "Goshute",
          "1592-5": "Panamint",
          "1593-3": "Ruby Valley",
          "1594-1": "Skull Valley",
          "1595-8": "South Fork Shoshone",
          "1596-6": "Te-Moak Western Shoshone",
          "1597-4": "Timbi-Sha Shoshone",
          "1598-2": "Washakie",
          "1599-0": "Wind River Shoshone",
          "1600-6": "Yomba",
          "1603-0": "Duck Valley",
          "1604-8": "Fallon",
          "1605-5": "Fort McDermitt",
          "1610-5": "Blackfoot Sioux",
          "1611-3": "Brule Sioux",
          "1612-1": "Cheyenne River Sioux",
          "1613-9": "Crow Creek Sioux",
          "1614-7": "Dakota Sioux",
          "1615-4": "Flandreau Santee",
          "1616-2": "Fort Peck",
          "1617-0": "Lake Traverse Sioux",
          "1618-8": "Lower Brule Sioux",
          "1619-6": "Lower Sioux",
          "1620-4": "Mdewakanton Sioux",
          "1621-2": "Miniconjou",
          "1622-0": "Oglala Sioux",
          "1623-8": "Pine Ridge Sioux",
          "1624-6": "Pipestone Sioux",
          "1625-3": "Prairie Island Sioux",
          "1626-1": "Prior Lake Sioux",
          "1627-9": "Rosebud Sioux",
          "1628-7": "Sans Arc Sioux",
          "1629-5": "Santee Sioux",
          "1630-3": "Sisseton-Wahpeton",
          "1631-1": "Sisseton Sioux",
          "1632-9": "Spirit Lake Sioux",
          "1633-7": "Standing Rock Sioux",
          "1634-5": "Teton Sioux",
          "1635-2": "Two Kettle Sioux",
          "1636-0": "Upper Sioux",
          "1637-8": "Wahpekute Sioux",
          "1638-6": "Wahpeton Sioux",
          "1639-4": "Wazhaza Sioux",
          "1640-2": "Yankton Sioux",
          "1641-0": "Yanktonai Sioux",
          "1654-3": "Ak-Chin",
          "1655-0": "Gila Bend",
          "1656-8": "San Xavier",
          "1657-6": "Sells",
          "1668-3": "Cow Creek Umpqua",
          "1671-7": "Allen Canyon",
          "1672-5": "Uintah Ute",
          "1673-3": "Ute Mountain Ute",
          "1680-8": "Gay Head Wampanoag",
          "1681-6": "Mashpee Wampanoag",
          "1688-1": "Alpine",
          "1689-9": "Carson",
          "1690-7": "Dresslerville",
          "1697-2": "Ho-chunk",
          "1698-0": "Nebraska Winnebago",
          "1705-3": "Table Bluff",
          "1712-9": "Barrio Libre",
          "1713-7": "Pascua Yaqui",
          "1718-6": "Chukchansi",
          "1719-4": "Tachi",
          "1720-2": "Tule River",
          "1725-1": "Cocopah",
          "1726-9": "Havasupai",
          "1727-7": "Hualapai",
          "1728-5": "Maricopa",
          "1729-3": "Mohave",
          "1730-1": "Quechan",
          "1731-9": "Yavapai",
          "1733-5": "Coast Yurok",
          "1739-2": "Alaskan Athabascan",
          "1811-9": "Southeast Alaska",
          "1842-4": "Greenland Eskimo",
          "1844-0": "Inupiat Eskimo",
          "1891-1": "Siberian Eskimo",
          "1896-0": "Yupik Eskimo",
          "1968-7": "Alutiiq Aleut",
          "1972-9": "Bristol Bay Aleut",
          "1984-4": "Chugach Aleut",
          "1990-1": "Eyak",
          "1992-7": "Koniag Aleut",
          "2002-4": "Sugpiaq",
          "2004-0": "Suqpigaq",
          "2006-5": "Unangan Aleut",
          "1740-0": "Ahtna",
          "1741-8": "Alatna",
          "1742-6": "Alexander",
          "1743-4": "Allakaket",
          "1744-2": "Alanvik",
          "1745-9": "Anvik",
          "1746-7": "Arctic",
          "1747-5": "Beaver",
          "1748-3": "Birch Creek",
          "1749-1": "Cantwell",
          "1750-9": "Chalkyitsik",
          "1751-7": "Chickaloon",
          "1752-5": "Chistochina",
          "1753-3": "Chitina",
          "1754-1": "Circle",
          "1755-8": "Cook Inlet",
          "1756-6": "Copper Center",
          "1757-4": "Copper River",
          "1758-2": "Dot Lake",
          "1759-0": "Doyon",
          "1760-8": "Eagle",
          "1761-6": "Eklutna",
          "1762-4": "Evansville",
          "1763-2": "Fort Yukon",
          "1764-0": "Gakona",
          "1765-7": "Galena",
          "1766-5": "Grayling",
          "1767-3": "Gulkana",
          "1768-1": "Healy Lake",
          "1769-9": "Holy Cross",
          "1770-7": "Hughes",
          "1771-5": "Huslia",
          "1772-3": "Iliamna",
          "1773-1": "Kaltag",
          "1774-9": "Kluti Kaah",
          "1775-6": "Knik",
          "1776-4": "Koyukuk",
          "1777-2": "Lake Minchumina",
          "1778-0": "Lime",
          "1779-8": "Mcgrath",
          "1780-6": "Manley Hot Springs",
          "1781-4": "Mentasta Lake",
          "1782-2": "Minto",
          "1783-0": "Nenana",
          "1784-8": "Nikolai",
          "1785-5": "Ninilchik",
          "1786-3": "Nondalton",
          "1787-1": "Northway",
          "1788-9": "Nulato",
          "1789-7": "Pedro Bay",
          "1790-5": "Rampart",
          "1791-3": "Ruby",
          "1792-1": "Salamatof",
          "1793-9": "Seldovia",
          "1794-7": "Slana",
          "1795-4": "Shageluk",
          "1796-2": "Stevens",
          "1797-0": "Stony River",
          "1798-8": "Takotna",
          "1799-6": "Tanacross",
          "1800-2": "Tanaina",
          "1801-0": "Tanana",
          "1802-8": "Tanana Chiefs",
          "1803-6": "Tazlina",
          "1804-4": "Telida",
          "1805-1": "Tetlin",
          "1806-9": "Tok",
          "1807-7": "Tyonek",
          "1808-5": "Venetie",
          "1809-3": "Wiseman",
          "1813-5": "Tlingit-Haida",
          "1837-4": "Tsimshian",
          "1845-7": "Ambler",
          "1846-5": "Anaktuvuk",
          "1847-3": "Anaktuvuk Pass",
          "1848-1": "Arctic Slope Inupiat",
          "1849-9": "Arctic Slope Corporation",
          "1850-7": "Atqasuk",
          "1851-5": "Barrow",
          "1852-3": "Bering Straits Inupiat",
          "1853-1": "Brevig Mission",
          "1854-9": "Buckland",
          "1855-6": "Chinik",
          "1856-4": "Council",
          "1857-2": "Deering",
          "1858-0": "Elim",
          "1859-8": "Golovin",
          "1860-6": "Inalik Diomede",
          "1861-4": "Inupiaq",
          "1862-2": "Kaktovik",
          "1863-0": "Kawerak",
          "1864-8": "Kiana",
          "1865-5": "Kivalina",
          "1866-3": "Kobuk",
          "1867-1": "Kotzebue",
          "1868-9": "Koyuk",
          "1869-7": "Kwiguk",
          "1870-5": "Mauneluk Inupiat",
          "1871-3": "Nana Inupiat",
          "1872-1": "Noatak",
          "1873-9": "Nome",
          "1874-7": "Noorvik",
          "1875-4": "Nuiqsut",
          "1876-2": "Point Hope",
          "1877-0": "Point Lay",
          "1878-8": "Selawik",
          "1879-6": "Shaktoolik",
          "1880-4": "Shishmaref",
          "1881-2": "Shungnak",
          "1882-0": "Solomon",
          "1883-8": "Teller",
          "1884-6": "Unalakleet",
          "1885-3": "Wainwright",
          "1886-1": "Wales",
          "1887-9": "White Mountain",
          "1888-7": "White Mountain Inupiat",
          "1889-5": "Mary's Igloo",
          "1892-9": "Gambell",
          "1893-7": "Savoonga",
          "1894-5": "Siberian Yupik",
          "1897-8": "Akiachak",
          "1898-6": "Akiak",
          "1899-4": "Alakanuk",
          "1900-0": "Aleknagik",
          "1901-8": "Andreafsky",
          "1902-6": "Aniak",
          "1903-4": "Atmautluak",
          "1904-2": "Bethel",
          "1905-9": "Bill Moore's Slough",
          "1906-7": "Bristol Bay Yupik",
          "1907-5": "Calista Yupik",
          "1908-3": "Chefornak",
          "1909-1": "Chevak",
          "1910-9": "Chuathbaluk",
          "1911-7": "Clark's Point",
          "1912-5": "Crooked Creek",
          "1913-3": "Dillingham",
          "1914-1": "Eek",
          "1915-8": "Ekuk",
          "1916-6": "Ekwok",
          "1917-4": "Emmonak",
          "1918-2": "Goodnews Bay",
          "1919-0": "Hooper Bay",
          "1920-8": "Iqurmuit (Russian Mission)",
          "1921-6": "Kalskag",
          "1922-4": "Kasigluk",
          "1923-2": "Kipnuk",
          "1924-0": "Koliganek",
          "1925-7": "Kongiganak",
          "1926-5": "Kotlik",
          "1927-3": "Kwethluk",
          "1928-1": "Kwigillingok",
          "1929-9": "Levelock",
          "1930-7": "Lower Kalskag",
          "1931-5": "Manokotak",
          "1932-3": "Marshall",
          "1933-1": "Mekoryuk",
          "1934-9": "Mountain Village",
          "1935-6": "Naknek",
          "1936-4": "Napaumute",
          "1937-2": "Napakiak",
          "1938-0": "Napaskiak",
          "1939-8": "Newhalen",
          "1940-6": "New Stuyahok",
          "1941-4": "Newtok",
          "1942-2": "Nightmute",
          "1943-0": "Nunapitchukv",
          "1944-8": "Oscarville",
          "1945-5": "Pilot Station",
          "1946-3": "Pitkas Point",
          "1947-1": "Platinum",
          "1948-9": "Portage Creek",
          "1949-7": "Quinhagak",
          "1950-5": "Red Devil",
          "1951-3": "St. Michael",
          "1952-1": "Scammon Bay",
          "1953-9": "Sheldon's Point",
          "1954-7": "Sleetmute",
          "1955-4": "Stebbins",
          "1956-2": "Togiak",
          "1957-0": "Toksook",
          "1958-8": "Tulukskak",
          "1959-6": "Tuntutuliak",
          "1960-4": "Tununak",
          "1961-2": "Twin Hills",
          "1962-0": "Georgetown (Yupik-Eskimo)",
          "1963-8": "St. Mary's",
          "1964-6": "Umkumiate",
          "1969-5": "Tatitlek",
          "1970-3": "Ugashik",
          "1973-7": "Chignik",
          "1974-5": "Chignik Lake",
          "1975-2": "Egegik",
          "1976-0": "Igiugig",
          "1977-8": "Ivanof Bay",
          "1978-6": "King Salmon",
          "1979-4": "Kokhanok",
          "1980-2": "Perryville",
          "1981-0": "Pilot Point",
          "1982-8": "Port Heiden",
          "1985-1": "Chenega",
          "1986-9": "Chugach Corporation",
          "1987-7": "English Bay",
          "1988-5": "Port Graham",
          "1993-5": "Akhiok",
          "1994-3": "Agdaagux",
          "1995-0": "Karluk",
          "1996-8": "Kodiak",
          "1997-6": "Larsen Bay",
          "1998-4": "Old Harbor",
          "1999-2": "Ouzinkie",
          "2000-8": "Port Lions",
          "2007-3": "Akutan",
          "2008-1": "Aleut Corporation",
          "2009-9": "Aleutian",
          "2010-7": "Aleutian Islander",
          "2011-5": "Atka",
          "2012-3": "Belkofski",
          "2013-1": "Chignik Lagoon",
          "2014-9": "King Cove",
          "2015-6": "False Pass",
          "2016-4": "Nelson Lagoon",
          "2017-2": "Nikolski",
          "2018-0": "Pauloff Harbor",
          "2019-8": "Qagan Toyagungin",
          "2020-6": "Qawalangin",
          "2021-4": "St. George",
          "2022-2": "St. Paul",
          "2023-0": "Sand Point",
          "2024-8": "South Naknek",
          "2025-5": "Unalaska",
          "2026-3": "Unga",
          "1814-3": "Angoon",
          "1815-0": "Central Council of Tlingit and Haida Tribes",
          "1816-8": "Chilkat",
          "1817-6": "Chilkoot",
          "1818-4": "Craig",
          "1819-2": "Douglas",
          "1820-0": "Haida",
          "1821-8": "Hoonah",
          "1822-6": "Hydaburg",
          "1823-4": "Kake",
          "1824-2": "Kasaan",
          "1825-9": "Kenaitze",
          "1826-7": "Ketchikan",
          "1827-5": "Klawock",
          "1828-3": "Pelican",
          "1829-1": "Petersburg",
          "1830-9": "Saxman",
          "1831-7": "Sitka",
          "1832-5": "Tenakee Springs",
          "1833-3": "Tlingit",
          "1834-1": "Wrangell",
          "1835-8": "Yakutat",
          "1838-2": "Metlakatla",
          "2135-2": "Hispanic or Latino",
          "2186-5": "Not Hispanic or Latino"
        }
      },
      "2.16.840.1.113883.3.26.1.1": {
        name: "Medication Route FDA",
        uri: "http://nci-thesaurus-look-me-up#",
        table: {
          "C38192": "AURICULAR (OTIC)",
          "C38193": "BUCCAL",
          "C38194": "CONJUNCTIVAL",
          "C38675": "CUTANEOUS",
          "C38197": "DENTAL",
          "C38633": "ELECTRO-OSMOSIS",
          "C38205": "ENDOCERVICAL",
          "C38206": "ENDOSINUSIAL",
          "C38208": "ENDOTRACHEAL",
          "C38209": "ENTERAL",
          "C38210": "EPIDURAL",
          "C38211": "EXTRA-AMNIOTIC",
          "C38212": "EXTRACORPOREAL",
          "C38200": "HEMODIALYSIS",
          "C38215": "INFILTRATION",
          "C38219": "INTERSTITIAL",
          "C38220": "INTRA-ABDOMINAL",
          "C38221": "INTRA-AMNIOTIC",
          "C38222": "INTRA-ARTERIAL",
          "C38223": "INTRA-ARTICULAR",
          "C38224": "INTRABILIARY",
          "C38225": "INTRABRONCHIAL",
          "C38226": "INTRABURSAL",
          "C38227": "INTRACARDIAC",
          "C38228": "INTRACARTILAGINOUS",
          "C38229": "INTRACAUDAL",
          "C38230": "INTRACAVERNOUS",
          "C38231": "INTRACAVITARY",
          "C38232": "INTRACEREBRAL",
          "C38233": "INTRACISTERNAL",
          "C38234": "INTRACORNEAL",
          "C38217": "INTRACORONAL, DENTAL",
          "C38218": "INTRACORONARY",
          "C38235": "INTRACORPORUS CAVERNOSUM",
          "C38238": "INTRADERMAL",
          "C38239": "INTRADISCAL",
          "C38240": "INTRADUCTAL",
          "C38241": "INTRADUODENAL",
          "C38242": "INTRADURAL",
          "C38243": "INTRAEPIDERMAL",
          "C38245": "INTRAESOPHAGEAL",
          "C38246": "INTRAGASTRIC",
          "C38247": "INTRAGINGIVAL",
          "C38249": "INTRAILEAL",
          "C38250": "INTRALESIONAL",
          "C38251": "INTRALUMINAL",
          "C38252": "INTRALYMPHATIC",
          "C38253": "INTRAMEDULLARY",
          "C38254": "INTRAMENINGEAL",
          "C28161": "INTRAMUSCULAR",
          "C38255": "INTRAOCULAR",
          "C38256": "INTRAOVARIAN",
          "C38257": "INTRAPERICARDIAL",
          "C38258": "INTRAPERITONEAL",
          "C38259": "INTRAPLEURAL",
          "C38260": "INTRAPROSTATIC",
          "C38261": "INTRAPULMONARY",
          "C38262": "INTRASINAL",
          "C38263": "INTRASPINAL",
          "C38264": "INTRASYNOVIAL",
          "C38265": "INTRATENDINOUS",
          "C38266": "INTRATESTICULAR",
          "C38267": "INTRATHECAL",
          "C38207": "INTRATHORACIC",
          "C38268": "INTRATUBULAR",
          "C38269": "INTRATUMOR",
          "C38270": "INTRATYMPANIC",
          "C38272": "INTRAUTERINE",
          "C38273": "INTRAVASCULAR",
          "C38276": "INTRAVENOUS",
          "C38277": "INTRAVENTRICULAR",
          "C38278": "INTRAVESICAL",
          "C38280": "INTRAVITREAL",
          "C38203": "IONTOPHORESIS",
          "C38281": "IRRIGATION",
          "C38282": "LARYNGEAL",
          "C38284": "NASAL",
          "C38285": "NASOGASTRIC",
          "C48623": "NOT APPLICABLE",
          "C38286": "OCCLUSIVE DRESSING TECHNIQUE",
          "C38287": "OPHTHALMIC",
          "C38288": "ORAL",
          "C38289": "OROPHARYNGEAL",
          "C38291": "PARENTERAL",
          "C38676": "PERCUTANEOUS",
          "C38292": "PERIARTICULAR",
          "C38677": "PERIDURAL",
          "C38293": "PERINEURAL",
          "C38294": "PERIODONTAL",
          "C38295": "RECTAL",
          "C38216": "RESPIRATORY (INHALATION)",
          "C38296": "RETROBULBAR",
          "C38198": "SOFT TISSUE",
          "C38297": "SUBARACHNOID",
          "C38298": "SUBCONJUNCTIVAL",
          "C38299": "SUBCUTANEOUS",
          "C38300": "SUBLINGUAL",
          "C38301": "SUBMUCOSAL",
          "C38304": "TOPICAL",
          "C38305": "TRANSDERMAL",
          "C38283": "TRANSMUCOSAL",
          "C38307": "TRANSPLACENTAL",
          "C38308": "TRANSTRACHEAL",
          "C38309": "TRANSTYMPANIC",
          "C38312": "URETERAL",
          "C38271": "URETHRAL"
        }
      },
      "2.16.840.1.113883.11.20.9.33": {
        name: "IND Roleclass Codes",
        uri: "",
        code_system: "2.16.840.1.113883.5.110",
        table: {
          "PRS": "Personal Relationship",
          "NOK": "Next of Kin",
          "CAREGIVER": "Caregiver",
          "AGNT": "Agent",
          "GUAR": "Guarantor",
          "ECON": "Emergency Contact"
        }
      },
      "2.16.840.1.113883.5.139": {
        name: "Domain TimingEvent",
        table: {
          //https://groups.google.com/forum/#!msg/ccda_samples/WawmwNMYT_8/pqnp5bG1IygJ
          "AC": "before meal",
          "ACD": "before lunch",
          "ACM": "before breakfast",
          "ACV": "before dinner",
          "C": "with meal",
          "CD": "with lunch",
          "CM": "with breakfast",
          "CV": "with dinner",
          "HS": "at bedtime",
          "IC": "between meals",
          "ICD": "between lunch and dinner",
          "ICM": "between breakfast and lunch",
          "ICV": "between dinner and bedtime",
          "PC": "after meal",
          "PCD": "after lunch",
          "PCM": "after breakfast",
          "PCV": "after dinner",
          "WAKE": "upon waking"
        }
      },
      "2.16.840.1.113883.6.14": {
        name: "HCPCS",
        uri: "http://www.cms.gov/Medicare/Coding/MedHCPCSGenInfo/index.html?redirect=/medhcpcsgeninfo/"
      },
      "2.16.840.1.113883.3.88.12.3221.8.9": {
        name: "Body Site Value Set"
      },
      "2.16.840.1.113883.5.7": {
        name: "ActPriority"
      },
      "2.16.840.1.113883.6.63": {
        name: "First DataBank Diagnostic Codes"
      },
      "2.16.840.1.113883.3.26.1.2": {
        name: "NCI Metathesaurus"
      }
    };

  }, {}], 55: [function (require, module, exports) {
    "use strict";

    exports.validator = require("./lib/validator.js");

    exports.schemas = require("./lib/schemas");

  }, { "./lib/schemas": 64, "./lib/validator.js": 76 }], 56: [function (require, module, exports) {
    module.exports = {
      "id": "allergy",
      "type": "object",
      "properties": {
        "date_time": {
          "$ref": "cda_date"
        },
        "identifiers": {
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "cda_id"
          }
        },
        "observation": {
          "type": "object",
          "properties": {
            "identifiers": {
              "type": "array",
              "minItems": 1,
              "items": {
                "$ref": "cda_id"
              }
            },

            "negation_indicator": {
              "type": "boolean"
            },

            "allergen": {
              "$ref": "cda_coded_entry"
            },
            "intolerance": {
              "$ref": "cda_coded_entry"
            },
            "date_time": {
              "$ref": "cda_date"
            },
            "status": {
              "$ref": "cda_coded_entry"
            },

            "reactions": {
              "type": "array",
              "minItems": 1,
              "items": {
                "type": "object",
                "properties": {
                  "identifiers": {
                    "type": "array",
                    "minItems": 1,
                    "items": {
                      "$ref": "cda_id"
                    }
                  },

                  "date_time": {
                    "$ref": "cda_date"
                  },
                  "reaction": {
                    "$ref": "cda_coded_entry"
                  },
                  "severity": {
                    "type": "object",
                    "properties": {
                      "code": {
                        "$ref": "cda_coded_entry"
                      },
                      "interpretation": {
                        "$ref": "cda_coded_entry"
                      }
                    },
                    "additionalProperties": false
                  }
                },
                "additionalProperties": false

              }
            },
            "severity": {
              "type": "object",
              "properties": {
                "code": {
                  "$ref": "cda_coded_entry"
                },
                "interpretation": {
                  "$ref": "cda_coded_entry"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    };

  }, {}], 57: [function (require, module, exports) {
    module.exports = {
      "id": "claim",
      "type": "object",
      "properties": {
        "number": {
          "type": "string"
        },
        "diagnosis": {
          "type": "array",
          "items": {
            "$ref": "cda_coded_entry"
          }
        },
        "name": {
          "type": "string"
        },
        "payer": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "date_time": {
          "$ref": "cda_date"
        },
        "service": {
          "type": "string"
        },
        "type": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "phone": {
          "type": "array",
          "items": {
            "$ref": "cda_phone"
          }
        },
        "performers": {
          "type": "array",
          "items": {
            "$ref": "cda_performer"
          }
        },
        "charges": {
          "type": "object",
          "properties": {
            "insurance_paid": {
              "type": "string"
            },
            "negotiated_price": {
              "type": "string"
            },
            "patient_responsibility": {
              "type": "string"
            },
            "price_billed": {
              "type": "string"
            },
            "provider_paid": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "lines": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "line": {
                "type": "string"
              },
              "charges": {
                "type": "object",
                "properties": {
                  "insurance_paid": {
                    "type": "string"
                  },
                  "negotiated_price": {
                    "type": "string"
                  },
                  "patient_responsibility": {
                    "type": "string"
                  },
                  "price_billed": {
                    "type": "string"
                  },
                  "provider_paid": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "drug": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string"
                  },
                  "description": {
                    "type": "string"
                  },
                  "name": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "modifier": {
                "type": "array",
                "items": {
                  "properties": {
                    "code": {
                      "type": "string"
                    },
                    "description": {
                      "type": "string"
                    },
                    "name": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "number": {
                "type": "string"
              },
              "place_of_service": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string"
                  },
                  "description": {
                    "type": "string"
                  },
                  "name": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "procedure": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string"
                  },
                  "description": {
                    "type": "string"
                  },
                  "name": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "quantity": {
                "type": "object",
                "properties": {
                  "value": {
                    "type": "number"
                  },
                  "unit": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "performers": {
                "type": "array",
                "items": {
                  "$ref": "cda_performer"
                }
              },
              "revenue": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string"
                  },
                  "description": {
                    "type": "string"
                  },
                  "name": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "date_time": {
                "$ref": "cda_date"
              },
              "type": {
                "type": "object",
                "properties": {
                  "code": {
                    "type": "string"
                  },
                  "description": {
                    "type": "string"
                  },
                  "name": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "type_of_service_code": {
                "type": "string"
              },
              "type_of_service": {
                "type": "number"
              }
            },
            "additionalProperties": false
          }
        }
      },
      "additionalProperties": false
    };

  }, {}], 58: [function (require, module, exports) {
    module.exports = [{
      "id": "cda_address",
      "type": "object",
      "properties": {
        "city": {
          "type": "string"
        },
        "country": {
          "type": "string"
        },
        "state": {
          "type": "string"
        },
        "street_lines": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "minItems": 1
        },
        "use": {
          "type": "string"
        },
        "zip": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "required": [
        "street_lines",
        "city"
      ]
    }, {
      "id": "cda_date_element",
      "type": "object",
      "properties": {
        "date": {
          "type": "string",
          "format": "date-time"
        },
        "precision": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "required": [
        "date"
      ]
    }, {
      "id": "cda_date",
      "type": "object",
      "properties": {
        "low": {
          "$ref": "cda_date_element"
        },
        "point": {
          "$ref": "cda_date_element"
        },
        "high": {
          "$ref": "cda_date_element"
        },
        "center": {
          "$ref": "cda_date_element"
        }
      },
      "additionalProperties": false,
      "minProperties": 1
    }, {
      "id": "cda_phone",
      "type": "object",
      "properties": {
        "number": {
          "type": "string"
        },
        "type": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "required": [
        "number"
      ]
    }, {
      "id": "cda_email",
      "type": "object",
      "properties": {
        "address": {
          "type": "string"
        },
        "type": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "required": [
        "address"
      ]
    }, {
      "id": "cda_id",
      "type": "object",
      "properties": {
        "extension": {
          "type": "string"
        },
        "identifier": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "required": [
        "identifier"
      ]
    }, {
      "id": "cda_name",
      "type": "object",
      "properties": {
        "prefix": {
          "type": "string"
        },
        "first": {
          "type": "string"
        },
        "last": {
          "type": "string"
        },
        "middle": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "suffix": {
          "type": "string"
        }
      },
      "additionalProperties": false
    }, {
      "id": "cda_coded_entry",
      "type": "object",
      "properties": {
        "code_system_name": {
          "type": "string"
        },
        "code": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "translations": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "code_system_name": {
                "type": "string"
              },
              "code": {
                "type": "string"
              },
              "name": {
                "type": "string"
              },
              "nullFlavor": {
                "type": "string"
              }
            },
            "additionalProperties": false,
            "minProperties": 1
          },
          "minItems": 1
        }
      },
      "minProperties": 1,
      "additionalProperties": false
    }, {
      "id": "cda_physical_quantity",
      "type": "object",
      "properties": {
        "unit": {
          "type": "string"
        },
        "value": {
          "type": "number"
        }
      },
      "additionalProperties": false,
      "required": [
        "unit",
        "value"
      ]
    }, {
      "id": "cda_location",
      "type": "object",
      "properties": {
        "address": {
          "type": "array",
          "items": {
            "$ref": "cda_address"
          },
          "minItems": 1
        },
        "location_type": {
          "$ref": "cda_coded_entry"
        },
        "name": {
          "type": "string"
        },
        "phone": {
          "type": "array",
          "items": {
            "$ref": "cda_phone"
          }
        }
      },
      "required": [
        "name"
      ],
      "additionalProperties": false
    }, {
      "id": "cda_organization",
      "type": "object",
      "properties": {
        "address": {
          "type": "array",
          "items": {
            "$ref": "cda_address"
          }
        },
        "identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"
          }
        },
        "name": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "phone": {
          "type": "array",
          "items": {
            "$ref": "cda_phone"
          }
        },
        "email": {
          "type": "array",
          "items": {
            "$ref": "cda_email"
          }
        }
      },
      "additionalProperties": false
    }, {
      "id": "cda_performer",
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "address": {
          "type": "array",
          "items": {
            "$ref": "cda_address"
          }
        },
        "identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"
          }
        },
        "name": {
          "type": "array",
          "items": {
            "anyOf": [{
              "$ref": "cda_name"
            }, {
              "type": "string"
            }]
          }
        },
        "organization": {
          "type": "array",
          "items": {
            "$ref": "cda_organization"
          }
        },
        "phone": {
          "type": "array",
          "items": {
            "$ref": "cda_phone"
          }
        },
        "email": {
          "type": "array",
          "items": {
            "$ref": "cda_email"
          }
        },
        "code": {
          "type": "array",
          "items": {
            "$ref": "cda_coded_entry"
          }
        } //,
        //"npi": {
        //    "type": "string"
        //}
      },
      "additionalProperties": false
    }];

  }, {}], 59: [function (require, module, exports) {
    module.exports = {
      "id": "demographics",
      "type": "object",
      "properties": {
        "name": {
          "$ref": "cda_name"
        },
        "dob": {
          "$ref": "cda_date"
        },
        "gender": {
          "type": "string"
        },
        "identifiers": {
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "cda_id"
          }
        },
        "marital_status": {
          "type": "string"
        },
        "addresses": {
          "type": "array",
          "items": {
            "$ref": "cda_address"
          },
          "minItems": 1
        },
        "phone": {
          "type": "array",
          "items": {
            "$ref": "cda_phone"
          }
        },
        "email": {
          "type": "array",
          "items": {
            "$ref": "cda_email"
          }
        },
        "race": {
          "type": "string"
        },
        "ethnicity": {
          "type": "string"
        },
        "religion": {
          "type": "string"
        },
        "birthplace": {
          "type": "object",
          "properties": {
            "city": {
              "type": "string"
            },
            "country": {
              "type": "string"
            },
            "state": {
              "type": "string"
            },
            "zip": {
              "type": "string"
            },
            "use": {
              "type": "string"
            }
          },
          "additionalProperties": false,
          "minProperties": 1,
          "required": [
            "city",
            "country"
          ]
        },
        "guardians": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "addresses": {
                "type": "array",
                "items": {
                  "$ref": "cda_address"
                }
              },
              "names": {
                "type": "array",
                "items": {
                  "$ref": "cda_name"
                }
              },
              "phone": {
                "type": "array",
                "items": {
                  "$ref": "cda_phone"
                }
              },
              "relation": {
                "type": "string"
              }
            },
            "required": [
              "names"
            ],
            "additionalProperties": false,
            "minProperties": 1
          },
          "minItems": 1
        },
        "languages": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "language": {
                "type": "string"
              },
              "mode": {
                "type": "string"
              },
              "preferred": {
                "type": "boolean"
              },
              "proficiency": {
                "type": "string"
              }
            },
            "additionalProperties": false,
            "required": [
              "language"
            ]
          },
          "minItems": 1
        }
      },
      "additionalProperties": false,
      "required": [
        "name"
      ]
    };

  }, {}], 60: [function (require, module, exports) {
    module.exports = {
      "id": "document_model",
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "properties": {
            "allergies": {
              "$ref": "allergies"
            },
            "demographics": {
              "$ref": "demographics"
            },
            "encounters": {
              "$ref": "encounters"
            },
            "immunizations": {
              "$ref": "immunizations"
            },
            "medications": {
              "$ref": "medications"
            },
            "problems": {
              "$ref": "problems"
            },
            "plan_of_care": {
              "$ref": "plan_of_care"
            },
            "procedures": {
              "$ref": "procedures"
            },
            "results": {
              "$ref": "results"
            },
            "social_history": {
              "$ref": "social_history"
            },
            "payers": {
              "$ref": "payers"
            },
            "vitals": {
              "$ref": "vitals"
            },
            "claims": {
              "$ref": "claims"
            },
            "providers": {
              "$ref": "providers"
            },
            "organizations": {
              "$ref": "organizations"
            },
            "medical_devices": {
              "$ref": "medical_devices"
            },
            "family_history": {
              "$ref": "family_history"
            }
          },
          "additionalProperties": true
        },
        "errors": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "meta": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string"
            },
            "version": {
              "type": "string"
            },
            "confidentiality": {
              "type": "string"
            },
            "patient_entered": {
              "type": "boolean"
            }
          },
          "additionalProperties": true
        }
      }
    };

  }, {}], 61: [function (require, module, exports) {
    module.exports = {
      "id": "encounter",
      "type": "object",
      "properties": {
        "date_time": {
          "$ref": "cda_date"
        },
        "encounter": {
          "$ref": "cda_coded_entry"
        },
        "findings": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "value": {
                "$ref": "cda_coded_entry"
              },
              "identifiers": {
                "type": "array",
                "items": {
                  "$ref": "cda_id"

                }
              },
              "date_time": {
                "$ref": "cda_date"
              }
            },
            "additionalProperties": false
          }
        },
        "identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"

          }
        },
        "performers": {
          "type": "array",
          "items": {
            "$ref": "cda_performer"
          }
        },
        "locations": {
          "type": "array",
          "items": {
            "$ref": "cda_location"
          }
        }
      },
      "additionalProperties": false,
      "required": ["encounter"]
    };

  }, {}], 62: [function (require, module, exports) {
    module.exports = {
      "id": "family_history_entry",
      "type": "object",
      "properties": {
        "identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"
          },
          "minItems": 1
        },
        "name": {
          "$ref": "cda_name"
        },
        "relationship": {
          "type": "string"
        },
        "dead": {
          "type": "boolean"
        },
        "conditions": {
          "type": "array",
          "items": {
            "$ref": "cda_coded_entry"
          },
          "minItems": 1
        },
        "dob": {
          "$ref": "cda_date"
        }
      },
      "additionalProperties": false,
      "required": ["name", "relationship"]
    };

  }, {}], 63: [function (require, module, exports) {
    module.exports = {
      "id": "immunization",
      "type": "object",
      "properties": {
        "date_time": {
          "$ref": "cda_date"
        },
        "identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"
          }
        },
        "status": {
          "type": "string"
        },
        "sequence_number": {
          "type": "string"
        },
        "administration": {
          "type": "object",
          "properties": {
            "dose": {
              "$ref": "cda_physical_quantity"
            },
            "route": {
              "$ref": "cda_coded_entry"
            },
            "body_site": {
              "$ref": "cda_coded_entry"
            },
            "form": {
              "$ref": "cda_coded_entry"
            }
          },
          "additionalProperties": false
        },
        "product": {
          "type": "object",
          "properties": {
            "lot_number": {
              "type": "string"
            },
            "manufacturer": {
              "type": "string"
            },
            "product": {
              "$ref": "cda_coded_entry"
            }
          },
          "required": [
            "product"
          ],
          "additionalProperties": false
        },
        "performer": {
          "$ref": "cda_performer"
        },
        "instructions": {
          "type": "object",
          "properties": {
            "free_text": {
              "type": "string"
            },
            "code": {
              "$ref": "cda_coded_entry"
            }
          },

          "additionalProperties": false
        },
        "refusal_reason": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "required": [
        "status",
        "product"
      ]
    };

  }, {}], 64: [function (require, module, exports) {
    "use strict";

    var _ = require('lodash');

    var common_models = require('./common_models');

    var demographics = require('./demographics');
    var allergy = require('./allergy');
    var encounter = require('./encounter');
    var immunization = require('./immunization');
    var medication = require('./medication');
    var problem = require('./problem');
    var procedure = require('./procedure');
    var plan_of_care_entry = require('./plan_of_care_entry');
    var payer = require('./payer');
    var result = require('./result');
    var social_history_entry = require('./social_history_entry');
    var vital = require('./vital');
    var claim = require('./claim');
    var provider = require('./provider');
    var organization = require('./organization');
    var medical_device = require('./medical_device');
    var family_history_entry = require('./family_history_entry');
    var document_model = require('./document_model');

    var list = exports.list = function (expandCommon) {
      var schemas = [];
      if (expandCommon) {
        Array.prototype.push.apply(schemas, common_models);
      } else {
        schemas.push(common_models);
      }

      schemas.push(demographics);
      schemas.push(allergy);
      schemas.push(encounter);
      schemas.push(immunization);
      schemas.push(medication);
      schemas.push(problem);
      schemas.push(procedure);
      schemas.push(plan_of_care_entry);
      schemas.push(payer);
      schemas.push(result);
      schemas.push(social_history_entry);
      schemas.push(vital);
      schemas.push(claim);
      schemas.push(provider);
      schemas.push(organization);
      schemas.push(medical_device);
      schemas.push(family_history_entry);

      var sections = {
        allergies: 'allergy',
        encounters: 'encounter',
        immunizations: 'immunization',
        medications: 'medication',
        problems: 'problem',
        procedures: 'procedure',
        plan_of_care: 'plan_of_care_entry',
        payers: 'payer',
        results: 'result',
        social_history: 'social_history_entry',
        vitals: 'vital',
        claims: 'claim',
        providers: 'provider',
        organizations: 'organization',
        medical_devices: 'medical_device',
        family_history: 'family_history_entry'
      };

      Object.keys(sections).forEach(function (sectionName) {
        var schema = {
          "id": sectionName,
          "type": "array",
          "items": {
            "$ref": sections[sectionName]
          }
        };
        schemas.push(schema);
      });

      schemas.push(document_model);

      return _.cloneDeep(schemas);
    };

    exports.map = function (expandCommon) {
      return list(expandCommon).reduce(function (r, schema) {
        if (schema.id) {
          r[schema.id] = schema;
        } else {
          r.common_models = schema;
        }
        return r;
      }, {});
    };

  }, { "./allergy": 56, "./claim": 57, "./common_models": 58, "./demographics": 59, "./document_model": 60, "./encounter": 61, "./family_history_entry": 62, "./immunization": 63, "./medical_device": 65, "./medication": 66, "./organization": 67, "./payer": 68, "./plan_of_care_entry": 69, "./problem": 70, "./procedure": 71, "./provider": 72, "./result": 73, "./social_history_entry": 74, "./vital": 75, "lodash": 77 }], 65: [function (require, module, exports) {
    module.exports = {
      "id": "medical_device",
      "type": "object",
      "properties": {
        "identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"
          },
          "minItems": 1 //in z-schema this essentially makes identifiers a required field
        },
        "product": {
          "$ref": "cda_coded_entry"
        },
        "status": {
          "type": "string"
        },
        "date_time": {
          "$ref": "cda_date"
        }
      },
      "additionalProperties": false,
      "required": ["product"]
    };

  }, {}], 66: [function (require, module, exports) {
    module.exports = {
      "id": "medication",
      "type": "object",
      "properties": {
        "date_time": {
          "$ref": "cda_date"
        },
        "identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"
          },
          "minItems": 1
        },
        "sig": {
          "type": "string"
        },
        "status": {
          "type": "string"
        },
        "is_brand": {
          "type": "boolean"
        },
        "administration": {
          "type": "object",
          "properties": {
            "dose": {
              "$ref": "cda_physical_quantity"
            },
            "form": {
              "$ref": "cda_coded_entry"
            },
            "rate": {
              "$ref": "cda_physical_quantity"
            },
            "route": {
              "$ref": "cda_coded_entry"
            },
            "dose_restriction": {
              "$ref": "cda_physical_quantity"
            },
            "site": {
              "$ref": "cda_coded_entry"
            },
            "interval": {
              "type": "object",
              "properties": {
                "xsiType": {
                  "type": "string"
                },
                "phase": {
                  "$ref": "cda_date"
                },
                "period": {
                  "$ref": "cda_physical_quantity"
                },
                "frequency": {
                  "type": "boolean"
                },
                "alignment": {
                  "type": "string"
                },
                "event": {
                  "type": "string"
                },
                "event_offset": {
                  "type": "object",
                  "properties": {
                    "low": {
                      "$ref": "cda_physical_quantity"
                    },
                    "high": {
                      "$ref": "cda_physical_quantity"
                    },
                    "center": {
                      "$ref": "cda_physical_quantity"
                    },
                    "width": {
                      "$ref": "cda_physical_quantity"
                    }

                  },
                  "additionalProperties": false

                }
              },
              "additionalProperties": false
            }

          },
          "additionalProperties": false,
          "minProperties": 1
        },

        "precondition": {
          "type": "object",
          "properties": {
            "code": {
              "$ref": "cda_coded_entry"
            },
            "value": {
              "$ref": "cda_coded_entry"
            }
          },
          "additionalProperties": false
        },
        "product": {
          "type": "object",
          "properties": {
            "identifiers": {
              "type": "array",
              "items": {
                "$ref": "cda_id"
              },
              "minItems": 1
            },
            "product": {
              "$ref": "cda_coded_entry"
            },
            "unencoded_name": {
              "type": "string"
            },
            "manufacturer": {
              "type": "string"
            }
          },
          "additionalProperties": false,
          "minProperties": 1,
          "required": [
            "product"
          ]
        },
        "supply": {
          "type": "object",
          "properties": {
            "date_time": {
              "$ref": "cda_date"
            },
            "repeatNumber": {
              "type": "string"
            },
            "quantity": {
              "type": "string"
            },
            "author": {
              "type": "object",
              "properties": {
                "identifiers": {
                  "type": "array",
                  "items": {
                    "$ref": "cda_id"
                  },
                  "minItems": 1
                },
                "date_time": {
                  "$ref": "cda_date"
                },
                "name": {
                  "$ref": "cda_name"
                },
                //"npi": {
                //    "type": "string"
                //},
                "organization": {
                  "$ref": "cda_organization"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        "indication": {
          "type": "object",
          "properties": {
            "identifiers": {
              "type": "array",
              "items": {
                "$ref": "cda_id"
              },
              "minItems": 1
            },
            "code": {
              "$ref": "cda_coded_entry"
            },
            "date_time": {
              "$ref": "cda_date"
            },
            "value": {
              "$ref": "cda_coded_entry"
            }
          },
          "additionalProperties": false
        },
        "performer": {
          "$ref": "cda_performer"
        },
        "drug_vehicle": {
          "$ref": "cda_coded_entry"
        },
        "dispense": {
          "type": "object",
          "properties": {
            "identifiers": {
              "type": "array",
              "items": {
                "$ref": "cda_id"
              },
              "minItems": 1
            },
            "performer": {
              "$ref": "cda_performer"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false,
      "minProperties": 1,
      "required": [
        "product",
        "status"
      ]
    };

  }, {}], 67: [function (require, module, exports) {
    module.exports = {
      "id": "organization",
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "addresses": {
          "type": "array",
          "items": {
            "$ref": "cda_address"
          }
        },
        "phone": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string"
              },
              "number": {
                "type": "string"
              }
            }
          }
        },
        "type": {
          "type": "object",
          "properties": {
            "coding": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "system": {
                    "type": "string"
                  },
                  "code": {
                    "type": "string"
                  },
                  "display": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "contact": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "purpose": {
                "type": "object",
                "properties": {
                  "coding": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "system": {
                          "type": "string"
                        },
                        "code": {
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              },
              "name": {
                "type": "string"
              },
              "phone": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string"
                    },
                    "number": {
                      "type": "string"
                    }
                  }
                }
              },
              "addresses": {
                "type": "array",
                "items": {
                  "$ref": "cda_address"
                },
              }
            }
          }
        },
        "identifiers": { //includes npi, replacement_npi
          "type": "array",
          "items": {
            "$ref": "cda_id"
          }
        },
        "part_of": {
          "type": "array",
          "items": {
            "$ref": "cda_organization"
          }
        },
        "active": {
          "type": "string"
        },
      }
    };

  }, {}], 68: [function (require, module, exports) {
    module.exports = {
      "id": "payer",
      "type": "object",
      "properties": {
        "identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"
          },
          "minItems": 1
        },
        "policy": {
          "type": "object",
          "properties": {
            "identifiers": {
              "type": "array",
              "items": {
                "$ref": "cda_id"
              },
              "minItems": 1
            },
            "code": {
              "$ref": "cda_coded_entry"
            },
            "insurance": {
              "type": "object",
              "properties": {
                "code": {
                  "$ref": "cda_coded_entry"
                },
                "performer": {
                  "$ref": "cda_performer"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        "guarantor": {
          "type": "object",
          "properties": {
            "code": {
              "$ref": "cda_coded_entry"
            },
            "identifiers": {
              "type": "array",
              "items": {
                "$ref": "cda_id"
              },
              "minItems": 1
            },
            "address": {
              "type": "array",
              "items": {
                "$ref": "cda_address"
              }
            },
            "phone": {
              "type": "array",
              "items": {
                "$ref": "cda_phone"
              }
            },
            "name": {
              "type": "array",
              "items": {
                "type": "object"
              }
            }
          },
          "additionalProperties": false
        },
        "participant": {
          "type": "object",
          "properties": {
            "date_time": {
              "$ref": "cda_date"
            },
            "code": {
              "$ref": "cda_coded_entry"
            },
            "performer": {
              "$ref": "cda_performer"
            },
            "name": {
              "type": "array",
              "items": {
                "type": "object"
              }
            }
          },
          "additionalProperties": false
        },
        "policy_holder": {
          "type": "object",
          "properties": {
            "performer": {
              "type": "object",
              "properties": {
                "identifiers": {
                  "type": "array",
                  "items": {
                    "$ref": "cda_id"
                  },
                  "minItems": 1
                },
                "address": {
                  "type": "array",
                  "items": {
                    "$ref": "cda_address"
                  }
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        "authorization": {
          "type": "object",
          "properties": {
            "identifiers": {
              "type": "array",
              "items": {
                "$ref": "cda_id"
              },
              "minItems": 1
            },
            "procedure": {
              "type": "object",
              "properties": {
                "code": {
                  "$ref": "cda_coded_entry"
                }
              },
              "additionalProperties": false
            }
          }
        }
      },
      "required": [
        "policy",
        "participant"
      ],
      "additionalProperties": false
    };

  }, {}], 69: [function (require, module, exports) {
    module.exports = {
      "id": "plan_of_care_entry",
      "type": "object",
      "properties": {
        "plan": {
          "$ref": "cda_coded_entry"
        },
        "type": {
          "type": "string"
        },
        "date_time": {
          "$ref": "cda_date"
        },
        "identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"
          },
          "minItems": 1
        },
        "status": {
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "additionalProperties": false
    };

  }, {}], 70: [function (require, module, exports) {
    module.exports = {
      "id": "problem",
      "type": "object",
      "properties": {
        "date_time": {
          "$ref": "cda_date"
        },
        "identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"
          }
        },
        "problem": {
          "type": "object",
          "properties": {
            "code": {
              "$ref": "cda_coded_entry"
            },
            "date_time": {
              "$ref": "cda_date"
            },
            "severity": {
              "type": "object",
              "properties": {
                "code": {
                  "$ref": "cda_coded_entry"
                },
                "interpretation": {
                  "$ref": "cda_coded_entry"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        "negation_indicator": {
          "type": "boolean"
        },
        "onset_age": {
          "type": "string"
        },
        "onset_age_unit": {
          "type": "string"
        },
        "patient_status": {
          "type": "string"
        },
        "status": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            },
            "date_time": {
              "$ref": "cda_date"
            }
          },
          "additionalProperties": false
        },
        "source_list_identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"
          }
        }
      },
      "additionalProperties": false,
      "required": ["problem"]
    };

  }, {}], 71: [function (require, module, exports) {
    module.exports = {
      "id": "procedure",
      "type": "object",
      "properties": {
        "procedure": {
          "$ref": "cda_coded_entry"
        },
        "procedure_type": {
          "type": "string"
        },
        "body_sites": {
          "type": "array",
          "items": {
            "$ref": "cda_coded_entry"
          },
          "minItems": 1
        },
        "specimen": {
          "type": "object",
          "properties": {
            "code": {
              "$ref": "cda_coded_entry"
            },
            "identifiers": {
              "type": "array",
              "items": {
                "$ref": "cda_id"
              }
            }
          },
          "additionalProperties": false
        },
        "priority": {
          "$ref": "cda_coded_entry"
        },
        "date_time": {
          "$ref": "cda_date"
        },
        "identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"
          },
          "minItems": 1
        },
        "status": {
          "type": "string"
        },
        "performers": {
          "type": "array",
          "items": {
            "$ref": "cda_performer"
          }
        },
        "locations": {
          "type": "array",
          "items": {
            "$ref": "cda_location"
          }
        }
      },
      "required": [
        "procedure"
      ],
      "additionalProperties": false
    };

  }, {}], 72: [function (require, module, exports) {
    module.exports = {
      "id": "provider",
      "type": "object",
      "properties": {
        "date_time": {
          "$ref": "cda_date"
        },
        "identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"
          }
        },
        "type": {
          "$ref": "cda_coded_entry"
        },
        "role": {
          "$ref": "cda_coded_entry"
        },
        "name": {
          "$ref": "cda_name"
        },
        "address": {
          "$ref": "cda_address"
        },
        "phone": {
          "type": "array",
          "items": {
            "$ref": "cda_phone"
          }
        },
        "email": {
          "type": "array",
          "items": {
            "$ref": "cda_phone"
          }
        },
        "organization": {
          "$ref": "cda_organization"
        }
      },
      "additionalProperties": false
    };

  }, {}], 73: [function (require, module, exports) {
    module.exports = {
      "id": "result",
      "type": "object",
      "properties": {
        "identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"
          },
          "minItems": 1
        },
        "result_set": {
          "$ref": "cda_coded_entry"
        },
        "results": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "object",
            "properties": {
              "date_time": {
                "$ref": "cda_date"
              },
              "identifiers": {
                "type": "array",
                "items": {
                  "$ref": "cda_id"
                }
              },
              "interpretations": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "result": {
                "$ref": "cda_coded_entry"
              },
              "status": {
                "type": "string"
              },
              "unit": {
                "type": "string"
              },
              "value": {
                "type": "number"
              },
              "text": {
                "type": "string"
              },
              "reference_range": {
                "type": "object",
                "properties": {
                  "text": {
                    "type": "string"
                  },
                  "low_value": {
                    "type": "number"
                  },
                  "low_unit": {
                    "type": "string"
                  },
                  "high_value": {
                    "type": "number"
                  },
                  "high_unit": {
                    "type": "string"
                  }
                }
              }
            },
            "required": [
              "result",
              "date_time",
              "status"
            ],
            "additionalProperties": false
          }

        }
      },
      "additionalProperties": false,
      "required": [
        "results"
      ]
    };

  }, {}], 74: [function (require, module, exports) {
    module.exports = {
      "id": "social_history_entry",
      "type": "object",
      "properties": {
        "date_time": {
          "$ref": "cda_date"
        },
        "value": {
          "type": "string"
        },
        "code": {
          "$ref": "cda_coded_entry"
        },
        "observation_value": {
          "type": "string"
        },
        "identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"
          }
        }
      },
      "required": [
        "value"
      ],
      "additionalProperties": false
    };

  }, {}], 75: [function (require, module, exports) {
    module.exports = {
      "id": "vital",
      "type": "object",
      "properties": {
        "identifiers": {
          "type": "array",
          "items": {
            "$ref": "cda_id"
          },
          "minItems": 1
        },
        "vital": {
          "$ref": "cda_coded_entry"
        },
        "status": {
          "type": "string"
        },
        "date_time": {
          "$ref": "cda_date"
        },
        "interpretations": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "value": {
          "type": "number"
        },
        "unit": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "required": ["vital"]
    };

  }, {}], 76: [function (require, module, exports) {
    "use strict";

    var ZSchema = require('z-schema');

    var schemas = require('./schemas');

    var Validator = function () {
      var zschema = new ZSchema({
        noExtraKeywords: true,
        noEmptyArrays: true,
        breakOnFirstError: false
      });

      var schemaList = schemas.list(true);
      var compiled = zschema.validateSchema(schemaList);
      if (compiled) {
        this.compiledSchemaMap = schemaList.reduce(function (r, schema) {
          r[schema.id] = schema;
          return r;
        }, {});
        this.zschema = zschema;
      } else {
        this.lastError = "Internal Error: Compilation of schemas failed.";
      }
    };

    Validator.prototype.getLastError = function () {
      return this.lastError;
    };

    Validator.prototype.validate = function (obj, schemaName) {
      var schema = this.compiledSchemaMap[schemaName];
      if (schema) {
        var valid = this.zschema.validate(obj, schema);
        this.lastError = this.zschema.getLastErrors();
        return valid;
      } else {
        return false;
      }
    };

    Validator.prototype.validateDocumentModel = function (document) {
      return this.validate(document, 'document_model');
    };

    module.exports = new Validator();

  }, { "./schemas": 64, "z-schema": 88 }], 77: [function (require, module, exports) {
    (function (global) {
      /**
       * @license
       * lodash 3.9.3 (Custom Build) <https://lodash.com/>
       * Build: `lodash modern -d -o ./index.js`
       * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
       * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
       * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
       * Available under MIT license <https://lodash.com/license>
       */
      ; (function () {

        /** Used as a safe reference for `undefined` in pre-ES5 environments. */
        var undefined;

        /** Used as the semantic version number. */
        var VERSION = '3.9.3';

        /** Used to compose bitmasks for wrapper metadata. */
        var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          ARY_FLAG = 128,
          REARG_FLAG = 256;

        /** Used as default options for `_.trunc`. */
        var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';

        /** Used to detect when a function becomes hot. */
        var HOT_COUNT = 150,
          HOT_SPAN = 16;

        /** Used to indicate the type of lazy iteratees. */
        var LAZY_DROP_WHILE_FLAG = 0,
          LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2;

        /** Used as the `TypeError` message for "Functions" methods. */
        var FUNC_ERROR_TEXT = 'Expected a function';

        /** Used as the internal argument placeholder. */
        var PLACEHOLDER = '__lodash_placeholder__';

        /** `Object#toString` result references. */
        var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';

        var arrayBufferTag = '[object ArrayBuffer]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';

        /** Used to match empty string literals in compiled template source. */
        var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

        /** Used to match HTML entities and HTML characters. */
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

        /** Used to match template delimiters. */
        var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;

        /** Used to match property names within property paths. */
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

        /**
         * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).
         * In addition to special characters the forward slash is escaped to allow for
         * easier `eval` use and `Function` compilation.
         */
        var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
          reHasRegExpChars = RegExp(reRegExpChars.source);

        /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
        var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

        /** Used to match backslashes in property paths. */
        var reEscapeChar = /\\(\\)?/g;

        /** Used to match [ES template delimiters](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literal-lexical-components). */
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

        /** Used to match `RegExp` flags from their coerced string values. */
        var reFlags = /\w*$/;

        /** Used to detect hexadecimal string values. */
        var reHasHexPrefix = /^0[xX]/;

        /** Used to detect host constructors (Safari > 5). */
        var reIsHostCtor = /^\[object .+?Constructor\]$/;

        /** Used to detect unsigned integer values. */
        var reIsUint = /^\d+$/;

        /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
        var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

        /** Used to ensure capturing order of template delimiters. */
        var reNoMatch = /($^)/;

        /** Used to match unescaped characters in compiled string literals. */
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

        /** Used to match words to create compound words. */
        var reWords = (function () {
          var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
            lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

          return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
        }());

        /** Used to detect and test for whitespace. */
        var whitespace = (
          // Basic whitespace characters.
          ' \t\x0b\f\xa0\ufeff' +

          // Line terminators.
          '\n\r\u2028\u2029' +

          // Unicode category "Zs" space separators.
          '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
        );

        /** Used to assign default `context` object properties. */
        var contextProps = [
          'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
          'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
          'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document',
          'isFinite', 'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
          'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', 'window'
        ];

        /** Used to make template sourceURLs easier to identify. */
        var templateCounter = -1;

        /** Used to identify `toStringTag` values of typed arrays. */
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
          typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
          typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
          typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
          typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
          typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
          typedArrayTags[dateTag] = typedArrayTags[errorTag] =
          typedArrayTags[funcTag] = typedArrayTags[mapTag] =
          typedArrayTags[numberTag] = typedArrayTags[objectTag] =
          typedArrayTags[regexpTag] = typedArrayTags[setTag] =
          typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

        /** Used to identify `toStringTag` values supported by `_.clone`. */
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] =
          cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
          cloneableTags[dateTag] = cloneableTags[float32Tag] =
          cloneableTags[float64Tag] = cloneableTags[int8Tag] =
          cloneableTags[int16Tag] = cloneableTags[int32Tag] =
          cloneableTags[numberTag] = cloneableTags[objectTag] =
          cloneableTags[regexpTag] = cloneableTags[stringTag] =
          cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
          cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] =
          cloneableTags[mapTag] = cloneableTags[setTag] =
          cloneableTags[weakMapTag] = false;

        /** Used as an internal `_.debounce` options object by `_.throttle`. */
        var debounceOptions = {
          'leading': false,
          'maxWait': 0,
          'trailing': false
        };

        /** Used to map latin-1 supplementary letters to basic latin letters. */
        var deburredLetters = {
          '\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
          '\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
          '\xc7': 'C', '\xe7': 'c',
          '\xd0': 'D', '\xf0': 'd',
          '\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
          '\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
          '\xcC': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
          '\xeC': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
          '\xd1': 'N', '\xf1': 'n',
          '\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
          '\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
          '\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
          '\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
          '\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
          '\xc6': 'Ae', '\xe6': 'ae',
          '\xde': 'Th', '\xfe': 'th',
          '\xdf': 'ss'
        };

        /** Used to map characters to HTML entities. */
        var htmlEscapes = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;',
          '`': '&#96;'
        };

        /** Used to map HTML entities to characters. */
        var htmlUnescapes = {
          '&amp;': '&',
          '&lt;': '<',
          '&gt;': '>',
          '&quot;': '"',
          '&#39;': "'",
          '&#96;': '`'
        };

        /** Used to determine if values are of the language type `Object`. */
        var objectTypes = {
          'function': true,
          'object': true
        };

        /** Used to escape characters for inclusion in compiled string literals. */
        var stringEscapes = {
          '\\': '\\',
          "'": "'",
          '\n': 'n',
          '\r': 'r',
          '\u2028': 'u2028',
          '\u2029': 'u2029'
        };

        /** Detect free variable `exports`. */
        var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

        /** Detect free variable `module`. */
        var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

        /** Detect free variable `global` from Node.js. */
        var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

        /** Detect free variable `self`. */
        var freeSelf = objectTypes[typeof self] && self && self.Object && self;

        /** Detect free variable `window`. */
        var freeWindow = objectTypes[typeof window] && window && window.Object && window;

        /** Detect the popular CommonJS extension `module.exports`. */
        var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

        /**
         * Used as a reference to the global object.
         *
         * The `this` value is used if it's the global object to avoid Greasemonkey's
         * restricted `window` object, otherwise the `window` object is used.
         */
        var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

        /*--------------------------------------------------------------------------*/

        /**
         * The base implementation of `compareAscending` which compares values and
         * sorts them in ascending order without guaranteeing a stable sort.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {number} Returns the sort order indicator for `value`.
         */
        function baseCompareAscending(value, other) {
          if (value !== other) {
            var valIsNull = value === null,
              valIsUndef = value === undefined,
              valIsReflexive = value === value;

            var othIsNull = other === null,
              othIsUndef = other === undefined,
              othIsReflexive = other === other;

            if ((value > other && !othIsNull) || !valIsReflexive ||
              (valIsNull && !othIsUndef && othIsReflexive) ||
              (valIsUndef && othIsReflexive)) {
              return 1;
            }
            if ((value < other && !valIsNull) || !othIsReflexive ||
              (othIsNull && !valIsUndef && valIsReflexive) ||
              (othIsUndef && valIsReflexive)) {
              return -1;
            }
          }
          return 0;
        }

        /**
         * The base implementation of `_.findIndex` and `_.findLastIndex` without
         * support for callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {Function} predicate The function invoked per iteration.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function baseFindIndex(array, predicate, fromRight) {
          var length = array.length,
            index = fromRight ? length : -1;

          while ((fromRight ? index-- : ++index < length)) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * The base implementation of `_.indexOf` without support for binary searches.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function baseIndexOf(array, value, fromIndex) {
          if (value !== value) {
            return indexOfNaN(array, fromIndex);
          }
          var index = fromIndex - 1,
            length = array.length;

          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }

        /**
         * The base implementation of `_.isFunction` without support for environments
         * with incorrect `typeof` results.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         */
        function baseIsFunction(value) {
          // Avoid a Chakra JIT bug in compatibility modes of IE 11.
          // See https://github.com/jashkenas/underscore/issues/1621 for more details.
          return typeof value == 'function' || false;
        }

        /**
         * Converts `value` to a string if it's not one. An empty string is returned
         * for `null` or `undefined` values.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString(value) {
          if (typeof value == 'string') {
            return value;
          }
          return value == null ? '' : (value + '');
        }

        /**
         * Used by `_.trim` and `_.trimLeft` to get the index of the first character
         * of `string` that is not found in `chars`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @param {string} chars The characters to find.
         * @returns {number} Returns the index of the first character not found in `chars`.
         */
        function charsLeftIndex(string, chars) {
          var index = -1,
            length = string.length;

          while (++index < length && chars.indexOf(string.charAt(index)) > -1) { }
          return index;
        }

        /**
         * Used by `_.trim` and `_.trimRight` to get the index of the last character
         * of `string` that is not found in `chars`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @param {string} chars The characters to find.
         * @returns {number} Returns the index of the last character not found in `chars`.
         */
        function charsRightIndex(string, chars) {
          var index = string.length;

          while (index-- && chars.indexOf(string.charAt(index)) > -1) { }
          return index;
        }

        /**
         * Used by `_.sortBy` to compare transformed elements of a collection and stable
         * sort them in ascending order.
         *
         * @private
         * @param {Object} object The object to compare to `other`.
         * @param {Object} other The object to compare to `object`.
         * @returns {number} Returns the sort order indicator for `object`.
         */
        function compareAscending(object, other) {
          return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
        }

        /**
         * Used by `_.sortByOrder` to compare multiple properties of each element
         * in a collection and stable sort them in the following order:
         *
         * If `orders` is unspecified, sort in ascending order for all properties.
         * Otherwise, for each property, sort in ascending order if its corresponding value in
         * orders is true, and descending order if false.
         *
         * @private
         * @param {Object} object The object to compare to `other`.
         * @param {Object} other The object to compare to `object`.
         * @param {boolean[]} orders The order to sort by for each property.
         * @returns {number} Returns the sort order indicator for `object`.
         */
        function compareMultiple(object, other, orders) {
          var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;

          while (++index < length) {
            var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
            if (result) {
              if (index >= ordersLength) {
                return result;
              }
              return result * (orders[index] ? 1 : -1);
            }
          }
          // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
          // that causes it, under certain circumstances, to provide the same value for
          // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
          // for more details.
          //
          // This also ensures a stable sort in V8 and other engines.
          // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
          return object.index - other.index;
        }

        /**
         * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
         *
         * @private
         * @param {string} letter The matched letter to deburr.
         * @returns {string} Returns the deburred letter.
         */
        function deburrLetter(letter) {
          return deburredLetters[letter];
        }

        /**
         * Used by `_.escape` to convert characters to HTML entities.
         *
         * @private
         * @param {string} chr The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
        function escapeHtmlChar(chr) {
          return htmlEscapes[chr];
        }

        /**
         * Used by `_.template` to escape characters for inclusion in compiled
         * string literals.
         *
         * @private
         * @param {string} chr The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
        function escapeStringChar(chr) {
          return '\\' + stringEscapes[chr];
        }

        /**
         * Gets the index at which the first occurrence of `NaN` is found in `array`.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {number} fromIndex The index to search from.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {number} Returns the index of the matched `NaN`, else `-1`.
         */
        function indexOfNaN(array, fromIndex, fromRight) {
          var length = array.length,
            index = fromIndex + (fromRight ? 0 : -1);

          while ((fromRight ? index-- : ++index < length)) {
            var other = array[index];
            if (other !== other) {
              return index;
            }
          }
          return -1;
        }

        /**
         * Checks if `value` is object-like.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         */
        function isObjectLike(value) {
          return !!value && typeof value == 'object';
        }

        /**
         * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
         * character code is whitespace.
         *
         * @private
         * @param {number} charCode The character code to inspect.
         * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
         */
        function isSpace(charCode) {
          return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
            (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
        }

        /**
         * Replaces all `placeholder` elements in `array` with an internal placeholder
         * and returns an array of their indexes.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {*} placeholder The placeholder to replace.
         * @returns {Array} Returns the new array of placeholder indexes.
         */
        function replaceHolders(array, placeholder) {
          var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];

          while (++index < length) {
            if (array[index] === placeholder) {
              array[index] = PLACEHOLDER;
              result[++resIndex] = index;
            }
          }
          return result;
        }

        /**
         * An implementation of `_.uniq` optimized for sorted arrays without support
         * for callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The function invoked per iteration.
         * @returns {Array} Returns the new duplicate-value-free array.
         */
        function sortedUniq(array, iteratee) {
          var seen,
            index = -1,
            length = array.length,
            resIndex = -1,
            result = [];

          while (++index < length) {
            var value = array[index],
              computed = iteratee ? iteratee(value, index, array) : value;

            if (!index || seen !== computed) {
              seen = computed;
              result[++resIndex] = value;
            }
          }
          return result;
        }

        /**
         * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
         * character of `string`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {number} Returns the index of the first non-whitespace character.
         */
        function trimmedLeftIndex(string) {
          var index = -1,
            length = string.length;

          while (++index < length && isSpace(string.charCodeAt(index))) { }
          return index;
        }

        /**
         * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
         * character of `string`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {number} Returns the index of the last non-whitespace character.
         */
        function trimmedRightIndex(string) {
          var index = string.length;

          while (index-- && isSpace(string.charCodeAt(index))) { }
          return index;
        }

        /**
         * Used by `_.unescape` to convert HTML entities to characters.
         *
         * @private
         * @param {string} chr The matched character to unescape.
         * @returns {string} Returns the unescaped character.
         */
        function unescapeHtmlChar(chr) {
          return htmlUnescapes[chr];
        }

        /*--------------------------------------------------------------------------*/

        /**
         * Create a new pristine `lodash` function using the given `context` object.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Object} [context=root] The context object.
         * @returns {Function} Returns a new `lodash` function.
         * @example
         *
         * _.mixin({ 'foo': _.constant('foo') });
         *
         * var lodash = _.runInContext();
         * lodash.mixin({ 'bar': lodash.constant('bar') });
         *
         * _.isFunction(_.foo);
         * // => true
         * _.isFunction(_.bar);
         * // => false
         *
         * lodash.isFunction(lodash.foo);
         * // => false
         * lodash.isFunction(lodash.bar);
         * // => true
         *
         * // using `context` to mock `Date#getTime` use in `_.now`
         * var mock = _.runInContext({
         *   'Date': function() {
         *     return { 'getTime': getTimeMock };
         *   }
         * });
         *
         * // or creating a suped-up `defer` in Node.js
         * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
         */
        function runInContext(context) {
          // Avoid issues with some ES3 environments that attempt to use values, named
          // after built-in constructors like `Object`, for the creation of literals.
          // ES5 clears this up by stating that literals must use built-in constructors.
          // See https://es5.github.io/#x11.1.5 for more details.
          context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

          /** Native constructor references. */
          var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function.toBeInstanceOf(Function),
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;

          /** Used for native method references. */
          var arrayProto = Array.prototype,
            objectProto = Object.prototype,
            stringProto = String.prototype;

          /** Used to detect DOM support. */
          var document = (document = context.window) ? document.document : null;

          /** Used to resolve the decompiled source of functions. */
          var fnToString = Function.prototype.toString;

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty;

          /** Used to generate unique IDs. */
          var idCounter = 0;

          /**
           * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
           * of values.
           */
          var objToString = objectProto.toString;

          /** Used to restore the original `_` reference in `_.noConflict`. */
          var oldDash = context._;

          /** Used to detect if a method is native. */
          var reIsNative = RegExp('^' +
            escapeRegExp(fnToString.call(hasOwnProperty))
              .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
          );

          /** Native method references. */
          var ArrayBuffer = getNative(context, 'ArrayBuffer'),
            bufferSlice = getNative(ArrayBuffer && new ArrayBuffer(0), 'slice'),
            ceil = Math.ceil,
            clearTimeout = context.clearTimeout,
            floor = Math.floor,
            getPrototypeOf = getNative(Object, 'getPrototypeOf'),
            parseFloat = context.parseFloat,
            push = arrayProto.push,
            Set = getNative(context, 'Set'),
            setTimeout = context.setTimeout,
            splice = arrayProto.splice,
            Uint8Array = getNative(context, 'Uint8Array'),
            WeakMap = getNative(context, 'WeakMap');

          /** Used to clone array buffers. */
          var Float64Array = (function () {
            // Safari 5 errors when using an array buffer to initialize a typed array
            // where the array buffer's `byteLength` is not a multiple of the typed
            // array's `BYTES_PER_ELEMENT`.
            try {
              var func = getNative(context, 'Float64Array'),
                result = new func(new ArrayBuffer(10), 0, 1) && func;
            } catch (e) { }
            return result || null;
          }());

          /* Native method references for those with the same name as other `lodash` methods. */
          var nativeCreate = getNative(Object, 'create'),
            nativeIsArray = getNative(Array, 'isArray'),
            nativeIsFinite = context.isFinite,
            nativeKeys = getNative(Object, 'keys'),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = getNative(Date, 'now'),
            nativeNumIsFinite = getNative(Number, 'isFinite'),
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;

          /** Used as references for `-Infinity` and `Infinity`. */
          var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
            POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

          /** Used as references for the maximum length and index of an array. */
          var MAX_ARRAY_LENGTH = 4294967295,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

          /** Used as the size, in bytes, of each `Float64Array` element. */
          var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

          /**
           * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
           * of an array-like value.
           */
          var MAX_SAFE_INTEGER = 9007199254740991;

          /** Used to store function metadata. */
          var metaMap = WeakMap && new WeakMap;

          /** Used to lookup unminified function names. */
          var realNames = {};

          /*------------------------------------------------------------------------*/

          /**
           * Creates a `lodash` object which wraps `value` to enable implicit chaining.
           * Methods that operate on and return arrays, collections, and functions can
           * be chained together. Methods that return a boolean or single value will
           * automatically end the chain returning the unwrapped value. Explicit chaining
           * may be enabled using `_.chain`. The execution of chained methods is lazy,
           * that is, execution is deferred until `_#value` is implicitly or explicitly
           * called.
           *
           * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
           * fusion is an optimization that merges iteratees to avoid creating intermediate
           * arrays and reduce the number of iteratee executions.
           *
           * Chaining is supported in custom builds as long as the `_#value` method is
           * directly or indirectly included in the build.
           *
           * In addition to lodash methods, wrappers have `Array` and `String` methods.
           *
           * The wrapper `Array` methods are:
           * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
           * `splice`, and `unshift`
           *
           * The wrapper `String` methods are:
           * `replace` and `split`
           *
           * The wrapper methods that support shortcut fusion are:
           * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
           * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
           * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
           * and `where`
           *
           * The chainable wrapper methods are:
           * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
           * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
           * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`,
           * `difference`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `fill`,
           * `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`, `forEach`,
           * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,
           * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,
           * `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
           * `memoize`, `merge`, `method`, `methodOf`, `mixin`, `negate`, `omit`, `once`,
           * `pairs`, `partial`, `partialRight`, `partition`, `pick`, `plant`, `pluck`,
           * `property`, `propertyOf`, `pull`, `pullAt`, `push`, `range`, `rearg`,
           * `reject`, `remove`, `rest`, `restParam`, `reverse`, `set`, `shuffle`,
           * `slice`, `sort`, `sortBy`, `sortByAll`, `sortByOrder`, `splice`, `spread`,
           * `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`, `throttle`,
           * `thru`, `times`, `toArray`, `toPlainObject`, `transform`, `union`, `uniq`,
           * `unshift`, `unzip`, `unzipWith`, `values`, `valuesIn`, `where`, `without`,
           * `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
           *
           * The wrapper methods that are **not** chainable by default are:
           * `add`, `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,
           * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,
           * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `get`,
           * `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`, `inRange`, `isArguments`,
           * `isArray`, `isBoolean`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`,
           * `isFinite` `isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`,
           * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`,
           * `isTypedArray`, `join`, `kebabCase`, `last`, `lastIndexOf`, `lt`, `lte`,
           * `max`, `min`, `noConflict`, `noop`, `now`, `pad`, `padLeft`, `padRight`,
           * `parseInt`, `pop`, `random`, `reduce`, `reduceRight`, `repeat`, `result`,
           * `runInContext`, `shift`, `size`, `snakeCase`, `some`, `sortedIndex`,
           * `sortedLastIndex`, `startCase`, `startsWith`, `sum`, `template`, `trim`,
           * `trimLeft`, `trimRight`, `trunc`, `unescape`, `uniqueId`, `value`, and `words`
           *
           * The wrapper method `sample` will return a wrapped value when `n` is provided,
           * otherwise an unwrapped value is returned.
           *
           * @name _
           * @constructor
           * @category Chain
           * @param {*} value The value to wrap in a `lodash` instance.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var wrapped = _([1, 2, 3]);
           *
           * // returns an unwrapped value
           * wrapped.reduce(function(total, n) {
           *   return total + n;
           * });
           * // => 6
           *
           * // returns a wrapped value
           * var squares = wrapped.map(function(n) {
           *   return n * n;
           * });
           *
           * _.isArray(squares);
           * // => false
           *
           * _.isArray(squares.value());
           * // => true
           */
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }

          /**
           * The function whose prototype all chaining wrappers inherit from.
           *
           * @private
           */
          function baseLodash() {
            // No operation performed.
          }

          /**
           * The base constructor for creating `lodash` wrapper objects.
           *
           * @private
           * @param {*} value The value to wrap.
           * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
           * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
           */
          function LodashWrapper(value, chainAll, actions) {
            this.__wrapped__ = value;
            this.__actions__ = actions || [];
            this.__chain__ = !!chainAll;
          }

          /**
           * An object environment feature flags.
           *
           * @static
           * @memberOf _
           * @type Object
           */
          var support = lodash.support = {};

          (function (x) {
            var Ctor = function () { this.x = x; },
              object = { '0': x, 'length': x },
              props = [];

            Ctor.prototype = { 'valueOf': x, 'y': x };
            for (var key in new Ctor) { props.push(key); }

            /**
             * Detect if the DOM is supported.
             *
             * @memberOf _.support
             * @type boolean
             */
            try {
              support.dom = document.createDocumentFragment().nodeType === 11;
            } catch (e) {
              support.dom = false;
            }
          }(1, 0));

          /**
           * By default, the template delimiters used by lodash are like those in
           * embedded Ruby (ERB). Change the following template settings to use
           * alternative delimiters.
           *
           * @static
           * @memberOf _
           * @type Object
           */
          lodash.templateSettings = {

            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type RegExp
             */
            'escape': reEscape,

            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type RegExp
             */
            'evaluate': reEvaluate,

            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type RegExp
             */
            'interpolate': reInterpolate,

            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type string
             */
            'variable': '',

            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type Object
             */
            'imports': {

              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type Function
               */
              '_': lodash
            }
          };

          /*------------------------------------------------------------------------*/

          /**
           * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
           *
           * @private
           * @param {*} value The value to wrap.
           */
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = null;
            this.__dir__ = 1;
            this.__dropCount__ = 0;
            this.__filtered__ = false;
            this.__iteratees__ = null;
            this.__takeCount__ = POSITIVE_INFINITY;
            this.__views__ = null;
          }

          /**
           * Creates a clone of the lazy wrapper object.
           *
           * @private
           * @name clone
           * @memberOf LazyWrapper
           * @returns {Object} Returns the cloned `LazyWrapper` object.
           */
          function lazyClone() {
            var actions = this.__actions__,
              iteratees = this.__iteratees__,
              views = this.__views__,
              result = new LazyWrapper(this.__wrapped__);

            result.__actions__ = actions ? arrayCopy(actions) : null;
            result.__dir__ = this.__dir__;
            result.__filtered__ = this.__filtered__;
            result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
            result.__takeCount__ = this.__takeCount__;
            result.__views__ = views ? arrayCopy(views) : null;
            return result;
          }

          /**
           * Reverses the direction of lazy iteration.
           *
           * @private
           * @name reverse
           * @memberOf LazyWrapper
           * @returns {Object} Returns the new reversed `LazyWrapper` object.
           */
          function lazyReverse() {
            if (this.__filtered__) {
              var result = new LazyWrapper(this);
              result.__dir__ = -1;
              result.__filtered__ = true;
            } else {
              result = this.clone();
              result.__dir__ *= -1;
            }
            return result;
          }

          /**
           * Extracts the unwrapped value from its lazy wrapper.
           *
           * @private
           * @name value
           * @memberOf LazyWrapper
           * @returns {*} Returns the unwrapped value.
           */
          function lazyValue() {
            var array = this.__wrapped__.value();
            if (!isArray(array)) {
              return baseWrapperValue(array, this.__actions__);
            }
            var dir = this.__dir__,
              isRight = dir < 0,
              view = getView(0, array.length, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              takeCount = nativeMin(length, this.__takeCount__),
              iteratees = this.__iteratees__,
              iterLength = iteratees ? iteratees.length : 0,
              resIndex = 0,
              result = [];

            outer:
            while (length-- && resIndex < takeCount) {
              index += dir;

              var iterIndex = -1,
                value = array[index];

              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type;

                if (type == LAZY_DROP_WHILE_FLAG) {
                  if (data.done && (isRight ? (index > data.index) : (index < data.index))) {
                    data.count = 0;
                    data.done = false;
                  }
                  data.index = index;
                  if (!data.done) {
                    var limit = data.limit;
                    if (!(data.done = limit > -1 ? (data.count++ >= limit) : !iteratee(value))) {
                      continue outer;
                    }
                  }
                } else {
                  var computed = iteratee(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
              }
              result[resIndex++] = value;
            }
            return result;
          }

          /*------------------------------------------------------------------------*/

          /**
           * Creates a cache object to store key/value pairs.
           *
           * @private
           * @static
           * @name Cache
           * @memberOf _.memoize
           */
          function MapCache() {
            this.__data__ = {};
          }

          /**
           * Removes `key` and its value from the cache.
           *
           * @private
           * @name delete
           * @memberOf _.memoize.Cache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
           */
          function mapDelete(key) {
            return this.has(key) && delete this.__data__[key];
          }

          /**
           * Gets the cached value for `key`.
           *
           * @private
           * @name get
           * @memberOf _.memoize.Cache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the cached value.
           */
          function mapGet(key) {
            return key == '__proto__' ? undefined : this.__data__[key];
          }

          /**
           * Checks if a cached value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf _.memoize.Cache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function mapHas(key) {
            return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
          }

          /**
           * Sets `value` to `key` of the cache.
           *
           * @private
           * @name set
           * @memberOf _.memoize.Cache
           * @param {string} key The key of the value to cache.
           * @param {*} value The value to cache.
           * @returns {Object} Returns the cache object.
           */
          function mapSet(key, value) {
            if (key != '__proto__') {
              this.__data__[key] = value;
            }
            return this;
          }

          /*------------------------------------------------------------------------*/

          /**
           *
           * Creates a cache object to store unique values.
           *
           * @private
           * @param {Array} [values] The values to cache.
           */
          function SetCache(values) {
            var length = values ? values.length : 0;

            this.data = { 'hash': nativeCreate(null), 'set': new Set };
            while (length--) {
              this.push(values[length]);
            }
          }

          /**
           * Checks if `value` is in `cache` mimicking the return signature of
           * `_.indexOf` by returning `0` if the value is found, else `-1`.
           *
           * @private
           * @param {Object} cache The cache to search.
           * @param {*} value The value to search for.
           * @returns {number} Returns `0` if `value` is found, else `-1`.
           */
          function cacheIndexOf(cache, value) {
            var data = cache.data,
              result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

            return result ? 0 : -1;
          }

          /**
           * Adds `value` to the cache.
           *
           * @private
           * @name push
           * @memberOf SetCache
           * @param {*} value The value to cache.
           */
          function cachePush(value) {
            var data = this.data;
            if (typeof value == 'string' || isObject(value)) {
              data.set.add(value);
            } else {
              data.hash[value] = true;
            }
          }

          /*------------------------------------------------------------------------*/

          /**
           * Copies the values of `source` to `array`.
           *
           * @private
           * @param {Array} source The array to copy values from.
           * @param {Array} [array=[]] The array to copy values to.
           * @returns {Array} Returns `array`.
           */
          function arrayCopy(source, array) {
            var index = -1,
              length = source.length;

            array || (array = Array(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }

          /**
           * A specialized version of `_.forEach` for arrays without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns `array`.
           */
          function arrayEach(array, iteratee) {
            var index = -1,
              length = array.length;

            while (++index < length) {
              if (iteratee(array[index], index, array) === false) {
                break;
              }
            }
            return array;
          }

          /**
           * A specialized version of `_.forEachRight` for arrays without support for
           * callback shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns `array`.
           */
          function arrayEachRight(array, iteratee) {
            var length = array.length;

            while (length--) {
              if (iteratee(array[length], length, array) === false) {
                break;
              }
            }
            return array;
          }

          /**
           * A specialized version of `_.every` for arrays without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if all elements pass the predicate check,
           *  else `false`.
           */
          function arrayEvery(array, predicate) {
            var index = -1,
              length = array.length;

            while (++index < length) {
              if (!predicate(array[index], index, array)) {
                return false;
              }
            }
            return true;
          }

          /**
           * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
           * with one argument: (value).
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} comparator The function used to compare values.
           * @param {*} exValue The initial extremum value.
           * @returns {*} Returns the extremum value.
           */
          function arrayExtremum(array, iteratee, comparator, exValue) {
            var index = -1,
              length = array.length,
              computed = exValue,
              result = computed;

            while (++index < length) {
              var value = array[index],
                current = +iteratee(value);

              if (comparator(current, computed)) {
                computed = current;
                result = value;
              }
            }
            return result;
          }

          /**
           * A specialized version of `_.filter` for arrays without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           */
          function arrayFilter(array, predicate) {
            var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];

            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result[++resIndex] = value;
              }
            }
            return result;
          }

          /**
           * A specialized version of `_.map` for arrays without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns the new mapped array.
           */
          function arrayMap(array, iteratee) {
            var index = -1,
              length = array.length,
              result = Array(length);

            while (++index < length) {
              result[index] = iteratee(array[index], index, array);
            }
            return result;
          }

          /**
           * A specialized version of `_.reduce` for arrays without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @param {boolean} [initFromArray] Specify using the first element of `array`
           *  as the initial value.
           * @returns {*} Returns the accumulated value.
           */
          function arrayReduce(array, iteratee, accumulator, initFromArray) {
            var index = -1,
              length = array.length;

            if (initFromArray && length) {
              accumulator = array[++index];
            }
            while (++index < length) {
              accumulator = iteratee(accumulator, array[index], index, array);
            }
            return accumulator;
          }

          /**
           * A specialized version of `_.reduceRight` for arrays without support for
           * callback shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @param {boolean} [initFromArray] Specify using the last element of `array`
           *  as the initial value.
           * @returns {*} Returns the accumulated value.
           */
          function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
            var length = array.length;
            if (initFromArray && length) {
              accumulator = array[--length];
            }
            while (length--) {
              accumulator = iteratee(accumulator, array[length], length, array);
            }
            return accumulator;
          }

          /**
           * A specialized version of `_.some` for arrays without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if any element passes the predicate check,
           *  else `false`.
           */
          function arraySome(array, predicate) {
            var index = -1,
              length = array.length;

            while (++index < length) {
              if (predicate(array[index], index, array)) {
                return true;
              }
            }
            return false;
          }

          /**
           * A specialized version of `_.sum` for arrays without support for iteratees.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @returns {number} Returns the sum.
           */
          function arraySum(array) {
            var length = array.length,
              result = 0;

            while (length--) {
              result += +array[length] || 0;
            }
            return result;
          }

          /**
           * Used by `_.defaults` to customize its `_.assign` use.
           *
           * @private
           * @param {*} objectValue The destination object property value.
           * @param {*} sourceValue The source object property value.
           * @returns {*} Returns the value to assign to the destination object.
           */
          function assignDefaults(objectValue, sourceValue) {
            return objectValue === undefined ? sourceValue : objectValue;
          }

          /**
           * Used by `_.template` to customize its `_.assign` use.
           *
           * **Note:** This function is like `assignDefaults` except that it ignores
           * inherited property values when checking if a property is `undefined`.
           *
           * @private
           * @param {*} objectValue The destination object property value.
           * @param {*} sourceValue The source object property value.
           * @param {string} key The key associated with the object and source values.
           * @param {Object} object The destination object.
           * @returns {*} Returns the value to assign to the destination object.
           */
          function assignOwnDefaults(objectValue, sourceValue, key, object) {
            return (objectValue === undefined || !hasOwnProperty.call(object, key))
              ? sourceValue
              : objectValue;
          }

          /**
           * A specialized version of `_.assign` for customizing assigned values without
           * support for argument juggling, multiple sources, and `this` binding `customizer`
           * functions.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {Function} customizer The function to customize assigned values.
           * @returns {Object} Returns `object`.
           */
          function assignWith(object, source, customizer) {
            var index = -1,
              props = keys(source),
              length = props.length;

            while (++index < length) {
              var key = props[index],
                value = object[key],
                result = customizer(value, source[key], key, object, source);

              if ((result === result ? (result !== value) : (value === value)) ||
                (value === undefined && !(key in object))) {
                object[key] = result;
              }
            }
            return object;
          }

          /**
           * The base implementation of `_.assign` without support for argument juggling,
           * multiple sources, and `customizer` functions.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @returns {Object} Returns `object`.
           */
          function baseAssign(object, source) {
            return source == null
              ? object
              : baseCopy(source, keys(source), object);
          }

          /**
           * The base implementation of `_.at` without support for string collections
           * and individual key arguments.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {number[]|string[]} props The property names or indexes of elements to pick.
           * @returns {Array} Returns the new array of picked elements.
           */
          function baseAt(collection, props) {
            var index = -1,
              isNil = collection == null,
              isArr = !isNil && isArrayLike(collection),
              length = isArr ? collection.length : 0,
              propsLength = props.length,
              result = Array(propsLength);

            while (++index < propsLength) {
              var key = props[index];
              if (isArr) {
                result[index] = isIndex(key, length) ? collection[key] : undefined;
              } else {
                result[index] = isNil ? undefined : collection[key];
              }
            }
            return result;
          }

          /**
           * Copies properties of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy properties from.
           * @param {Array} props The property names to copy.
           * @param {Object} [object={}] The object to copy properties to.
           * @returns {Object} Returns `object`.
           */
          function baseCopy(source, props, object) {
            object || (object = {});

            var index = -1,
              length = props.length;

            while (++index < length) {
              var key = props[index];
              object[key] = source[key];
            }
            return object;
          }

          /**
           * The base implementation of `_.callback` which supports specifying the
           * number of arguments to provide to `func`.
           *
           * @private
           * @param {*} [func=_.identity] The value to convert to a callback.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {number} [argCount] The number of arguments to provide to `func`.
           * @returns {Function} Returns the callback.
           */
          function baseCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (type == 'function') {
              return thisArg === undefined
                ? func
                : bindCallback(func, thisArg, argCount);
            }
            if (func == null) {
              return identity;
            }
            if (type == 'object') {
              return baseMatches(func);
            }
            return thisArg === undefined
              ? property(func)
              : baseMatchesProperty(func, thisArg);
          }

          /**
           * The base implementation of `_.clone` without support for argument juggling
           * and `this` binding `customizer` functions.
           *
           * @private
           * @param {*} value The value to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @param {Function} [customizer] The function to customize cloning values.
           * @param {string} [key] The key of `value`.
           * @param {Object} [object] The object `value` belongs to.
           * @param {Array} [stackA=[]] Tracks traversed source objects.
           * @param {Array} [stackB=[]] Associates clones with source counterparts.
           * @returns {*} Returns the cloned value.
           */
          function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
            var result;
            if (customizer) {
              result = object ? customizer(value, key, object) : customizer(value);
            }
            if (result !== undefined) {
              return result;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result = initCloneArray(value);
              if (!isDeep) {
                return arrayCopy(value, result);
              }
            } else {
              var tag = objToString.call(value),
                isFunc = tag == funcTag;

              if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                result = initCloneObject(isFunc ? {} : value);
                if (!isDeep) {
                  return baseAssign(result, value);
                }
              } else {
                return cloneableTags[tag]
                  ? initCloneByTag(value, tag, isDeep)
                  : (object ? value : {});
              }
            }
            // Check for circular references and return corresponding clone.
            stackA || (stackA = []);
            stackB || (stackB = []);

            var length = stackA.length;
            while (length--) {
              if (stackA[length] == value) {
                return stackB[length];
              }
            }
            // Add the source value to the stack of traversed objects and associate it with its clone.
            stackA.push(value);
            stackB.push(result);

            // Recursively populate clone (susceptible to call stack limits).
            (isArr ? arrayEach : baseForOwn)(value, function (subValue, key) {
              result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
            });
            return result;
          }

          /**
           * The base implementation of `_.create` without support for assigning
           * properties to the created object.
           *
           * @private
           * @param {Object} prototype The object to inherit from.
           * @returns {Object} Returns the new object.
           */
          var baseCreate = (function () {
            function object() { }
            return function (prototype) {
              if (isObject(prototype)) {
                object.prototype = prototype;
                var result = new object;
                object.prototype = null;
              }
              return result || {};
            };
          }());

          /**
           * The base implementation of `_.delay` and `_.defer` which accepts an index
           * of where to slice the arguments to provide to `func`.
           *
           * @private
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @param {Object} args The arguments provide to `func`.
           * @returns {number} Returns the timer id.
           */
          function baseDelay(func, wait, args) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            return setTimeout(function () { func.apply(undefined, args); }, wait);
          }

          /**
           * The base implementation of `_.difference` which accepts a single array
           * of values to exclude.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Array} values The values to exclude.
           * @returns {Array} Returns the new array of filtered values.
           */
          function baseDifference(array, values) {
            var length = array ? array.length : 0,
              result = [];

            if (!length) {
              return result;
            }
            var index = -1,
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              cache = (isCommon && values.length >= 200) ? createCache(values) : null,
              valuesLength = values.length;

            if (cache) {
              indexOf = cacheIndexOf;
              isCommon = false;
              values = cache;
            }
            outer:
            while (++index < length) {
              var value = array[index];

              if (isCommon && value === value) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values[valuesIndex] === value) {
                    continue outer;
                  }
                }
                result.push(value);
              }
              else if (indexOf(values, value, 0) < 0) {
                result.push(value);
              }
            }
            return result;
          }

          /**
           * The base implementation of `_.forEach` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array|Object|string} Returns `collection`.
           */
          var baseEach = createBaseEach(baseForOwn);

          /**
           * The base implementation of `_.forEachRight` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array|Object|string} Returns `collection`.
           */
          var baseEachRight = createBaseEach(baseForOwnRight, true);

          /**
           * The base implementation of `_.every` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if all elements pass the predicate check,
           *  else `false`
           */
          function baseEvery(collection, predicate) {
            var result = true;
            baseEach(collection, function (value, index, collection) {
              result = !!predicate(value, index, collection);
              return result;
            });
            return result;
          }

          /**
           * Gets the extremum value of `collection` invoking `iteratee` for each value
           * in `collection` to generate the criterion by which the value is ranked.
           * The `iteratee` is invoked with three arguments: (value, index|key, collection).
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} comparator The function used to compare values.
           * @param {*} exValue The initial extremum value.
           * @returns {*} Returns the extremum value.
           */
          function baseExtremum(collection, iteratee, comparator, exValue) {
            var computed = exValue,
              result = computed;

            baseEach(collection, function (value, index, collection) {
              var current = +iteratee(value, index, collection);
              if (comparator(current, computed) || (current === exValue && current === result)) {
                computed = current;
                result = value;
              }
            });
            return result;
          }

          /**
           * The base implementation of `_.fill` without an iteratee call guard.
           *
           * @private
           * @param {Array} array The array to fill.
           * @param {*} value The value to fill `array` with.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns `array`.
           */
          function baseFill(array, value, start, end) {
            var length = array.length;

            start = start == null ? 0 : (+start || 0);
            if (start < 0) {
              start = -start > length ? 0 : (length + start);
            }
            end = (end === undefined || end > length) ? length : (+end || 0);
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : (end >>> 0);
            start >>>= 0;

            while (start < length) {
              array[start++] = value;
            }
            return array;
          }

          /**
           * The base implementation of `_.filter` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           */
          function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function (value, index, collection) {
              if (predicate(value, index, collection)) {
                result.push(value);
              }
            });
            return result;
          }

          /**
           * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
           * without support for callback shorthands and `this` binding, which iterates
           * over `collection` using the provided `eachFunc`.
           *
           * @private
           * @param {Array|Object|string} collection The collection to search.
           * @param {Function} predicate The function invoked per iteration.
           * @param {Function} eachFunc The function to iterate over `collection`.
           * @param {boolean} [retKey] Specify returning the key of the found element
           *  instead of the element itself.
           * @returns {*} Returns the found element or its key, else `undefined`.
           */
          function baseFind(collection, predicate, eachFunc, retKey) {
            var result;
            eachFunc(collection, function (value, key, collection) {
              if (predicate(value, key, collection)) {
                result = retKey ? key : value;
                return false;
              }
            });
            return result;
          }

          /**
           * The base implementation of `_.flatten` with added support for restricting
           * flattening and specifying the start index.
           *
           * @private
           * @param {Array} array The array to flatten.
           * @param {boolean} [isDeep] Specify a deep flatten.
           * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
           * @returns {Array} Returns the new flattened array.
           */
          function baseFlatten(array, isDeep, isStrict) {
            var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];

            while (++index < length) {
              var value = array[index];
              if (isObjectLike(value) && isArrayLike(value) &&
                (isStrict || isArray(value) || isArguments(value))) {
                if (isDeep) {
                  // Recursively flatten arrays (susceptible to call stack limits).
                  value = baseFlatten(value, isDeep, isStrict);
                }
                var valIndex = -1,
                  valLength = value.length;

                while (++valIndex < valLength) {
                  result[++resIndex] = value[valIndex];
                }
              } else if (!isStrict) {
                result[++resIndex] = value;
              }
            }
            return result;
          }

          /**
           * The base implementation of `baseForIn` and `baseForOwn` which iterates
           * over `object` properties returned by `keysFunc` invoking `iteratee` for
           * each property. Iteratee functions may exit iteration early by explicitly
           * returning `false`.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @returns {Object} Returns `object`.
           */
          var baseFor = createBaseFor();

          /**
           * This function is like `baseFor` except that it iterates over properties
           * in the opposite order.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @returns {Object} Returns `object`.
           */
          var baseForRight = createBaseFor(true);

          /**
           * The base implementation of `_.forIn` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Object} Returns `object`.
           */
          function baseForIn(object, iteratee) {
            return baseFor(object, iteratee, keysIn);
          }

          /**
           * The base implementation of `_.forOwn` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Object} Returns `object`.
           */
          function baseForOwn(object, iteratee) {
            return baseFor(object, iteratee, keys);
          }

          /**
           * The base implementation of `_.forOwnRight` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Object} Returns `object`.
           */
          function baseForOwnRight(object, iteratee) {
            return baseForRight(object, iteratee, keys);
          }

          /**
           * The base implementation of `_.functions` which creates an array of
           * `object` function property names filtered from those provided.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Array} props The property names to filter.
           * @returns {Array} Returns the new array of filtered property names.
           */
          function baseFunctions(object, props) {
            var index = -1,
              length = props.length,
              resIndex = -1,
              result = [];

            while (++index < length) {
              var key = props[index];
              if (isFunction(object[key])) {
                result[++resIndex] = key;
              }
            }
            return result;
          }

          /**
           * The base implementation of `get` without support for string paths
           * and default values.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array} path The path of the property to get.
           * @param {string} [pathKey] The key representation of path.
           * @returns {*} Returns the resolved value.
           */
          function baseGet(object, path, pathKey) {
            if (object == null) {
              return;
            }
            if (pathKey !== undefined && pathKey in toObject(object)) {
              path = [pathKey];
            }
            var index = 0,
              length = path.length;

            while (object != null && index < length) {
              object = object[path[index++]];
            }
            return (index && index == length) ? object : undefined;
          }

          /**
           * The base implementation of `_.isEqual` without support for `this` binding
           * `customizer` functions.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @param {Function} [customizer] The function to customize comparing values.
           * @param {boolean} [isLoose] Specify performing partial comparisons.
           * @param {Array} [stackA] Tracks traversed `value` objects.
           * @param {Array} [stackB] Tracks traversed `other` objects.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           */
          function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
          }

          /**
           * A specialized version of `baseIsEqual` for arrays and objects which performs
           * deep comparisons and tracks traversed objects enabling objects with circular
           * references to be compared.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Function} [customizer] The function to customize comparing objects.
           * @param {boolean} [isLoose] Specify performing partial comparisons.
           * @param {Array} [stackA=[]] Tracks traversed `value` objects.
           * @param {Array} [stackB=[]] Tracks traversed `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */
          function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;

            if (!objIsArr) {
              objTag = objToString.call(object);
              if (objTag == argsTag) {
                objTag = objectTag;
              } else if (objTag != objectTag) {
                objIsArr = isTypedArray(object);
              }
            }
            if (!othIsArr) {
              othTag = objToString.call(other);
              if (othTag == argsTag) {
                othTag = objectTag;
              } else if (othTag != objectTag) {
                othIsArr = isTypedArray(other);
              }
            }
            var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;

            if (isSameTag && !(objIsArr || objIsObj)) {
              return equalByTag(object, other, objTag);
            }
            if (!isLoose) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

              if (objIsWrapped || othIsWrapped) {
                return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
              }
            }
            if (!isSameTag) {
              return false;
            }
            // Assume cyclic values are equal.
            // For more information on detecting circular references see https://es5.github.io/#JO.
            stackA || (stackA = []);
            stackB || (stackB = []);

            var length = stackA.length;
            while (length--) {
              if (stackA[length] == object) {
                return stackB[length] == other;
              }
            }
            // Add `object` and `other` to the stack of traversed objects.
            stackA.push(object);
            stackB.push(other);

            var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

            stackA.pop();
            stackB.pop();

            return result;
          }

          /**
           * The base implementation of `_.isMatch` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Array} matchData The propery names, values, and compare flags to match.
           * @param {Function} [customizer] The function to customize comparing objects.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           */
          function baseIsMatch(object, matchData, customizer) {
            var index = matchData.length,
              length = index,
              noCustomizer = !customizer;

            if (object == null) {
              return !length;
            }
            object = toObject(object);
            while (index--) {
              var data = matchData[index];
              if ((noCustomizer && data[2])
                ? data[1] !== object[data[0]]
                : !(data[0] in object)
              ) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0],
                objValue = object[key],
                srcValue = data[1];

              if (noCustomizer && data[2]) {
                if (objValue === undefined && !(key in object)) {
                  return false;
                }
              } else {
                var result = customizer ? customizer(objValue, srcValue, key) : undefined;
                if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                  return false;
                }
              }
            }
            return true;
          }

          /**
           * The base implementation of `_.map` without support for callback shorthands
           * and `this` binding.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns the new mapped array.
           */
          function baseMap(collection, iteratee) {
            var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];

            baseEach(collection, function (value, key, collection) {
              result[++index] = iteratee(value, key, collection);
            });
            return result;
          }

          /**
           * The base implementation of `_.matches` which does not clone `source`.
           *
           * @private
           * @param {Object} source The object of property values to match.
           * @returns {Function} Returns the new function.
           */
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              var key = matchData[0][0],
                value = matchData[0][1];

              return function (object) {
                if (object == null) {
                  return false;
                }
                return object[key] === value && (value !== undefined || (key in toObject(object)));
              };
            }
            return function (object) {
              return baseIsMatch(object, matchData);
            };
          }

          /**
           * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
           *
           * @private
           * @param {string} path The path of the property to get.
           * @param {*} srcValue The value to compare.
           * @returns {Function} Returns the new function.
           */
          function baseMatchesProperty(path, srcValue) {
            var isArr = isArray(path),
              isCommon = isKey(path) && isStrictComparable(srcValue),
              pathKey = (path + '');

            path = toPath(path);
            return function (object) {
              if (object == null) {
                return false;
              }
              var key = pathKey;
              object = toObject(object);
              if ((isArr || !isCommon) && !(key in object)) {
                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                if (object == null) {
                  return false;
                }
                key = last(path);
                object = toObject(object);
              }
              return object[key] === srcValue
                ? (srcValue !== undefined || (key in object))
                : baseIsEqual(srcValue, object[key], undefined, true);
            };
          }

          /**
           * The base implementation of `_.merge` without support for argument juggling,
           * multiple sources, and `this` binding `customizer` functions.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {Function} [customizer] The function to customize merging properties.
           * @param {Array} [stackA=[]] Tracks traversed source objects.
           * @param {Array} [stackB=[]] Associates values with source counterparts.
           * @returns {Object} Returns `object`.
           */
          function baseMerge(object, source, customizer, stackA, stackB) {
            if (!isObject(object)) {
              return object;
            }
            var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
              props = isSrcArr ? null : keys(source);

            arrayEach(props || source, function (srcValue, key) {
              if (props) {
                key = srcValue;
                srcValue = source[key];
              }
              if (isObjectLike(srcValue)) {
                stackA || (stackA = []);
                stackB || (stackB = []);
                baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
              }
              else {
                var value = object[key],
                  result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                  isCommon = result === undefined;

                if (isCommon) {
                  result = srcValue;
                }
                if ((result !== undefined || (isSrcArr && !(key in object))) &&
                  (isCommon || (result === result ? (result !== value) : (value === value)))) {
                  object[key] = result;
                }
              }
            });
            return object;
          }

          /**
           * A specialized version of `baseMerge` for arrays and objects which performs
           * deep merges and tracks traversed objects enabling objects with circular
           * references to be merged.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {string} key The key of the value to merge.
           * @param {Function} mergeFunc The function to merge values.
           * @param {Function} [customizer] The function to customize merging properties.
           * @param {Array} [stackA=[]] Tracks traversed source objects.
           * @param {Array} [stackB=[]] Associates values with source counterparts.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */
          function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
            var length = stackA.length,
              srcValue = source[key];

            while (length--) {
              if (stackA[length] == srcValue) {
                object[key] = stackB[length];
                return;
              }
            }
            var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;

            if (isCommon) {
              result = srcValue;
              if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
                result = isArray(value)
                  ? value
                  : (isArrayLike(value) ? arrayCopy(value) : []);
              }
              else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                result = isArguments(value)
                  ? toPlainObject(value)
                  : (isPlainObject(value) ? value : {});
              }
              else {
                isCommon = false;
              }
            }
            // Add the source value to the stack of traversed objects and associate
            // it with its merged value.
            stackA.push(srcValue);
            stackB.push(result);

            if (isCommon) {
              // Recursively merge objects and arrays (susceptible to call stack limits).
              object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
            } else if (result === result ? (result !== value) : (value === value)) {
              object[key] = result;
            }
          }

          /**
           * The base implementation of `_.property` without support for deep paths.
           *
           * @private
           * @param {string} key The key of the property to get.
           * @returns {Function} Returns the new function.
           */
          function baseProperty(key) {
            return function (object) {
              return object == null ? undefined : object[key];
            };
          }

          /**
           * A specialized version of `baseProperty` which supports deep paths.
           *
           * @private
           * @param {Array|string} path The path of the property to get.
           * @returns {Function} Returns the new function.
           */
          function basePropertyDeep(path) {
            var pathKey = (path + '');
            path = toPath(path);
            return function (object) {
              return baseGet(object, path, pathKey);
            };
          }

          /**
           * The base implementation of `_.pullAt` without support for individual
           * index arguments and capturing the removed elements.
           *
           * @private
           * @param {Array} array The array to modify.
           * @param {number[]} indexes The indexes of elements to remove.
           * @returns {Array} Returns `array`.
           */
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0;
            while (length--) {
              var index = indexes[length];
              if (index != previous && isIndex(index)) {
                var previous = index;
                splice.call(array, index, 1);
              }
            }
            return array;
          }

          /**
           * The base implementation of `_.random` without support for argument juggling
           * and returning floating-point numbers.
           *
           * @private
           * @param {number} min The minimum possible value.
           * @param {number} max The maximum possible value.
           * @returns {number} Returns the random number.
           */
          function baseRandom(min, max) {
            return min + floor(nativeRandom() * (max - min + 1));
          }

          /**
           * The base implementation of `_.reduce` and `_.reduceRight` without support
           * for callback shorthands and `this` binding, which iterates over `collection`
           * using the provided `eachFunc`.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {*} accumulator The initial value.
           * @param {boolean} initFromCollection Specify using the first or last element
           *  of `collection` as the initial value.
           * @param {Function} eachFunc The function to iterate over `collection`.
           * @returns {*} Returns the accumulated value.
           */
          function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
            eachFunc(collection, function (value, index, collection) {
              accumulator = initFromCollection
                ? (initFromCollection = false, value)
                : iteratee(accumulator, value, index, collection);
            });
            return accumulator;
          }

          /**
           * The base implementation of `setData` without support for hot loop detection.
           *
           * @private
           * @param {Function} func The function to associate metadata with.
           * @param {*} data The metadata.
           * @returns {Function} Returns `func`.
           */
          var baseSetData = !metaMap ? identity : function (func, data) {
            metaMap.set(func, data);
            return func;
          };

          /**
           * The base implementation of `_.slice` without an iteratee call guard.
           *
           * @private
           * @param {Array} array The array to slice.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the slice of `array`.
           */
          function baseSlice(array, start, end) {
            var index = -1,
              length = array.length;

            start = start == null ? 0 : (+start || 0);
            if (start < 0) {
              start = -start > length ? 0 : (length + start);
            }
            end = (end === undefined || end > length) ? length : (+end || 0);
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : ((end - start) >>> 0);
            start >>>= 0;

            var result = Array(length);
            while (++index < length) {
              result[index] = array[index + start];
            }
            return result;
          }

          /**
           * The base implementation of `_.some` without support for callback shorthands
           * and `this` binding.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if any element passes the predicate check,
           *  else `false`.
           */
          function baseSome(collection, predicate) {
            var result;

            baseEach(collection, function (value, index, collection) {
              result = predicate(value, index, collection);
              return !result;
            });
            return !!result;
          }

          /**
           * The base implementation of `_.sortBy` which uses `comparer` to define
           * the sort order of `array` and replaces criteria objects with their
           * corresponding values.
           *
           * @private
           * @param {Array} array The array to sort.
           * @param {Function} comparer The function to define sort order.
           * @returns {Array} Returns `array`.
           */
          function baseSortBy(array, comparer) {
            var length = array.length;

            array.sort(comparer);
            while (length--) {
              array[length] = array[length].value;
            }
            return array;
          }

          /**
           * The base implementation of `_.sortByOrder` without param guards.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
           * @param {boolean[]} orders The sort orders of `iteratees`.
           * @returns {Array} Returns the new sorted array.
           */
          function baseSortByOrder(collection, iteratees, orders) {
            var callback = getCallback(),
              index = -1;

            iteratees = arrayMap(iteratees, function (iteratee) { return callback(iteratee); });

            var result = baseMap(collection, function (value) {
              var criteria = arrayMap(iteratees, function (iteratee) { return iteratee(value); });
              return { 'criteria': criteria, 'index': ++index, 'value': value };
            });

            return baseSortBy(result, function (object, other) {
              return compareMultiple(object, other, orders);
            });
          }

          /**
           * The base implementation of `_.sum` without support for callback shorthands
           * and `this` binding.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {number} Returns the sum.
           */
          function baseSum(collection, iteratee) {
            var result = 0;
            baseEach(collection, function (value, index, collection) {
              result += +iteratee(value, index, collection) || 0;
            });
            return result;
          }

          /**
           * The base implementation of `_.uniq` without support for callback shorthands
           * and `this` binding.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee] The function invoked per iteration.
           * @returns {Array} Returns the new duplicate-value-free array.
           */
          function baseUniq(array, iteratee) {
            var index = -1,
              indexOf = getIndexOf(),
              length = array.length,
              isCommon = indexOf == baseIndexOf,
              isLarge = isCommon && length >= 200,
              seen = isLarge ? createCache() : null,
              result = [];

            if (seen) {
              indexOf = cacheIndexOf;
              isCommon = false;
            } else {
              isLarge = false;
              seen = iteratee ? [] : result;
            }
            outer:
            while (++index < length) {
              var value = array[index],
                computed = iteratee ? iteratee(value, index, array) : value;

              if (isCommon && value === value) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee) {
                  seen.push(computed);
                }
                result.push(value);
              }
              else if (indexOf(seen, computed, 0) < 0) {
                if (iteratee || isLarge) {
                  seen.push(computed);
                }
                result.push(value);
              }
            }
            return result;
          }

          /**
           * The base implementation of `_.values` and `_.valuesIn` which creates an
           * array of `object` property values corresponding to the property names
           * of `props`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array} props The property names to get values for.
           * @returns {Object} Returns the array of property values.
           */
          function baseValues(object, props) {
            var index = -1,
              length = props.length,
              result = Array(length);

            while (++index < length) {
              result[index] = object[props[index]];
            }
            return result;
          }

          /**
           * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
           * and `_.takeWhile` without support for callback shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to query.
           * @param {Function} predicate The function invoked per iteration.
           * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Array} Returns the slice of `array`.
           */
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length,
              index = fromRight ? length : -1;

            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) { }
            return isDrop
              ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
              : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
          }

          /**
           * The base implementation of `wrapperValue` which returns the result of
           * performing a sequence of actions on the unwrapped `value`, where each
           * successive action is supplied the return value of the previous.
           *
           * @private
           * @param {*} value The unwrapped value.
           * @param {Array} actions Actions to peform to resolve the unwrapped value.
           * @returns {*} Returns the resolved value.
           */
          function baseWrapperValue(value, actions) {
            var result = value;
            if (result instanceof LazyWrapper) {
              result = result.value();
            }
            var index = -1,
              length = actions.length;

            while (++index < length) {
              var args = [result],
                action = actions[index];

              push.apply(args, action.args);
              result = action.func.apply(action.thisArg, args);
            }
            return result;
          }

          /**
           * Performs a binary search of `array` to determine the index at which `value`
           * should be inserted into `array` in order to maintain its sort order.
           *
           * @private
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {boolean} [retHighest] Specify returning the highest qualified index.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           */
          function binaryIndex(array, value, retHighest) {
            var low = 0,
              high = array ? array.length : low;

            if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = (low + high) >>> 1,
                  computed = array[mid];

                if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return binaryIndexBy(array, value, identity, retHighest);
          }

          /**
           * This function is like `binaryIndex` except that it invokes `iteratee` for
           * `value` and each element of `array` to compute their sort ranking. The
           * iteratee is invoked with one argument; (value).
           *
           * @private
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {boolean} [retHighest] Specify returning the highest qualified index.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           */
          function binaryIndexBy(array, value, iteratee, retHighest) {
            value = iteratee(value);

            var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsNull = value === null,
              valIsUndef = value === undefined;

            while (low < high) {
              var mid = floor((low + high) / 2),
                computed = iteratee(array[mid]),
                isDef = computed !== undefined,
                isReflexive = computed === computed;

              if (valIsNaN) {
                var setLow = isReflexive || retHighest;
              } else if (valIsNull) {
                setLow = isReflexive && isDef && (retHighest || computed != null);
              } else if (valIsUndef) {
                setLow = isReflexive && (retHighest || isDef);
              } else if (computed == null) {
                setLow = false;
              } else {
                setLow = retHighest ? (computed <= value) : (computed < value);
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }

          /**
           * A specialized version of `baseCallback` which only supports `this` binding
           * and specifying the number of arguments to provide to `func`.
           *
           * @private
           * @param {Function} func The function to bind.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {number} [argCount] The number of arguments to provide to `func`.
           * @returns {Function} Returns the callback.
           */
          function bindCallback(func, thisArg, argCount) {
            if (typeof func != 'function') {
              return identity;
            }
            if (thisArg === undefined) {
              return func;
            }
            switch (argCount) {
              case 1: return function (value) {
                return func.call(thisArg, value);
              };
              case 3: return function (value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
              case 4: return function (accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
              case 5: return function (value, other, key, object, source) {
                return func.call(thisArg, value, other, key, object, source);
              };
            }
            return function () {
              return func.apply(thisArg, arguments);
            };
          }

          /**
           * Creates a clone of the given array buffer.
           *
           * @private
           * @param {ArrayBuffer} buffer The array buffer to clone.
           * @returns {ArrayBuffer} Returns the cloned array buffer.
           */
          function bufferClone(buffer) {
            return bufferSlice.call(buffer, 0);
          }
          if (!bufferSlice) {
            // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
            bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function (buffer) {
              var byteLength = buffer.byteLength,
                floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
                offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
                result = new ArrayBuffer(byteLength);

              if (floatLength) {
                var view = new Float64Array(result, 0, floatLength);
                view.set(new Float64Array(buffer, 0, floatLength));
              }
              if (byteLength != offset) {
                view = new Uint8Array(result, offset);
                view.set(new Uint8Array(buffer, offset));
              }
              return result;
            };
          }

          /**
           * Creates an array that is the composition of partially applied arguments,
           * placeholders, and provided arguments into a single array of arguments.
           *
           * @private
           * @param {Array|Object} args The provided arguments.
           * @param {Array} partials The arguments to prepend to those provided.
           * @param {Array} holders The `partials` placeholder indexes.
           * @returns {Array} Returns the new array of composed arguments.
           */
          function composeArgs(args, partials, holders) {
            var holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              leftIndex = -1,
              leftLength = partials.length,
              result = Array(argsLength + leftLength);

            while (++leftIndex < leftLength) {
              result[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              result[holders[argsIndex]] = args[argsIndex];
            }
            while (argsLength--) {
              result[leftIndex++] = args[argsIndex++];
            }
            return result;
          }

          /**
           * This function is like `composeArgs` except that the arguments composition
           * is tailored for `_.partialRight`.
           *
           * @private
           * @param {Array|Object} args The provided arguments.
           * @param {Array} partials The arguments to append to those provided.
           * @param {Array} holders The `partials` placeholder indexes.
           * @returns {Array} Returns the new array of composed arguments.
           */
          function composeArgsRight(args, partials, holders) {
            var holdersIndex = -1,
              holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              rightIndex = -1,
              rightLength = partials.length,
              result = Array(argsLength + rightLength);

            while (++argsIndex < argsLength) {
              result[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              result[offset + holders[holdersIndex]] = args[argsIndex++];
            }
            return result;
          }

          /**
           * Creates a function that aggregates a collection, creating an accumulator
           * object composed from the results of running each element in the collection
           * through an iteratee.
           *
           * **Note:** This function is used to create `_.countBy`, `_.groupBy`, `_.indexBy`,
           * and `_.partition`.
           *
           * @private
           * @param {Function} setter The function to set keys and values of the accumulator object.
           * @param {Function} [initializer] The function to initialize the accumulator object.
           * @returns {Function} Returns the new aggregator function.
           */
          function createAggregator(setter, initializer) {
            return function (collection, iteratee, thisArg) {
              var result = initializer ? initializer() : {};
              iteratee = getCallback(iteratee, thisArg, 3);

              if (isArray(collection)) {
                var index = -1,
                  length = collection.length;

                while (++index < length) {
                  var value = collection[index];
                  setter(result, value, iteratee(value, index, collection), collection);
                }
              } else {
                baseEach(collection, function (value, key, collection) {
                  setter(result, value, iteratee(value, key, collection), collection);
                });
              }
              return result;
            };
          }

          /**
           * Creates a function that assigns properties of source object(s) to a given
           * destination object.
           *
           * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.
           *
           * @private
           * @param {Function} assigner The function to assign values.
           * @returns {Function} Returns the new assigner function.
           */
          function createAssigner(assigner) {
            return restParam(function (object, sources) {
              var index = -1,
                length = object == null ? 0 : sources.length,
                customizer = length > 2 ? sources[length - 2] : undefined,
                guard = length > 2 ? sources[2] : undefined,
                thisArg = length > 1 ? sources[length - 1] : undefined;

              if (typeof customizer == 'function') {
                customizer = bindCallback(customizer, thisArg, 5);
                length -= 2;
              } else {
                customizer = typeof thisArg == 'function' ? thisArg : undefined;
                length -= (customizer ? 1 : 0);
              }
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined : customizer;
                length = 1;
              }
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, customizer);
                }
              }
              return object;
            });
          }

          /**
           * Creates a `baseEach` or `baseEachRight` function.
           *
           * @private
           * @param {Function} eachFunc The function to iterate over a collection.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new base function.
           */
          function createBaseEach(eachFunc, fromRight) {
            return function (collection, iteratee) {
              var length = collection ? getLength(collection) : 0;
              if (!isLength(length)) {
                return eachFunc(collection, iteratee);
              }
              var index = fromRight ? length : -1,
                iterable = toObject(collection);

              while ((fromRight ? index-- : ++index < length)) {
                if (iteratee(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }

          /**
           * Creates a base function for `_.forIn` or `_.forInRight`.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new base function.
           */
          function createBaseFor(fromRight) {
            return function (object, iteratee, keysFunc) {
              var iterable = toObject(object),
                props = keysFunc(object),
                length = props.length,
                index = fromRight ? length : -1;

              while ((fromRight ? index-- : ++index < length)) {
                var key = props[index];
                if (iteratee(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }

          /**
           * Creates a function that wraps `func` and invokes it with the `this`
           * binding of `thisArg`.
           *
           * @private
           * @param {Function} func The function to bind.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @returns {Function} Returns the new bound function.
           */
          function createBindWrapper(func, thisArg) {
            var Ctor = createCtorWrapper(func);

            function wrapper() {
              var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
              return fn.apply(thisArg, arguments);
            }
            return wrapper;
          }

          /**
           * Creates a `Set` cache object to optimize linear searches of large arrays.
           *
           * @private
           * @param {Array} [values] The values to cache.
           * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
           */
          var createCache = !(nativeCreate && Set) ? constant(null) : function (values) {
            return new SetCache(values);
          };

          /**
           * Creates a function that produces compound words out of the words in a
           * given string.
           *
           * @private
           * @param {Function} callback The function to combine each word.
           * @returns {Function} Returns the new compounder function.
           */
          function createCompounder(callback) {
            return function (string) {
              var index = -1,
                array = words(deburr(string)),
                length = array.length,
                result = '';

              while (++index < length) {
                result = callback(result, array[index], index);
              }
              return result;
            };
          }

          /**
           * Creates a function that produces an instance of `Ctor` regardless of
           * whether it was invoked as part of a `new` expression or by `call` or `apply`.
           *
           * @private
           * @param {Function} Ctor The constructor to wrap.
           * @returns {Function} Returns the new wrapped function.
           */
          function createCtorWrapper(Ctor) {
            return function () {
              // Use a `switch` statement to work with class constructors.
              // See https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-function-objects-call-thisargument-argumentslist
              // for more details.
              var args = arguments;
              switch (args.length) {
                case 0: return new Ctor;
                case 1: return new Ctor(args[0]);
                case 2: return new Ctor(args[0], args[1]);
                case 3: return new Ctor(args[0], args[1], args[2]);
                case 4: return new Ctor(args[0], args[1], args[2], args[3]);
                case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              }
              var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);

              // Mimic the constructor's `return` behavior.
              // See https://es5.github.io/#x13.2.2 for more details.
              return isObject(result) ? result : thisBinding;
            };
          }

          /**
           * Creates a `_.curry` or `_.curryRight` function.
           *
           * @private
           * @param {boolean} flag The curry bit flag.
           * @returns {Function} Returns the new curry function.
           */
          function createCurry(flag) {
            function curryFunc(func, arity, guard) {
              if (guard && isIterateeCall(func, arity, guard)) {
                arity = null;
              }
              var result = createWrapper(func, flag, null, null, null, null, null, arity);
              result.placeholder = curryFunc.placeholder;
              return result;
            }
            return curryFunc;
          }

          /**
           * Creates a `_.max` or `_.min` function.
           *
           * @private
           * @param {Function} comparator The function used to compare values.
           * @param {*} exValue The initial extremum value.
           * @returns {Function} Returns the new extremum function.
           */
          function createExtremum(comparator, exValue) {
            return function (collection, iteratee, thisArg) {
              if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                iteratee = null;
              }
              iteratee = getCallback(iteratee, thisArg, 3);
              if (iteratee.length == 1) {
                collection = toIterable(collection);
                var result = arrayExtremum(collection, iteratee, comparator, exValue);
                if (!(collection.length && result === exValue)) {
                  return result;
                }
              }
              return baseExtremum(collection, iteratee, comparator, exValue);
            };
          }

          /**
           * Creates a `_.find` or `_.findLast` function.
           *
           * @private
           * @param {Function} eachFunc The function to iterate over a collection.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new find function.
           */
          function createFind(eachFunc, fromRight) {
            return function (collection, predicate, thisArg) {
              predicate = getCallback(predicate, thisArg, 3);
              if (isArray(collection)) {
                var index = baseFindIndex(collection, predicate, fromRight);
                return index > -1 ? collection[index] : undefined;
              }
              return baseFind(collection, predicate, eachFunc);
            };
          }

          /**
           * Creates a `_.findIndex` or `_.findLastIndex` function.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new find function.
           */
          function createFindIndex(fromRight) {
            return function (array, predicate, thisArg) {
              if (!(array && array.length)) {
                return -1;
              }
              predicate = getCallback(predicate, thisArg, 3);
              return baseFindIndex(array, predicate, fromRight);
            };
          }

          /**
           * Creates a `_.findKey` or `_.findLastKey` function.
           *
           * @private
           * @param {Function} objectFunc The function to iterate over an object.
           * @returns {Function} Returns the new find function.
           */
          function createFindKey(objectFunc) {
            return function (object, predicate, thisArg) {
              predicate = getCallback(predicate, thisArg, 3);
              return baseFind(object, predicate, objectFunc, true);
            };
          }

          /**
           * Creates a `_.flow` or `_.flowRight` function.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new flow function.
           */
          function createFlow(fromRight) {
            return function () {
              var wrapper,
                length = arguments.length,
                index = fromRight ? length : -1,
                leftIndex = 0,
                funcs = Array(length);

              while ((fromRight ? index-- : ++index < length)) {
                var func = funcs[leftIndex++] = arguments[index];
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
                  wrapper = new LodashWrapper([]);
                }
              }
              index = wrapper ? -1 : length;
              while (++index < length) {
                func = funcs[index];

                var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : null;

                if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function () {
                var args = arguments;
                if (wrapper && args.length == 1 && isArray(args[0])) {
                  return wrapper.plant(args[0]).value();
                }
                var index = 0,
                  result = length ? funcs[index].apply(this, args) : args[0];

                while (++index < length) {
                  result = funcs[index].call(this, result);
                }
                return result;
              };
            };
          }

          /**
           * Creates a function for `_.forEach` or `_.forEachRight`.
           *
           * @private
           * @param {Function} arrayFunc The function to iterate over an array.
           * @param {Function} eachFunc The function to iterate over a collection.
           * @returns {Function} Returns the new each function.
           */
          function createForEach(arrayFunc, eachFunc) {
            return function (collection, iteratee, thisArg) {
              return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
                ? arrayFunc(collection, iteratee)
                : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
            };
          }

          /**
           * Creates a function for `_.forIn` or `_.forInRight`.
           *
           * @private
           * @param {Function} objectFunc The function to iterate over an object.
           * @returns {Function} Returns the new each function.
           */
          function createForIn(objectFunc) {
            return function (object, iteratee, thisArg) {
              if (typeof iteratee != 'function' || thisArg !== undefined) {
                iteratee = bindCallback(iteratee, thisArg, 3);
              }
              return objectFunc(object, iteratee, keysIn);
            };
          }

          /**
           * Creates a function for `_.forOwn` or `_.forOwnRight`.
           *
           * @private
           * @param {Function} objectFunc The function to iterate over an object.
           * @returns {Function} Returns the new each function.
           */
          function createForOwn(objectFunc) {
            return function (object, iteratee, thisArg) {
              if (typeof iteratee != 'function' || thisArg !== undefined) {
                iteratee = bindCallback(iteratee, thisArg, 3);
              }
              return objectFunc(object, iteratee);
            };
          }

          /**
           * Creates a function for `_.mapKeys` or `_.mapValues`.
           *
           * @private
           * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
           * @returns {Function} Returns the new map function.
           */
          function createObjectMapper(isMapKeys) {
            return function (object, iteratee, thisArg) {
              var result = {};
              iteratee = getCallback(iteratee, thisArg, 3);

              baseForOwn(object, function (value, key, object) {
                var mapped = iteratee(value, key, object);
                key = isMapKeys ? mapped : key;
                value = isMapKeys ? value : mapped;
                result[key] = value;
              });
              return result;
            };
          }

          /**
           * Creates a function for `_.padLeft` or `_.padRight`.
           *
           * @private
           * @param {boolean} [fromRight] Specify padding from the right.
           * @returns {Function} Returns the new pad function.
           */
          function createPadDir(fromRight) {
            return function (string, length, chars) {
              string = baseToString(string);
              return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
            };
          }

          /**
           * Creates a `_.partial` or `_.partialRight` function.
           *
           * @private
           * @param {boolean} flag The partial bit flag.
           * @returns {Function} Returns the new partial function.
           */
          function createPartial(flag) {
            var partialFunc = restParam(function (func, partials) {
              var holders = replaceHolders(partials, partialFunc.placeholder);
              return createWrapper(func, flag, null, partials, holders);
            });
            return partialFunc;
          }

          /**
           * Creates a function for `_.reduce` or `_.reduceRight`.
           *
           * @private
           * @param {Function} arrayFunc The function to iterate over an array.
           * @param {Function} eachFunc The function to iterate over a collection.
           * @returns {Function} Returns the new each function.
           */
          function createReduce(arrayFunc, eachFunc) {
            return function (collection, iteratee, accumulator, thisArg) {
              var initFromArray = arguments.length < 3;
              return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
                ? arrayFunc(collection, iteratee, accumulator, initFromArray)
                : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
            };
          }

          /**
           * Creates a function that wraps `func` and invokes it with optional `this`
           * binding of, partial application, and currying.
           *
           * @private
           * @param {Function|string} func The function or method name to reference.
           * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to prepend to those provided to the new function.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
           * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */
          function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurry = bitmask & CURRY_FLAG,
              isCurryBound = bitmask & CURRY_BOUND_FLAG,
              isCurryRight = bitmask & CURRY_RIGHT_FLAG,
              Ctor = isBindKey ? null : createCtorWrapper(func);

            function wrapper() {
              // Avoid `arguments` object use disqualifying optimizations by
              // converting it to an array before providing it to other functions.
              var length = arguments.length,
                index = length,
                args = Array(length);

              while (index--) {
                args[index] = arguments[index];
              }
              if (partials) {
                args = composeArgs(args, partials, holders);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight);
              }
              if (isCurry || isCurryRight) {
                var placeholder = wrapper.placeholder,
                  argsHolders = replaceHolders(args, placeholder);

                length -= argsHolders.length;
                if (length < arity) {
                  var newArgPos = argPos ? arrayCopy(argPos) : null,
                    newArity = nativeMax(arity - length, 0),
                    newsHolders = isCurry ? argsHolders : null,
                    newHoldersRight = isCurry ? null : argsHolders,
                    newPartials = isCurry ? args : null,
                    newPartialsRight = isCurry ? null : args;

                  bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                  bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

                  if (!isCurryBound) {
                    bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                  }
                  var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                    result = createHybridWrapper.apply(undefined, newData);

                  if (isLaziable(func)) {
                    setData(result, newData);
                  }
                  result.placeholder = placeholder;
                  return result;
                }
              }
              var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;

              if (argPos) {
                args = reorder(args, argPos);
              }
              if (isAry && ary < args.length) {
                args.length = ary;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtorWrapper(func);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }

          /**
           * Creates the padding required for `string` based on the given `length`.
           * The `chars` string is truncated if the number of characters exceeds `length`.
           *
           * @private
           * @param {string} string The string to create padding for.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the pad for `string`.
           */
          function createPadding(string, length, chars) {
            var strLength = string.length;
            length = +length;

            if (strLength >= length || !nativeIsFinite(length)) {
              return '';
            }
            var padLength = length - strLength;
            chars = chars == null ? ' ' : (chars + '');
            return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
          }

          /**
           * Creates a function that wraps `func` and invokes it with the optional `this`
           * binding of `thisArg` and the `partials` prepended to those provided to
           * the wrapper.
           *
           * @private
           * @param {Function} func The function to partially apply arguments to.
           * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {Array} partials The arguments to prepend to those provided to the new function.
           * @returns {Function} Returns the new bound function.
           */
          function createPartialWrapper(func, bitmask, thisArg, partials) {
            var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);

            function wrapper() {
              // Avoid `arguments` object use disqualifying optimizations by
              // converting it to an array before providing it `func`.
              var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(argsLength + leftLength);

              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, args);
            }
            return wrapper;
          }

          /**
           * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
           *
           * @private
           * @param {boolean} [retHighest] Specify returning the highest qualified index.
           * @returns {Function} Returns the new index function.
           */
          function createSortedIndex(retHighest) {
            return function (array, value, iteratee, thisArg) {
              var callback = getCallback(iteratee);
              return (iteratee == null && callback === baseCallback)
                ? binaryIndex(array, value, retHighest)
                : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
            };
          }

          /**
           * Creates a function that either curries or invokes `func` with optional
           * `this` binding and partially applied arguments.
           *
           * @private
           * @param {Function|string} func The function or method name to reference.
           * @param {number} bitmask The bitmask of flags.
           *  The bitmask may be composed of the following flags:
           *     1 - `_.bind`
           *     2 - `_.bindKey`
           *     4 - `_.curry` or `_.curryRight` of a bound function
           *     8 - `_.curry`
           *    16 - `_.curryRight`
           *    32 - `_.partial`
           *    64 - `_.partialRight`
           *   128 - `_.rearg`
           *   256 - `_.ary`
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to be partially applied.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */
          function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & BIND_KEY_FLAG;
            if (!isBindKey && typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
              partials = holders = null;
            }
            length -= (holders ? holders.length : 0);
            if (bitmask & PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials,
                holdersRight = holders;

              partials = holders = null;
            }
            var data = isBindKey ? null : getData(func),
              newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

            if (data) {
              mergeData(newData, data);
              bitmask = newData[1];
              arity = newData[9];
            }
            newData[9] = arity == null
              ? (isBindKey ? 0 : func.length)
              : (nativeMax(arity - length, 0) || 0);

            if (bitmask == BIND_FLAG) {
              var result = createBindWrapper(newData[0], newData[2]);
            } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
              result = createPartialWrapper.apply(undefined, newData);
            } else {
              result = createHybridWrapper.apply(undefined, newData);
            }
            var setter = data ? baseSetData : setData;
            return setter(result, newData);
          }

          /**
           * A specialized version of `baseIsEqualDeep` for arrays with support for
           * partial deep comparisons.
           *
           * @private
           * @param {Array} array The array to compare.
           * @param {Array} other The other array to compare.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Function} [customizer] The function to customize comparing arrays.
           * @param {boolean} [isLoose] Specify performing partial comparisons.
           * @param {Array} [stackA] Tracks traversed `value` objects.
           * @param {Array} [stackB] Tracks traversed `other` objects.
           * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
           */
          function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var index = -1,
              arrLength = array.length,
              othLength = other.length;

            if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
              return false;
            }
            // Ignore non-index properties.
            while (++index < arrLength) {
              var arrValue = array[index],
                othValue = other[index],
                result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

              if (result !== undefined) {
                if (result) {
                  continue;
                }
                return false;
              }
              // Recursively compare arrays (susceptible to call stack limits).
              if (isLoose) {
                if (!arraySome(other, function (othValue) {
                  return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                })) {
                  return false;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
                return false;
              }
            }
            return true;
          }

          /**
           * A specialized version of `baseIsEqualDeep` for comparing objects of
           * the same `toStringTag`.
           *
           * **Note:** This function only supports comparing values with tags of
           * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
           *
           * @private
           * @param {Object} value The object to compare.
           * @param {Object} other The other object to compare.
           * @param {string} tag The `toStringTag` of the objects to compare.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */
          function equalByTag(object, other, tag) {
            switch (tag) {
              case boolTag:
              case dateTag:
                // Coerce dates and booleans to numbers, dates to milliseconds and booleans
                // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
                return +object == +other;

              case errorTag:
                return object.name == other.name && object.message == other.message;

              case numberTag:
                // Treat `NaN` vs. `NaN` as equal.
                return (object != +object)
                  ? other != +other
                  : object == +other;

              case regexpTag:
              case stringTag:
                // Coerce regexes to strings and treat strings primitives and string
                // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
                return object == (other + '');
            }
            return false;
          }

          /**
           * A specialized version of `baseIsEqualDeep` for objects with support for
           * partial deep comparisons.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Function} [customizer] The function to customize comparing values.
           * @param {boolean} [isLoose] Specify performing partial comparisons.
           * @param {Array} [stackA] Tracks traversed `value` objects.
           * @param {Array} [stackB] Tracks traversed `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */
          function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;

            if (objLength != othLength && !isLoose) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var skipCtor = isLoose;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key],
                othValue = other[key],
                result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;

              // Recursively compare objects (susceptible to call stack limits).
              if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
                return false;
              }
              skipCtor || (skipCtor = key == 'constructor');
            }
            if (!skipCtor) {
              var objCtor = object.constructor,
                othCtor = other.constructor;

              // Non `Object` object instances with different constructors are not equal.
              if (objCtor != othCtor &&
                ('constructor' in object && 'constructor' in other) &&
                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                  typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                return false;
              }
            }
            return true;
          }

          /**
           * Gets the appropriate "callback" function. If the `_.callback` method is
           * customized this function returns the custom method, otherwise it returns
           * the `baseCallback` function. If arguments are provided the chosen function
           * is invoked with them and its result is returned.
           *
           * @private
           * @returns {Function} Returns the chosen function or its result.
           */
          function getCallback(func, thisArg, argCount) {
            var result = lodash.callback || callback;
            result = result === callback ? baseCallback : result;
            return argCount ? result(func, thisArg, argCount) : result;
          }

          /**
           * Gets metadata for `func`.
           *
           * @private
           * @param {Function} func The function to query.
           * @returns {*} Returns the metadata for `func`.
           */
          var getData = !metaMap ? noop : function (func) {
            return metaMap.get(func);
          };

          /**
           * Gets the name of `func`.
           *
           * @private
           * @param {Function} func The function to query.
           * @returns {string} Returns the function name.
           */
          function getFuncName(func) {
            var result = func.name,
              array = realNames[result],
              length = array ? array.length : 0;

            while (length--) {
              var data = array[length],
                otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result;
          }

          /**
           * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
           * customized this function returns the custom method, otherwise it returns
           * the `baseIndexOf` function. If arguments are provided the chosen function
           * is invoked with them and its result is returned.
           *
           * @private
           * @returns {Function|number} Returns the chosen function or its result.
           */
          function getIndexOf(collection, target, fromIndex) {
            var result = lodash.indexOf || indexOf;
            result = result === indexOf ? baseIndexOf : result;
            return collection ? result(collection, target, fromIndex) : result;
          }

          /**
           * Gets the "length" property value of `object`.
           *
           * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
           * that affects Safari on at least iOS 8.1-8.3 ARM64.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {*} Returns the "length" value.
           */
          var getLength = baseProperty('length');

          /**
           * Gets the propery names, values, and compare flags of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the match data of `object`.
           */
          function getMatchData(object) {
            var result = pairs(object),
              length = result.length;

            while (length--) {
              result[length][2] = isStrictComparable(result[length][1]);
            }
            return result;
          }

          /**
           * Gets the native function at `key` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the method to get.
           * @returns {*} Returns the function if it's native, else `undefined`.
           */
          function getNative(object, key) {
            var value = object == null ? undefined : object[key];
            return isNative(value) ? value : undefined;
          }

          /**
           * Gets the view, applying any `transforms` to the `start` and `end` positions.
           *
           * @private
           * @param {number} start The start of the view.
           * @param {number} end The end of the view.
           * @param {Array} [transforms] The transformations to apply to the view.
           * @returns {Object} Returns an object containing the `start` and `end`
           *  positions of the view.
           */
          function getView(start, end, transforms) {
            var index = -1,
              length = transforms ? transforms.length : 0;

            while (++index < length) {
              var data = transforms[index],
                size = data.size;

              switch (data.type) {
                case 'drop': start += size; break;
                case 'dropRight': end -= size; break;
                case 'take': end = nativeMin(end, start + size); break;
                case 'takeRight': start = nativeMax(start, end - size); break;
              }
            }
            return { 'start': start, 'end': end };
          }

          /**
           * Initializes an array clone.
           *
           * @private
           * @param {Array} array The array to clone.
           * @returns {Array} Returns the initialized clone.
           */
          function initCloneArray(array) {
            var length = array.length,
              result = new array.constructor(length);

            // Add array properties assigned by `RegExp#exec`.
            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
              result.index = array.index;
              result.input = array.input;
            }
            return result;
          }

          /**
           * Initializes an object clone.
           *
           * @private
           * @param {Object} object The object to clone.
           * @returns {Object} Returns the initialized clone.
           */
          function initCloneObject(object) {
            var Ctor = object.constructor;
            if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
              Ctor = Object;
            }
            return new Ctor;
          }

          /**
           * Initializes an object clone based on its `toStringTag`.
           *
           * **Note:** This function only supports cloning values with tags of
           * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
           *
           * @private
           * @param {Object} object The object to clone.
           * @param {string} tag The `toStringTag` of the object to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the initialized clone.
           */
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return bufferClone(object);

              case boolTag:
              case dateTag:
                return new Ctor(+object);

              case float32Tag: case float64Tag:
              case int8Tag: case int16Tag: case int32Tag:
              case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
                var buffer = object.buffer;
                return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

              case numberTag:
              case stringTag:
                return new Ctor(object);

              case regexpTag:
                var result = new Ctor(object.source, reFlags.exec(object));
                result.lastIndex = object.lastIndex;
            }
            return result;
          }

          /**
           * Invokes the method at `path` on `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the method to invoke.
           * @param {Array} args The arguments to invoke the method with.
           * @returns {*} Returns the result of the invoked method.
           */
          function invokePath(object, path, args) {
            if (object != null && !isKey(path, object)) {
              path = toPath(path);
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              path = last(path);
            }
            var func = object == null ? object : object[path];
            return func == null ? undefined : func.apply(object, args);
          }

          /**
           * Checks if `value` is array-like.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
           */
          function isArrayLike(value) {
            return value != null && isLength(getLength(value));
          }

          /**
           * Checks if `value` is a valid array-like index.
           *
           * @private
           * @param {*} value The value to check.
           * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
           * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
           */
          function isIndex(value, length) {
            value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return value > -1 && value % 1 == 0 && value < length;
          }

          /**
           * Checks if the provided arguments are from an iteratee call.
           *
           * @private
           * @param {*} value The potential iteratee value argument.
           * @param {*} index The potential iteratee index or key argument.
           * @param {*} object The potential iteratee object argument.
           * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
           */
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (type == 'number'
              ? (isArrayLike(object) && isIndex(index, object.length))
              : (type == 'string' && index in object)) {
              var other = object[index];
              return value === value ? (value === other) : (other !== other);
            }
            return false;
          }

          /**
           * Checks if `value` is a property name and not a property path.
           *
           * @private
           * @param {*} value The value to check.
           * @param {Object} [object] The object to query keys on.
           * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
           */
          function isKey(value, object) {
            var type = typeof value;
            if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
              return true;
            }
            if (isArray(value)) {
              return false;
            }
            var result = !reIsDeepProp.test(value);
            return result || (object != null && value in toObject(object));
          }

          /**
           * Checks if `func` has a lazy counterpart.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
           */
          function isLaziable(func) {
            var funcName = getFuncName(func);
            if (!(funcName in LazyWrapper.prototype)) {
              return false;
            }
            var other = lodash[funcName];
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }

          /**
           * Checks if `value` is a valid array-like length.
           *
           * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
           */
          function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }

          /**
           * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` if suitable for strict
           *  equality comparisons, else `false`.
           */
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }

          /**
           * Merges the function metadata of `source` into `data`.
           *
           * Merging metadata reduces the number of wrappers required to invoke a function.
           * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
           * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
           * augment function arguments, making the order in which they are executed important,
           * preventing the merging of metadata. However, we make an exception for a safe
           * common case where curried functions have `_.ary` and or `_.rearg` applied.
           *
           * @private
           * @param {Array} data The destination metadata.
           * @param {Array} source The source metadata.
           * @returns {Array} Returns `data`.
           */
          function mergeData(data, source) {
            var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < ARY_FLAG;

            var isCombo =
              (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
              (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
              (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

            // Exit early if metadata can't be merged.
            if (!(isCommon || isCombo)) {
              return data;
            }
            // Use source `thisArg` if available.
            if (srcBitmask & BIND_FLAG) {
              data[2] = source[2];
              // Set when currying a bound function.
              newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
            }
            // Compose partial arguments.
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
            }
            // Compose partial right arguments.
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
            }
            // Use source `argPos` if available.
            value = source[7];
            if (value) {
              data[7] = arrayCopy(value);
            }
            // Use source `ary` if it's smaller.
            if (srcBitmask & ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            // Use source `arity` if one is not provided.
            if (data[9] == null) {
              data[9] = source[9];
            }
            // Use source `func` and merge bitmasks.
            data[0] = source[0];
            data[1] = newBitmask;

            return data;
          }

          /**
           * A specialized version of `_.pick` which picks `object` properties specified
           * by `props`.
           *
           * @private
           * @param {Object} object The source object.
           * @param {string[]} props The property names to pick.
           * @returns {Object} Returns the new object.
           */
          function pickByArray(object, props) {
            object = toObject(object);

            var index = -1,
              length = props.length,
              result = {};

            while (++index < length) {
              var key = props[index];
              if (key in object) {
                result[key] = object[key];
              }
            }
            return result;
          }

          /**
           * A specialized version of `_.pick` which picks `object` properties `predicate`
           * returns truthy for.
           *
           * @private
           * @param {Object} object The source object.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {Object} Returns the new object.
           */
          function pickByCallback(object, predicate) {
            var result = {};
            baseForIn(object, function (value, key, object) {
              if (predicate(value, key, object)) {
                result[key] = value;
              }
            });
            return result;
          }

          /**
           * Reorder `array` according to the specified indexes where the element at
           * the first index is assigned as the first element, the element at
           * the second index is assigned as the second element, and so on.
           *
           * @private
           * @param {Array} array The array to reorder.
           * @param {Array} indexes The arranged array indexes.
           * @returns {Array} Returns `array`.
           */
          function reorder(array, indexes) {
            var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = arrayCopy(array);

            while (length--) {
              var index = indexes[length];
              array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }
            return array;
          }

          /**
           * Sets metadata for `func`.
           *
           * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
           * period of time, it will trip its breaker and transition to an identity function
           * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
           * for more details.
           *
           * @private
           * @param {Function} func The function to associate metadata with.
           * @param {*} data The metadata.
           * @returns {Function} Returns `func`.
           */
          var setData = (function () {
            var count = 0,
              lastCalled = 0;

            return function (key, value) {
              var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);

              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return key;
                }
              } else {
                count = 0;
              }
              return baseSetData(key, value);
            };
          }());

          /**
           * A fallback implementation of `_.isPlainObject` which checks if `value`
           * is an object created by the `Object` constructor or has a `[[Prototype]]`
           * of `null`.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           */
          function shimIsPlainObject(value) {
            var Ctor,
              support = lodash.support;

            // Exit early for non `Object` objects.
            if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||
              (!hasOwnProperty.call(value, 'constructor') &&
                (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
              return false;
            }
            // IE < 9 iterates inherited properties before own properties. If the first
            // iterated property is an object's own property then there are no inherited
            // enumerable properties.
            var result;
            // In most environments an object's own properties are iterated before
            // its inherited properties. If the last iterated property is an object's
            // own property then there are no inherited enumerable properties.
            baseForIn(value, function (subValue, key) {
              result = key;
            });
            return result === undefined || hasOwnProperty.call(value, result);
          }

          /**
           * A fallback implementation of `Object.keys` which creates an array of the
           * own enumerable property names of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function shimKeys(object) {
            var props = keysIn(object),
              propsLength = props.length,
              length = propsLength && object.length;

            var allowIndexes = !!length && isLength(length) &&
              (isArray(object) || isArguments(object));

            var index = -1,
              result = [];

            while (++index < propsLength) {
              var key = props[index];
              if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * Converts `value` to an array-like object if it's not one.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {Array|Object} Returns the array-like object.
           */
          function toIterable(value) {
            if (value == null) {
              return [];
            }
            if (!isArrayLike(value)) {
              return values(value);
            }
            return isObject(value) ? value : Object(value);
          }

          /**
           * Converts `value` to an object if it's not one.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {Object} Returns the object.
           */
          function toObject(value) {
            return isObject(value) ? value : Object(value);
          }

          /**
           * Converts `value` to property path array if it's not one.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {Array} Returns the property path array.
           */
          function toPath(value) {
            if (isArray(value)) {
              return value;
            }
            var result = [];
            baseToString(value).replace(rePropName, function (match, number, quote, string) {
              result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
            });
            return result;
          }

          /**
           * Creates a clone of `wrapper`.
           *
           * @private
           * @param {Object} wrapper The wrapper to clone.
           * @returns {Object} Returns the cloned wrapper.
           */
          function wrapperClone(wrapper) {
            return wrapper instanceof LazyWrapper
              ? wrapper.clone()
              : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
          }

          /*------------------------------------------------------------------------*/

          /**
           * Creates an array of elements split into groups the length of `size`.
           * If `collection` can't be split evenly, the final chunk will be the remaining
           * elements.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to process.
           * @param {number} [size=1] The length of each chunk.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Array} Returns the new array containing chunks.
           * @example
           *
           * _.chunk(['a', 'b', 'c', 'd'], 2);
           * // => [['a', 'b'], ['c', 'd']]
           *
           * _.chunk(['a', 'b', 'c', 'd'], 3);
           * // => [['a', 'b', 'c'], ['d']]
           */
          function chunk(array, size, guard) {
            if (guard ? isIterateeCall(array, size, guard) : size == null) {
              size = 1;
            } else {
              size = nativeMax(+size || 1, 1);
            }
            var index = 0,
              length = array ? array.length : 0,
              resIndex = -1,
              result = Array(ceil(length / size));

            while (index < length) {
              result[++resIndex] = baseSlice(array, index, (index += size));
            }
            return result;
          }

          /**
           * Creates an array with all falsey values removed. The values `false`, `null`,
           * `0`, `""`, `undefined`, and `NaN` are falsey.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to compact.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.compact([0, 1, false, 2, '', 3]);
           * // => [1, 2, 3]
           */
          function compact(array) {
            var index = -1,
              length = array ? array.length : 0,
              resIndex = -1,
              result = [];

            while (++index < length) {
              var value = array[index];
              if (value) {
                result[++resIndex] = value;
              }
            }
            return result;
          }

          /**
           * Creates an array of unique `array` values not included in the other
           * provided arrays using [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
           * for equality comparisons.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...Array} [values] The arrays of values to exclude.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.difference([1, 2, 3], [4, 2]);
           * // => [1, 3]
           */
          var difference = restParam(function (array, values) {
            return isArrayLike(array)
              ? baseDifference(array, baseFlatten(values, false, true))
              : [];
          });

          /**
           * Creates a slice of `array` with `n` elements dropped from the beginning.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to drop.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.drop([1, 2, 3]);
           * // => [2, 3]
           *
           * _.drop([1, 2, 3], 2);
           * // => [3]
           *
           * _.drop([1, 2, 3], 5);
           * // => []
           *
           * _.drop([1, 2, 3], 0);
           * // => [1, 2, 3]
           */
          function drop(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
              n = 1;
            }
            return baseSlice(array, n < 0 ? 0 : n);
          }

          /**
           * Creates a slice of `array` with `n` elements dropped from the end.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to drop.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.dropRight([1, 2, 3]);
           * // => [1, 2]
           *
           * _.dropRight([1, 2, 3], 2);
           * // => [1]
           *
           * _.dropRight([1, 2, 3], 5);
           * // => []
           *
           * _.dropRight([1, 2, 3], 0);
           * // => [1, 2, 3]
           */
          function dropRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
              n = 1;
            }
            n = length - (+n || 0);
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }

          /**
           * Creates a slice of `array` excluding elements dropped from the end.
           * Elements are dropped until `predicate` returns falsey. The predicate is
           * bound to `thisArg` and invoked with three arguments: (value, index, array).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that match the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.dropRightWhile([1, 2, 3], function(n) {
           *   return n > 1;
           * });
           * // => [1]
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
           * // => ['barney', 'fred']
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
           * // => ['barney']
           *
           * // using the `_.property` callback shorthand
           * _.pluck(_.dropRightWhile(users, 'active'), 'user');
           * // => ['barney', 'fred', 'pebbles']
           */
          function dropRightWhile(array, predicate, thisArg) {
            return (array && array.length)
              ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
              : [];
          }

          /**
           * Creates a slice of `array` excluding elements dropped from the beginning.
           * Elements are dropped until `predicate` returns falsey. The predicate is
           * bound to `thisArg` and invoked with three arguments: (value, index, array).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.dropWhile([1, 2, 3], function(n) {
           *   return n < 3;
           * });
           * // => [3]
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
           * // => ['fred', 'pebbles']
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.pluck(_.dropWhile(users, 'active', false), 'user');
           * // => ['pebbles']
           *
           * // using the `_.property` callback shorthand
           * _.pluck(_.dropWhile(users, 'active'), 'user');
           * // => ['barney', 'fred', 'pebbles']
           */
          function dropWhile(array, predicate, thisArg) {
            return (array && array.length)
              ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
              : [];
          }

          /**
           * Fills elements of `array` with `value` from `start` up to, but not
           * including, `end`.
           *
           * **Note:** This method mutates `array`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to fill.
           * @param {*} value The value to fill `array` with.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _.fill(array, 'a');
           * console.log(array);
           * // => ['a', 'a', 'a']
           *
           * _.fill(Array(3), 2);
           * // => [2, 2, 2]
           *
           * _.fill([4, 6, 8], '*', 1, 2);
           * // => [4, '*', 8]
           */
          function fill(array, value, start, end) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array, value, start, end);
          }

          /**
           * This method is like `_.find` except that it returns the index of the first
           * element `predicate` returns truthy for instead of the element itself.
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to search.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * _.findIndex(users, function(chr) {
           *   return chr.user == 'barney';
           * });
           * // => 0
           *
           * // using the `_.matches` callback shorthand
           * _.findIndex(users, { 'user': 'fred', 'active': false });
           * // => 1
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.findIndex(users, 'active', false);
           * // => 0
           *
           * // using the `_.property` callback shorthand
           * _.findIndex(users, 'active');
           * // => 2
           */
          var findIndex = createFindIndex();

          /**
           * This method is like `_.findIndex` except that it iterates over elements
           * of `collection` from right to left.
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to search.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * _.findLastIndex(users, function(chr) {
           *   return chr.user == 'pebbles';
           * });
           * // => 2
           *
           * // using the `_.matches` callback shorthand
           * _.findLastIndex(users, { 'user': 'barney', 'active': true });
           * // => 0
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.findLastIndex(users, 'active', false);
           * // => 2
           *
           * // using the `_.property` callback shorthand
           * _.findLastIndex(users, 'active');
           * // => 0
           */
          var findLastIndex = createFindIndex(true);

          /**
           * Gets the first element of `array`.
           *
           * @static
           * @memberOf _
           * @alias head
           * @category Array
           * @param {Array} array The array to query.
           * @returns {*} Returns the first element of `array`.
           * @example
           *
           * _.first([1, 2, 3]);
           * // => 1
           *
           * _.first([]);
           * // => undefined
           */
          function first(array) {
            return array ? array[0] : undefined;
          }

          /**
           * Flattens a nested array. If `isDeep` is `true` the array is recursively
           * flattened, otherwise it is only flattened a single level.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to flatten.
           * @param {boolean} [isDeep] Specify a deep flatten.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * _.flatten([1, [2, 3, [4]]]);
           * // => [1, 2, 3, [4]]
           *
           * // using `isDeep`
           * _.flatten([1, [2, 3, [4]]], true);
           * // => [1, 2, 3, 4]
           */
          function flatten(array, isDeep, guard) {
            var length = array ? array.length : 0;
            if (guard && isIterateeCall(array, isDeep, guard)) {
              isDeep = false;
            }
            return length ? baseFlatten(array, isDeep) : [];
          }

          /**
           * Recursively flattens a nested array.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to recursively flatten.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * _.flattenDeep([1, [2, 3, [4]]]);
           * // => [1, 2, 3, 4]
           */
          function flattenDeep(array) {
            var length = array ? array.length : 0;
            return length ? baseFlatten(array, true) : [];
          }

          /**
           * Gets the index at which the first occurrence of `value` is found in `array`
           * using [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
           * for equality comparisons. If `fromIndex` is negative, it is used as the offset
           * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
           * performs a faster binary search.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to search.
           * @param {*} value The value to search for.
           * @param {boolean|number} [fromIndex=0] The index to search from or `true`
           *  to perform a binary search on a sorted array.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.indexOf([1, 2, 1, 2], 2);
           * // => 1
           *
           * // using `fromIndex`
           * _.indexOf([1, 2, 1, 2], 2, 2);
           * // => 3
           *
           * // performing a binary search
           * _.indexOf([1, 1, 2, 2], 2, true);
           * // => 2
           */
          function indexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) {
              return -1;
            }
            if (typeof fromIndex == 'number') {
              fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
            } else if (fromIndex) {
              var index = binaryIndex(array, value),
                other = array[index];

              if (value === value ? (value === other) : (other !== other)) {
                return index;
              }
              return -1;
            }
            return baseIndexOf(array, value, fromIndex || 0);
          }

          /**
           * Gets all but the last element of `array`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.initial([1, 2, 3]);
           * // => [1, 2]
           */
          function initial(array) {
            return dropRight(array, 1);
          }

          /**
           * Creates an array of unique values that are included in all of the provided
           * arrays using [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
           * for equality comparisons.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of shared values.
           * @example
           * _.intersection([1, 2], [4, 2], [2, 1]);
           * // => [2]
           */
          var intersection = restParam(function (arrays) {
            var othLength = arrays.length,
              othIndex = othLength,
              caches = Array(length),
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              result = [];

            while (othIndex--) {
              var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
              caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
            }
            var array = arrays[0],
              index = -1,
              length = array ? array.length : 0,
              seen = caches[0];

            outer:
            while (++index < length) {
              value = array[index];
              if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
                var othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(value);
                }
                result.push(value);
              }
            }
            return result;
          });

          /**
           * Gets the last element of `array`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @returns {*} Returns the last element of `array`.
           * @example
           *
           * _.last([1, 2, 3]);
           * // => 3
           */
          function last(array) {
            var length = array ? array.length : 0;
            return length ? array[length - 1] : undefined;
          }

          /**
           * This method is like `_.indexOf` except that it iterates over elements of
           * `array` from right to left.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to search.
           * @param {*} value The value to search for.
           * @param {boolean|number} [fromIndex=array.length-1] The index to search from
           *  or `true` to perform a binary search on a sorted array.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.lastIndexOf([1, 2, 1, 2], 2);
           * // => 3
           *
           * // using `fromIndex`
           * _.lastIndexOf([1, 2, 1, 2], 2, 2);
           * // => 1
           *
           * // performing a binary search
           * _.lastIndexOf([1, 1, 2, 2], 2, true);
           * // => 3
           */
          function lastIndexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) {
              return -1;
            }
            var index = length;
            if (typeof fromIndex == 'number') {
              index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
            } else if (fromIndex) {
              index = binaryIndex(array, value, true) - 1;
              var other = array[index];
              if (value === value ? (value === other) : (other !== other)) {
                return index;
              }
              return -1;
            }
            if (value !== value) {
              return indexOfNaN(array, index, true);
            }
            while (index--) {
              if (array[index] === value) {
                return index;
              }
            }
            return -1;
          }

          /**
           * Removes all provided values from `array` using
           * [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
           * for equality comparisons.
           *
           * **Note:** Unlike `_.without`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to modify.
           * @param {...*} [values] The values to remove.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [1, 2, 3, 1, 2, 3];
           *
           * _.pull(array, 2, 3);
           * console.log(array);
           * // => [1, 1]
           */
          function pull() {
            var args = arguments,
              array = args[0];

            if (!(array && array.length)) {
              return array;
            }
            var index = 0,
              indexOf = getIndexOf(),
              length = args.length;

            while (++index < length) {
              var fromIndex = 0,
                value = args[index];

              while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }

          /**
           * Removes elements from `array` corresponding to the given indexes and returns
           * an array of the removed elements. Indexes may be specified as an array of
           * indexes or as individual arguments.
           *
           * **Note:** Unlike `_.at`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to modify.
           * @param {...(number|number[])} [indexes] The indexes of elements to remove,
           *  specified as individual indexes or arrays of indexes.
           * @returns {Array} Returns the new array of removed elements.
           * @example
           *
           * var array = [5, 10, 15, 20];
           * var evens = _.pullAt(array, 1, 3);
           *
           * console.log(array);
           * // => [5, 15]
           *
           * console.log(evens);
           * // => [10, 20]
           */
          var pullAt = restParam(function (array, indexes) {
            indexes = baseFlatten(indexes);

            var result = baseAt(array, indexes);
            basePullAt(array, indexes.sort(baseCompareAscending));
            return result;
          });

          /**
           * Removes all elements from `array` that `predicate` returns truthy for
           * and returns an array of the removed elements. The predicate is bound to
           * `thisArg` and invoked with three arguments: (value, index, array).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * **Note:** Unlike `_.filter`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the new array of removed elements.
           * @example
           *
           * var array = [1, 2, 3, 4];
           * var evens = _.remove(array, function(n) {
           *   return n % 2 == 0;
           * });
           *
           * console.log(array);
           * // => [1, 3]
           *
           * console.log(evens);
           * // => [2, 4]
           */
          function remove(array, predicate, thisArg) {
            var result = [];
            if (!(array && array.length)) {
              return result;
            }
            var index = -1,
              indexes = [],
              length = array.length;

            predicate = getCallback(predicate, thisArg, 3);
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result;
          }

          /**
           * Gets all but the first element of `array`.
           *
           * @static
           * @memberOf _
           * @alias tail
           * @category Array
           * @param {Array} array The array to query.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.rest([1, 2, 3]);
           * // => [2, 3]
           */
          function rest(array) {
            return drop(array, 1);
          }

          /**
           * Creates a slice of `array` from `start` up to, but not including, `end`.
           *
           * **Note:** This method is used instead of `Array#slice` to support node
           * lists in IE < 9 and to ensure dense arrays are returned.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to slice.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the slice of `array`.
           */
          function slice(array, start, end) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            }
            return baseSlice(array, start, end);
          }

          /**
           * Uses a binary search to determine the lowest index at which `value` should
           * be inserted into `array` in order to maintain its sort order. If an iteratee
           * function is provided it is invoked for `value` and each element of `array`
           * to compute their sort ranking. The iteratee is bound to `thisArg` and
           * invoked with one argument; (value).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * _.sortedIndex([30, 50], 40);
           * // => 1
           *
           * _.sortedIndex([4, 4, 5, 5], 5);
           * // => 2
           *
           * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
           *
           * // using an iteratee function
           * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
           *   return this.data[word];
           * }, dict);
           * // => 1
           *
           * // using the `_.property` callback shorthand
           * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
           * // => 1
           */
          var sortedIndex = createSortedIndex();

          /**
           * This method is like `_.sortedIndex` except that it returns the highest
           * index at which `value` should be inserted into `array` in order to
           * maintain its sort order.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * _.sortedLastIndex([4, 4, 5, 5], 5);
           * // => 4
           */
          var sortedLastIndex = createSortedIndex(true);

          /**
           * Creates a slice of `array` with `n` elements taken from the beginning.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to take.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.take([1, 2, 3]);
           * // => [1]
           *
           * _.take([1, 2, 3], 2);
           * // => [1, 2]
           *
           * _.take([1, 2, 3], 5);
           * // => [1, 2, 3]
           *
           * _.take([1, 2, 3], 0);
           * // => []
           */
          function take(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
              n = 1;
            }
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }

          /**
           * Creates a slice of `array` with `n` elements taken from the end.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to take.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.takeRight([1, 2, 3]);
           * // => [3]
           *
           * _.takeRight([1, 2, 3], 2);
           * // => [2, 3]
           *
           * _.takeRight([1, 2, 3], 5);
           * // => [1, 2, 3]
           *
           * _.takeRight([1, 2, 3], 0);
           * // => []
           */
          function takeRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
              n = 1;
            }
            n = length - (+n || 0);
            return baseSlice(array, n < 0 ? 0 : n);
          }

          /**
           * Creates a slice of `array` with elements taken from the end. Elements are
           * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
           * and invoked with three arguments: (value, index, array).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.takeRightWhile([1, 2, 3], function(n) {
           *   return n > 1;
           * });
           * // => [2, 3]
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
           * // => ['pebbles']
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
           * // => ['fred', 'pebbles']
           *
           * // using the `_.property` callback shorthand
           * _.pluck(_.takeRightWhile(users, 'active'), 'user');
           * // => []
           */
          function takeRightWhile(array, predicate, thisArg) {
            return (array && array.length)
              ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
              : [];
          }

          /**
           * Creates a slice of `array` with elements taken from the beginning. Elements
           * are taken until `predicate` returns falsey. The predicate is bound to
           * `thisArg` and invoked with three arguments: (value, index, array).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.takeWhile([1, 2, 3], function(n) {
           *   return n < 3;
           * });
           * // => [1, 2]
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false},
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
           * // => ['barney']
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.pluck(_.takeWhile(users, 'active', false), 'user');
           * // => ['barney', 'fred']
           *
           * // using the `_.property` callback shorthand
           * _.pluck(_.takeWhile(users, 'active'), 'user');
           * // => []
           */
          function takeWhile(array, predicate, thisArg) {
            return (array && array.length)
              ? baseWhile(array, getCallback(predicate, thisArg, 3))
              : [];
          }

          /**
           * Creates an array of unique values, in order, from all of the provided arrays
           * using [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
           * for equality comparisons.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of combined values.
           * @example
           *
           * _.union([1, 2], [4, 2], [2, 1]);
           * // => [1, 2, 4]
           */
          var union = restParam(function (arrays) {
            return baseUniq(baseFlatten(arrays, false, true));
          });

          /**
           * Creates a duplicate-free version of an array, using
           * [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
           * for equality comparisons, in which only the first occurence of each element
           * is kept. Providing `true` for `isSorted` performs a faster search algorithm
           * for sorted arrays. If an iteratee function is provided it is invoked for
           * each element in the array to generate the criterion by which uniqueness
           * is computed. The `iteratee` is bound to `thisArg` and invoked with three
           * arguments: (value, index, array).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @alias unique
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {boolean} [isSorted] Specify the array is sorted.
           * @param {Function|Object|string} [iteratee] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array} Returns the new duplicate-value-free array.
           * @example
           *
           * _.uniq([2, 1, 2]);
           * // => [2, 1]
           *
           * // using `isSorted`
           * _.uniq([1, 1, 2], true);
           * // => [1, 2]
           *
           * // using an iteratee function
           * _.uniq([1, 2.5, 1.5, 2], function(n) {
           *   return this.floor(n);
           * }, Math);
           * // => [1, 2.5]
           *
           * // using the `_.property` callback shorthand
           * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }, { 'x': 2 }]
           */
          function uniq(array, isSorted, iteratee, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            if (isSorted != null && typeof isSorted != 'boolean') {
              thisArg = iteratee;
              iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
              isSorted = false;
            }
            var callback = getCallback();
            if (!(iteratee == null && callback === baseCallback)) {
              iteratee = callback(iteratee, thisArg, 3);
            }
            return (isSorted && getIndexOf() == baseIndexOf)
              ? sortedUniq(array, iteratee)
              : baseUniq(array, iteratee);
          }

          /**
           * This method is like `_.zip` except that it accepts an array of grouped
           * elements and creates an array regrouping the elements to their pre-zip
           * configuration.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array of grouped elements to process.
           * @returns {Array} Returns the new array of regrouped elements.
           * @example
           *
           * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
           * // => [['fred', 30, true], ['barney', 40, false]]
           *
           * _.unzip(zipped);
           * // => [['fred', 'barney'], [30, 40], [true, false]]
           */
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var index = -1,
              length = 0;

            array = arrayFilter(array, function (group) {
              if (isArrayLike(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            var result = Array(length);
            while (++index < length) {
              result[index] = arrayMap(array, baseProperty(index));
            }
            return result;
          }

          /**
           * This method is like `_.unzip` except that it accepts an iteratee to specify
           * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
           * and invoked with four arguments: (accumulator, value, index, group).
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array of grouped elements to process.
           * @param {Function} [iteratee] The function to combine regrouped values.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array} Returns the new array of regrouped elements.
           * @example
           *
           * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
           * // => [[1, 10, 100], [2, 20, 200]]
           *
           * _.unzipWith(zipped, _.add);
           * // => [3, 30, 300]
           */
          function unzipWith(array, iteratee, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            var result = unzip(array);
            if (iteratee == null) {
              return result;
            }
            iteratee = bindCallback(iteratee, thisArg, 4);
            return arrayMap(result, function (group) {
              return arrayReduce(group, iteratee, undefined, true);
            });
          }

          /**
           * Creates an array excluding all provided values using
           * [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
           * for equality comparisons.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to filter.
           * @param {...*} [values] The values to exclude.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.without([1, 2, 1, 3], 1, 2);
           * // => [3]
           */
          var without = restParam(function (array, values) {
            return isArrayLike(array)
              ? baseDifference(array, values)
              : [];
          });

          /**
           * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
           * of the provided arrays.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of values.
           * @example
           *
           * _.xor([1, 2], [4, 2]);
           * // => [1, 4]
           */
          function xor() {
            var index = -1,
              length = arguments.length;

            while (++index < length) {
              var array = arguments[index];
              if (isArrayLike(array)) {
                var result = result
                  ? baseDifference(result, array).concat(baseDifference(array, result))
                  : array;
              }
            }
            return result ? baseUniq(result) : [];
          }

          /**
           * Creates an array of grouped elements, the first of which contains the first
           * elements of the given arrays, the second of which contains the second elements
           * of the given arrays, and so on.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {...Array} [arrays] The arrays to process.
           * @returns {Array} Returns the new array of grouped elements.
           * @example
           *
           * _.zip(['fred', 'barney'], [30, 40], [true, false]);
           * // => [['fred', 30, true], ['barney', 40, false]]
           */
          var zip = restParam(unzip);

          /**
           * The inverse of `_.pairs`; this method returns an object composed from arrays
           * of property names and values. Provide either a single two dimensional array,
           * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
           * and one of corresponding values.
           *
           * @static
           * @memberOf _
           * @alias object
           * @category Array
           * @param {Array} props The property names.
           * @param {Array} [values=[]] The property values.
           * @returns {Object} Returns the new object.
           * @example
           *
           * _.zipObject([['fred', 30], ['barney', 40]]);
           * // => { 'fred': 30, 'barney': 40 }
           *
           * _.zipObject(['fred', 'barney'], [30, 40]);
           * // => { 'fred': 30, 'barney': 40 }
           */
          function zipObject(props, values) {
            var index = -1,
              length = props ? props.length : 0,
              result = {};

            if (length && !values && !isArray(props[0])) {
              values = [];
            }
            while (++index < length) {
              var key = props[index];
              if (values) {
                result[key] = values[index];
              } else if (key) {
                result[key[0]] = key[1];
              }
            }
            return result;
          }

          /**
           * This method is like `_.zip` except that it accepts an iteratee to specify
           * how grouped values should be combined. The `iteratee` is bound to `thisArg`
           * and invoked with four arguments: (accumulator, value, index, group).
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {...Array} [arrays] The arrays to process.
           * @param {Function} [iteratee] The function to combine grouped values.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array} Returns the new array of grouped elements.
           * @example
           *
           * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
           * // => [111, 222]
           */
          var zipWith = restParam(function (arrays) {
            var length = arrays.length,
              iteratee = length > 2 ? arrays[length - 2] : undefined,
              thisArg = length > 1 ? arrays[length - 1] : undefined;

            if (length > 2 && typeof iteratee == 'function') {
              length -= 2;
            } else {
              iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
              thisArg = undefined;
            }
            arrays.length = length;
            return unzipWith(arrays, iteratee, thisArg);
          });

          /*------------------------------------------------------------------------*/

          /**
           * Creates a `lodash` object that wraps `value` with explicit method
           * chaining enabled.
           *
           * @static
           * @memberOf _
           * @category Chain
           * @param {*} value The value to wrap.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36 },
           *   { 'user': 'fred',    'age': 40 },
           *   { 'user': 'pebbles', 'age': 1 }
           * ];
           *
           * var youngest = _.chain(users)
           *   .sortBy('age')
           *   .map(function(chr) {
           *     return chr.user + ' is ' + chr.age;
           *   })
           *   .first()
           *   .value();
           * // => 'pebbles is 1'
           */
          function chain(value) {
            var result = lodash(value);
            result.__chain__ = true;
            return result;
          }

          /**
           * This method invokes `interceptor` and returns `value`. The interceptor is
           * bound to `thisArg` and invoked with one argument; (value). The purpose of
           * this method is to "tap into" a method chain in order to perform operations
           * on intermediate results within the chain.
           *
           * @static
           * @memberOf _
           * @category Chain
           * @param {*} value The value to provide to `interceptor`.
           * @param {Function} interceptor The function to invoke.
           * @param {*} [thisArg] The `this` binding of `interceptor`.
           * @returns {*} Returns `value`.
           * @example
           *
           * _([1, 2, 3])
           *  .tap(function(array) {
           *    array.pop();
           *  })
           *  .reverse()
           *  .value();
           * // => [2, 1]
           */
          function tap(value, interceptor, thisArg) {
            interceptor.call(thisArg, value);
            return value;
          }

          /**
           * This method is like `_.tap` except that it returns the result of `interceptor`.
           *
           * @static
           * @memberOf _
           * @category Chain
           * @param {*} value The value to provide to `interceptor`.
           * @param {Function} interceptor The function to invoke.
           * @param {*} [thisArg] The `this` binding of `interceptor`.
           * @returns {*} Returns the result of `interceptor`.
           * @example
           *
           * _('  abc  ')
           *  .chain()
           *  .trim()
           *  .thru(function(value) {
           *    return [value];
           *  })
           *  .value();
           * // => ['abc']
           */
          function thru(value, interceptor, thisArg) {
            return interceptor.call(thisArg, value);
          }

          /**
           * Enables explicit method chaining on the wrapper object.
           *
           * @name chain
           * @memberOf _
           * @category Chain
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 40 }
           * ];
           *
           * // without explicit chaining
           * _(users).first();
           * // => { 'user': 'barney', 'age': 36 }
           *
           * // with explicit chaining
           * _(users).chain()
           *   .first()
           *   .pick('user')
           *   .value();
           * // => { 'user': 'barney' }
           */
          function wrapperChain() {
            return chain(this);
          }

          /**
           * Executes the chained sequence and returns the wrapped result.
           *
           * @name commit
           * @memberOf _
           * @category Chain
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var array = [1, 2];
           * var wrapper = _(array).push(3);
           *
           * console.log(array);
           * // => [1, 2]
           *
           * wrapper = wrapper.commit();
           * console.log(array);
           * // => [1, 2, 3]
           *
           * wrapper.last();
           * // => 3
           *
           * console.log(array);
           * // => [1, 2, 3]
           */
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }

          /**
           * Creates a clone of the chained sequence planting `value` as the wrapped value.
           *
           * @name plant
           * @memberOf _
           * @category Chain
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var array = [1, 2];
           * var wrapper = _(array).map(function(value) {
           *   return Math.pow(value, 2);
           * });
           *
           * var other = [3, 4];
           * var otherWrapper = wrapper.plant(other);
           *
           * otherWrapper.value();
           * // => [9, 16]
           *
           * wrapper.value();
           * // => [1, 4]
           */
          function wrapperPlant(value) {
            var result,
              parent = this;

            while (parent instanceof baseLodash) {
              var clone = wrapperClone(parent);
              if (result) {
                previous.__wrapped__ = clone;
              } else {
                result = clone;
              }
              var previous = clone;
              parent = parent.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result;
          }

          /**
           * Reverses the wrapped array so the first element becomes the last, the
           * second element becomes the second to last, and so on.
           *
           * **Note:** This method mutates the wrapped array.
           *
           * @name reverse
           * @memberOf _
           * @category Chain
           * @returns {Object} Returns the new reversed `lodash` wrapper instance.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _(array).reverse().value()
           * // => [3, 2, 1]
           *
           * console.log(array);
           * // => [3, 2, 1]
           */
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              if (this.__actions__.length) {
                value = new LazyWrapper(this);
              }
              return new LodashWrapper(value.reverse(), this.__chain__);
            }
            return this.thru(function (value) {
              return value.reverse();
            });
          }

          /**
           * Produces the result of coercing the unwrapped value to a string.
           *
           * @name toString
           * @memberOf _
           * @category Chain
           * @returns {string} Returns the coerced string value.
           * @example
           *
           * _([1, 2, 3]).toString();
           * // => '1,2,3'
           */
          function wrapperToString() {
            return (this.value() + '');
          }

          /**
           * Executes the chained sequence to extract the unwrapped value.
           *
           * @name value
           * @memberOf _
           * @alias run, toJSON, valueOf
           * @category Chain
           * @returns {*} Returns the resolved unwrapped value.
           * @example
           *
           * _([1, 2, 3]).value();
           * // => [1, 2, 3]
           */
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }

          /*------------------------------------------------------------------------*/

          /**
           * Creates an array of elements corresponding to the given keys, or indexes,
           * of `collection`. Keys may be specified as individual arguments or as arrays
           * of keys.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {...(number|number[]|string|string[])} [props] The property names
           *  or indexes of elements to pick, specified individually or in arrays.
           * @returns {Array} Returns the new array of picked elements.
           * @example
           *
           * _.at(['a', 'b', 'c'], [0, 2]);
           * // => ['a', 'c']
           *
           * _.at(['barney', 'fred', 'pebbles'], 0, 2);
           * // => ['barney', 'pebbles']
           */
          var at = restParam(function (collection, props) {
            return baseAt(collection, baseFlatten(props));
          });

          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` through `iteratee`. The corresponding value
           * of each key is the number of times the key was returned by `iteratee`.
           * The `iteratee` is bound to `thisArg` and invoked with three arguments:
           * (value, index|key, collection).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.countBy([4.3, 6.1, 6.4], function(n) {
           *   return Math.floor(n);
           * });
           * // => { '4': 1, '6': 2 }
           *
           * _.countBy([4.3, 6.1, 6.4], function(n) {
           *   return this.floor(n);
           * }, Math);
           * // => { '4': 1, '6': 2 }
           *
           * _.countBy(['one', 'two', 'three'], 'length');
           * // => { '3': 2, '5': 1 }
           */
          var countBy = createAggregator(function (result, value, key) {
            hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
          });

          /**
           * Checks if `predicate` returns truthy for **all** elements of `collection`.
           * The predicate is bound to `thisArg` and invoked with three arguments:
           * (value, index|key, collection).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @alias all
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {boolean} Returns `true` if all elements pass the predicate check,
           *  else `false`.
           * @example
           *
           * _.every([true, 1, null, 'yes'], Boolean);
           * // => false
           *
           * var users = [
           *   { 'user': 'barney', 'active': false },
           *   { 'user': 'fred',   'active': false }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.every(users, { 'user': 'barney', 'active': false });
           * // => false
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.every(users, 'active', false);
           * // => true
           *
           * // using the `_.property` callback shorthand
           * _.every(users, 'active');
           * // => false
           */
          function every(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
              predicate = null;
            }
            if (typeof predicate != 'function' || thisArg !== undefined) {
              predicate = getCallback(predicate, thisArg, 3);
            }
            return func(collection, predicate);
          }

          /**
           * Iterates over elements of `collection`, returning an array of all elements
           * `predicate` returns truthy for. The predicate is bound to `thisArg` and
           * invoked with three arguments: (value, index|key, collection).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @alias select
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the new filtered array.
           * @example
           *
           * _.filter([4, 5, 6], function(n) {
           *   return n % 2 == 0;
           * });
           * // => [4, 6]
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': true },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
           * // => ['barney']
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.pluck(_.filter(users, 'active', false), 'user');
           * // => ['fred']
           *
           * // using the `_.property` callback shorthand
           * _.pluck(_.filter(users, 'active'), 'user');
           * // => ['barney']
           */
          function filter(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = getCallback(predicate, thisArg, 3);
            return func(collection, predicate);
          }

          /**
           * Iterates over elements of `collection`, returning the first element
           * `predicate` returns truthy for. The predicate is bound to `thisArg` and
           * invoked with three arguments: (value, index|key, collection).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @alias detect
           * @category Collection
           * @param {Array|Object|string} collection The collection to search.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {*} Returns the matched element, else `undefined`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36, 'active': true },
           *   { 'user': 'fred',    'age': 40, 'active': false },
           *   { 'user': 'pebbles', 'age': 1,  'active': true }
           * ];
           *
           * _.result(_.find(users, function(chr) {
           *   return chr.age < 40;
           * }), 'user');
           * // => 'barney'
           *
           * // using the `_.matches` callback shorthand
           * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
           * // => 'pebbles'
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.result(_.find(users, 'active', false), 'user');
           * // => 'fred'
           *
           * // using the `_.property` callback shorthand
           * _.result(_.find(users, 'active'), 'user');
           * // => 'barney'
           */
          var find = createFind(baseEach);

          /**
           * This method is like `_.find` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to search.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {*} Returns the matched element, else `undefined`.
           * @example
           *
           * _.findLast([1, 2, 3, 4], function(n) {
           *   return n % 2 == 1;
           * });
           * // => 3
           */
          var findLast = createFind(baseEachRight, true);

          /**
           * Performs a deep comparison between each element in `collection` and the
           * source object, returning the first element that has equivalent property
           * values.
           *
           * **Note:** This method supports comparing arrays, booleans, `Date` objects,
           * numbers, `Object` objects, regexes, and strings. Objects are compared by
           * their own, not inherited, enumerable properties. For comparing a single
           * own or inherited property value see `_.matchesProperty`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to search.
           * @param {Object} source The object of property values to match.
           * @returns {*} Returns the matched element, else `undefined`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': true },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
           * // => 'barney'
           *
           * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
           * // => 'fred'
           */
          function findWhere(collection, source) {
            return find(collection, baseMatches(source));
          }

          /**
           * Iterates over elements of `collection` invoking `iteratee` for each element.
           * The `iteratee` is bound to `thisArg` and invoked with three arguments:
           * (value, index|key, collection). Iteratee functions may exit iteration early
           * by explicitly returning `false`.
           *
           * **Note:** As with other "Collections" methods, objects with a "length" property
           * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
           * may be used for object iteration.
           *
           * @static
           * @memberOf _
           * @alias each
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array|Object|string} Returns `collection`.
           * @example
           *
           * _([1, 2]).forEach(function(n) {
           *   console.log(n);
           * }).value();
           * // => logs each value from left to right and returns the array
           *
           * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
           *   console.log(n, key);
           * });
           * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
           */
          var forEach = createForEach(arrayEach, baseEach);

          /**
           * This method is like `_.forEach` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @alias eachRight
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array|Object|string} Returns `collection`.
           * @example
           *
           * _([1, 2]).forEachRight(function(n) {
           *   console.log(n);
           * }).value();
           * // => logs each value from right to left and returns the array
           */
          var forEachRight = createForEach(arrayEachRight, baseEachRight);

          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` through `iteratee`. The corresponding value
           * of each key is an array of the elements responsible for generating the key.
           * The `iteratee` is bound to `thisArg` and invoked with three arguments:
           * (value, index|key, collection).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.groupBy([4.2, 6.1, 6.4], function(n) {
           *   return Math.floor(n);
           * });
           * // => { '4': [4.2], '6': [6.1, 6.4] }
           *
           * _.groupBy([4.2, 6.1, 6.4], function(n) {
           *   return this.floor(n);
           * }, Math);
           * // => { '4': [4.2], '6': [6.1, 6.4] }
           *
           * // using the `_.property` callback shorthand
           * _.groupBy(['one', 'two', 'three'], 'length');
           * // => { '3': ['one', 'two'], '5': ['three'] }
           */
          var groupBy = createAggregator(function (result, value, key) {
            if (hasOwnProperty.call(result, key)) {
              result[key].push(value);
            } else {
              result[key] = [value];
            }
          });

          /**
           * Checks if `value` is in `collection` using
           * [`SameValueZero`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
           * for equality comparisons. If `fromIndex` is negative, it is used as the offset
           * from the end of `collection`.
           *
           * @static
           * @memberOf _
           * @alias contains, include
           * @category Collection
           * @param {Array|Object|string} collection The collection to search.
           * @param {*} target The value to search for.
           * @param {number} [fromIndex=0] The index to search from.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
           * @returns {boolean} Returns `true` if a matching element is found, else `false`.
           * @example
           *
           * _.includes([1, 2, 3], 1);
           * // => true
           *
           * _.includes([1, 2, 3], 1, 2);
           * // => false
           *
           * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
           * // => true
           *
           * _.includes('pebbles', 'eb');
           * // => true
           */
          function includes(collection, target, fromIndex, guard) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) {
              collection = values(collection);
              length = collection.length;
            }
            if (!length) {
              return false;
            }
            if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
              fromIndex = 0;
            } else {
              fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
            }
            return (typeof collection == 'string' || !isArray(collection) && isString(collection))
              ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)
              : (getIndexOf(collection, target, fromIndex) > -1);
          }

          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` through `iteratee`. The corresponding value
           * of each key is the last element responsible for generating the key. The
           * iteratee function is bound to `thisArg` and invoked with three arguments:
           * (value, index|key, collection).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * var keyData = [
           *   { 'dir': 'left', 'code': 97 },
           *   { 'dir': 'right', 'code': 100 }
           * ];
           *
           * _.indexBy(keyData, 'dir');
           * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
           *
           * _.indexBy(keyData, function(object) {
           *   return String.fromCharCode(object.code);
           * });
           * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
           *
           * _.indexBy(keyData, function(object) {
           *   return this.fromCharCode(object.code);
           * }, String);
           * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
           */
          var indexBy = createAggregator(function (result, value, key) {
            result[key] = value;
          });

          /**
           * Invokes the method at `path` of each element in `collection`, returning
           * an array of the results of each invoked method. Any additional arguments
           * are provided to each invoked method. If `methodName` is a function it is
           * invoked for, and `this` bound to, each element in `collection`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Array|Function|string} path The path of the method to invoke or
           *  the function invoked per iteration.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {Array} Returns the array of results.
           * @example
           *
           * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
           * // => [[1, 5, 7], [1, 2, 3]]
           *
           * _.invoke([123, 456], String.prototype.split, '');
           * // => [['1', '2', '3'], ['4', '5', '6']]
           */
          var invoke = restParam(function (collection, path, args) {
            var index = -1,
              isFunc = typeof path == 'function',
              isProp = isKey(path),
              result = isArrayLike(collection) ? Array(collection.length) : [];

            baseEach(collection, function (value) {
              var func = isFunc ? path : ((isProp && value != null) ? value[path] : null);
              result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
            });
            return result;
          });

          /**
           * Creates an array of values by running each element in `collection` through
           * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
           * arguments: (value, index|key, collection).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * Many lodash methods are guarded to work as iteratees for methods like
           * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
           *
           * The guarded methods are:
           * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
           * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
           * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
           * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
           * `sum`, `uniq`, and `words`
           *
           * @static
           * @memberOf _
           * @alias collect
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array} Returns the new mapped array.
           * @example
           *
           * function timesThree(n) {
           *   return n * 3;
           * }
           *
           * _.map([1, 2], timesThree);
           * // => [3, 6]
           *
           * _.map({ 'a': 1, 'b': 2 }, timesThree);
           * // => [3, 6] (iteration order is not guaranteed)
           *
           * var users = [
           *   { 'user': 'barney' },
           *   { 'user': 'fred' }
           * ];
           *
           * // using the `_.property` callback shorthand
           * _.map(users, 'user');
           * // => ['barney', 'fred']
           */
          function map(collection, iteratee, thisArg) {
            var func = isArray(collection) ? arrayMap : baseMap;
            iteratee = getCallback(iteratee, thisArg, 3);
            return func(collection, iteratee);
          }

          /**
           * Creates an array of elements split into two groups, the first of which
           * contains elements `predicate` returns truthy for, while the second of which
           * contains elements `predicate` returns falsey for. The predicate is bound
           * to `thisArg` and invoked with three arguments: (value, index|key, collection).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the array of grouped elements.
           * @example
           *
           * _.partition([1, 2, 3], function(n) {
           *   return n % 2;
           * });
           * // => [[1, 3], [2]]
           *
           * _.partition([1.2, 2.3, 3.4], function(n) {
           *   return this.floor(n) % 2;
           * }, Math);
           * // => [[1.2, 3.4], [2.3]]
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36, 'active': false },
           *   { 'user': 'fred',    'age': 40, 'active': true },
           *   { 'user': 'pebbles', 'age': 1,  'active': false }
           * ];
           *
           * var mapper = function(array) {
           *   return _.pluck(array, 'user');
           * };
           *
           * // using the `_.matches` callback shorthand
           * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
           * // => [['pebbles'], ['barney', 'fred']]
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.map(_.partition(users, 'active', false), mapper);
           * // => [['barney', 'pebbles'], ['fred']]
           *
           * // using the `_.property` callback shorthand
           * _.map(_.partition(users, 'active'), mapper);
           * // => [['fred'], ['barney', 'pebbles']]
           */
          var partition = createAggregator(function (result, value, key) {
            result[key ? 0 : 1].push(value);
          }, function () { return [[], []]; });

          /**
           * Gets the property value of `path` from all elements in `collection`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Array|string} path The path of the property to pluck.
           * @returns {Array} Returns the property values.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 40 }
           * ];
           *
           * _.pluck(users, 'user');
           * // => ['barney', 'fred']
           *
           * var userIndex = _.indexBy(users, 'user');
           * _.pluck(userIndex, 'age');
           * // => [36, 40] (iteration order is not guaranteed)
           */
          function pluck(collection, path) {
            return map(collection, property(path));
          }

          /**
           * Reduces `collection` to a value which is the accumulated result of running
           * each element in `collection` through `iteratee`, where each successive
           * invocation is supplied the return value of the previous. If `accumulator`
           * is not provided the first element of `collection` is used as the initial
           * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
           * (accumulator, value, index|key, collection).
           *
           * Many lodash methods are guarded to work as iteratees for methods like
           * `_.reduce`, `_.reduceRight`, and `_.transform`.
           *
           * The guarded methods are:
           * `assign`, `defaults`, `includes`, `merge`, `sortByAll`, and `sortByOrder`
           *
           * @static
           * @memberOf _
           * @alias foldl, inject
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * _.reduce([1, 2], function(total, n) {
           *   return total + n;
           * });
           * // => 3
           *
           * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
           *   result[key] = n * 3;
           *   return result;
           * }, {});
           * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
           */
          var reduce = createReduce(arrayReduce, baseEach);

          /**
           * This method is like `_.reduce` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @alias foldr
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * var array = [[0, 1], [2, 3], [4, 5]];
           *
           * _.reduceRight(array, function(flattened, other) {
           *   return flattened.concat(other);
           * }, []);
           * // => [4, 5, 2, 3, 0, 1]
           */
          var reduceRight = createReduce(arrayReduceRight, baseEachRight);

          /**
           * The opposite of `_.filter`; this method returns the elements of `collection`
           * that `predicate` does **not** return truthy for.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the new filtered array.
           * @example
           *
           * _.reject([1, 2, 3, 4], function(n) {
           *   return n % 2 == 0;
           * });
           * // => [1, 3]
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': false },
           *   { 'user': 'fred',   'age': 40, 'active': true }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
           * // => ['barney']
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.pluck(_.reject(users, 'active', false), 'user');
           * // => ['fred']
           *
           * // using the `_.property` callback shorthand
           * _.pluck(_.reject(users, 'active'), 'user');
           * // => ['barney']
           */
          function reject(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = getCallback(predicate, thisArg, 3);
            return func(collection, function (value, index, collection) {
              return !predicate(value, index, collection);
            });
          }

          /**
           * Gets a random element or `n` random elements from a collection.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to sample.
           * @param {number} [n] The number of elements to sample.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {*} Returns the random sample(s).
           * @example
           *
           * _.sample([1, 2, 3, 4]);
           * // => 2
           *
           * _.sample([1, 2, 3, 4], 2);
           * // => [3, 1]
           */
          function sample(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n == null) {
              collection = toIterable(collection);
              var length = collection.length;
              return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
            }
            var index = -1,
              result = toArray(collection),
              length = result.length,
              lastIndex = length - 1;

            n = nativeMin(n < 0 ? 0 : (+n || 0), length);
            while (++index < n) {
              var rand = baseRandom(index, lastIndex),
                value = result[rand];

              result[rand] = result[index];
              result[index] = value;
            }
            result.length = n;
            return result;
          }

          /**
           * Creates an array of shuffled values, using a version of the
           * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to shuffle.
           * @returns {Array} Returns the new shuffled array.
           * @example
           *
           * _.shuffle([1, 2, 3, 4]);
           * // => [4, 1, 3, 2]
           */
          function shuffle(collection) {
            return sample(collection, POSITIVE_INFINITY);
          }

          /**
           * Gets the size of `collection` by returning its length for array-like
           * values or the number of own enumerable properties for objects.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to inspect.
           * @returns {number} Returns the size of `collection`.
           * @example
           *
           * _.size([1, 2, 3]);
           * // => 3
           *
           * _.size({ 'a': 1, 'b': 2 });
           * // => 2
           *
           * _.size('pebbles');
           * // => 7
           */
          function size(collection) {
            var length = collection ? getLength(collection) : 0;
            return isLength(length) ? length : keys(collection).length;
          }

          /**
           * Checks if `predicate` returns truthy for **any** element of `collection`.
           * The function returns as soon as it finds a passing value and does not iterate
           * over the entire collection. The predicate is bound to `thisArg` and invoked
           * with three arguments: (value, index|key, collection).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @alias any
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {boolean} Returns `true` if any element passes the predicate check,
           *  else `false`.
           * @example
           *
           * _.some([null, 0, 'yes', false], Boolean);
           * // => true
           *
           * var users = [
           *   { 'user': 'barney', 'active': true },
           *   { 'user': 'fred',   'active': false }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.some(users, { 'user': 'barney', 'active': false });
           * // => false
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.some(users, 'active', false);
           * // => true
           *
           * // using the `_.property` callback shorthand
           * _.some(users, 'active');
           * // => true
           */
          function some(collection, predicate, thisArg) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
              predicate = null;
            }
            if (typeof predicate != 'function' || thisArg !== undefined) {
              predicate = getCallback(predicate, thisArg, 3);
            }
            return func(collection, predicate);
          }

          /**
           * Creates an array of elements, sorted in ascending order by the results of
           * running each element in a collection through `iteratee`. This method performs
           * a stable sort, that is, it preserves the original sort order of equal elements.
           * The `iteratee` is bound to `thisArg` and invoked with three arguments:
           * (value, index|key, collection).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array} Returns the new sorted array.
           * @example
           *
           * _.sortBy([1, 2, 3], function(n) {
           *   return Math.sin(n);
           * });
           * // => [3, 1, 2]
           *
           * _.sortBy([1, 2, 3], function(n) {
           *   return this.sin(n);
           * }, Math);
           * // => [3, 1, 2]
           *
           * var users = [
           *   { 'user': 'fred' },
           *   { 'user': 'pebbles' },
           *   { 'user': 'barney' }
           * ];
           *
           * // using the `_.property` callback shorthand
           * _.pluck(_.sortBy(users, 'user'), 'user');
           * // => ['barney', 'fred', 'pebbles']
           */
          function sortBy(collection, iteratee, thisArg) {
            if (collection == null) {
              return [];
            }
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = null;
            }
            var index = -1;
            iteratee = getCallback(iteratee, thisArg, 3);

            var result = baseMap(collection, function (value, key, collection) {
              return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
            });
            return baseSortBy(result, compareAscending);
          }

          /**
           * This method is like `_.sortBy` except that it can sort by multiple iteratees
           * or property names.
           *
           * If a property name is provided for an iteratee the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If an object is provided for an iteratee the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
           *  The iteratees to sort by, specified as individual values or arrays of values.
           * @returns {Array} Returns the new sorted array.
           * @example
           *
           * var users = [
           *   { 'user': 'fred',   'age': 48 },
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 42 },
           *   { 'user': 'barney', 'age': 34 }
           * ];
           *
           * _.map(_.sortByAll(users, ['user', 'age']), _.values);
           * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
           *
           * _.map(_.sortByAll(users, 'user', function(chr) {
           *   return Math.floor(chr.age / 10);
           * }), _.values);
           * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
           */
          var sortByAll = restParam(function (collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var guard = iteratees[2];
            if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
              iteratees.length = 1;
            }
            return baseSortByOrder(collection, baseFlatten(iteratees), []);
          });

          /**
           * This method is like `_.sortByAll` except that it allows specifying the
           * sort orders of the iteratees to sort by. A truthy value in `orders` will
           * sort the corresponding property name in ascending order while a falsey
           * value will sort it in descending order.
           *
           * If a property name is provided for an iteratee the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If an object is provided for an iteratee the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
           * @param {boolean[]} orders The sort orders of `iteratees`.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
           * @returns {Array} Returns the new sorted array.
           * @example
           *
           * var users = [
           *   { 'user': 'fred',   'age': 48 },
           *   { 'user': 'barney', 'age': 34 },
           *   { 'user': 'fred',   'age': 42 },
           *   { 'user': 'barney', 'age': 36 }
           * ];
           *
           * // sort by `user` in ascending order and by `age` in descending order
           * _.map(_.sortByOrder(users, ['user', 'age'], [true, false]), _.values);
           * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
           */
          function sortByOrder(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (guard && isIterateeCall(iteratees, orders, guard)) {
              orders = null;
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseSortByOrder(collection, iteratees, orders);
          }

          /**
           * Performs a deep comparison between each element in `collection` and the
           * source object, returning an array of all elements that have equivalent
           * property values.
           *
           * **Note:** This method supports comparing arrays, booleans, `Date` objects,
           * numbers, `Object` objects, regexes, and strings. Objects are compared by
           * their own, not inherited, enumerable properties. For comparing a single
           * own or inherited property value see `_.matchesProperty`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to search.
           * @param {Object} source The object of property values to match.
           * @returns {Array} Returns the new filtered array.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
           *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
           * ];
           *
           * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
           * // => ['barney']
           *
           * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
           * // => ['fred']
           */
          function where(collection, source) {
            return filter(collection, baseMatches(source));
          }

          /*------------------------------------------------------------------------*/

          /**
           * Gets the number of milliseconds that have elapsed since the Unix epoch
           * (1 January 1970 00:00:00 UTC).
           *
           * @static
           * @memberOf _
           * @category Date
           * @example
           *
           * _.defer(function(stamp) {
           *   console.log(_.now() - stamp);
           * }, _.now());
           * // => logs the number of milliseconds it took for the deferred function to be invoked
           */
          var now = nativeNow || function () {
            return new Date().getTime();
          };

          /*------------------------------------------------------------------------*/

          /**
           * The opposite of `_.before`; this method creates a function that invokes
           * `func` once it is called `n` or more times.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {number} n The number of calls before `func` is invoked.
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var saves = ['profile', 'settings'];
           *
           * var done = _.after(saves.length, function() {
           *   console.log('done saving!');
           * });
           *
           * _.forEach(saves, function(type) {
           *   asyncSave({ 'type': type, 'complete': done });
           * });
           * // => logs 'done saving!' after the two async saves have completed
           */
          function after(n, func) {
            if (typeof func != 'function') {
              if (typeof n == 'function') {
                var temp = n;
                n = func;
                func = temp;
              } else {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
            }
            n = nativeIsFinite(n = +n) ? n : 0;
            return function () {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }

          /**
           * Creates a function that accepts up to `n` arguments ignoring any
           * additional arguments.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to cap arguments for.
           * @param {number} [n=func.length] The arity cap.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Function} Returns the new function.
           * @example
           *
           * _.map(['6', '8', '10'], _.ary(parseInt, 1));
           * // => [6, 8, 10]
           */
          function ary(func, n, guard) {
            if (guard && isIterateeCall(func, n, guard)) {
              n = null;
            }
            n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
            return createWrapper(func, ARY_FLAG, null, null, null, null, n);
          }

          /**
           * Creates a function that invokes `func`, with the `this` binding and arguments
           * of the created function, while it is called less than `n` times. Subsequent
           * calls to the created function return the result of the last `func` invocation.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {number} n The number of calls at which `func` is no longer invoked.
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * jQuery('#add').on('click', _.before(5, addContactToList));
           * // => allows adding up to 4 contacts to the list
           */
          function before(n, func) {
            var result;
            if (typeof func != 'function') {
              if (typeof n == 'function') {
                var temp = n;
                n = func;
                func = temp;
              } else {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
            }
            return function () {
              if (--n > 0) {
                result = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = null;
              }
              return result;
            };
          }

          /**
           * Creates a function that invokes `func` with the `this` binding of `thisArg`
           * and prepends any additional `_.bind` arguments to those provided to the
           * bound function.
           *
           * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
           * may be used as a placeholder for partially applied arguments.
           *
           * **Note:** Unlike native `Function#bind` this method does not set the "length"
           * property of bound functions.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to bind.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * var greet = function(greeting, punctuation) {
           *   return greeting + ' ' + this.user + punctuation;
           * };
           *
           * var object = { 'user': 'fred' };
           *
           * var bound = _.bind(greet, object, 'hi');
           * bound('!');
           * // => 'hi fred!'
           *
           * // using placeholders
           * var bound = _.bind(greet, object, _, '!');
           * bound('hi');
           * // => 'hi fred!'
           */
          var bind = restParam(function (func, thisArg, partials) {
            var bitmask = BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, bind.placeholder);
              bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(func, bitmask, thisArg, partials, holders);
          });

          /**
           * Binds methods of an object to the object itself, overwriting the existing
           * method. Method names may be specified as individual arguments or as arrays
           * of method names. If no method names are provided all enumerable function
           * properties, own and inherited, of `object` are bound.
           *
           * **Note:** This method does not set the "length" property of bound functions.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Object} object The object to bind and assign the bound methods to.
           * @param {...(string|string[])} [methodNames] The object method names to bind,
           *  specified as individual method names or arrays of method names.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var view = {
           *   'label': 'docs',
           *   'onClick': function() {
           *     console.log('clicked ' + this.label);
           *   }
           * };
           *
           * _.bindAll(view);
           * jQuery('#docs').on('click', view.onClick);
           * // => logs 'clicked docs' when the element is clicked
           */
          var bindAll = restParam(function (object, methodNames) {
            methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

            var index = -1,
              length = methodNames.length;

            while (++index < length) {
              var key = methodNames[index];
              object[key] = createWrapper(object[key], BIND_FLAG, object);
            }
            return object;
          });

          /**
           * Creates a function that invokes the method at `object[key]` and prepends
           * any additional `_.bindKey` arguments to those provided to the bound function.
           *
           * This method differs from `_.bind` by allowing bound functions to reference
           * methods that may be redefined or don't yet exist.
           * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
           * for more details.
           *
           * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Object} object The object the method belongs to.
           * @param {string} key The key of the method.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * var object = {
           *   'user': 'fred',
           *   'greet': function(greeting, punctuation) {
           *     return greeting + ' ' + this.user + punctuation;
           *   }
           * };
           *
           * var bound = _.bindKey(object, 'greet', 'hi');
           * bound('!');
           * // => 'hi fred!'
           *
           * object.greet = function(greeting, punctuation) {
           *   return greeting + 'ya ' + this.user + punctuation;
           * };
           *
           * bound('!');
           * // => 'hiya fred!'
           *
           * // using placeholders
           * var bound = _.bindKey(object, 'greet', _, '!');
           * bound('hi');
           * // => 'hiya fred!'
           */
          var bindKey = restParam(function (object, key, partials) {
            var bitmask = BIND_FLAG | BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, bindKey.placeholder);
              bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(key, bitmask, object, partials, holders);
          });

          /**
           * Creates a function that accepts one or more arguments of `func` that when
           * called either invokes `func` returning its result, if all `func` arguments
           * have been provided, or returns a function that accepts one or more of the
           * remaining `func` arguments, and so on. The arity of `func` may be specified
           * if `func.length` is not sufficient.
           *
           * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
           * may be used as a placeholder for provided arguments.
           *
           * **Note:** This method does not set the "length" property of curried functions.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to curry.
           * @param {number} [arity=func.length] The arity of `func`.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Function} Returns the new curried function.
           * @example
           *
           * var abc = function(a, b, c) {
           *   return [a, b, c];
           * };
           *
           * var curried = _.curry(abc);
           *
           * curried(1)(2)(3);
           * // => [1, 2, 3]
           *
           * curried(1, 2)(3);
           * // => [1, 2, 3]
           *
           * curried(1, 2, 3);
           * // => [1, 2, 3]
           *
           * // using placeholders
           * curried(1)(_, 3)(2);
           * // => [1, 2, 3]
           */
          var curry = createCurry(CURRY_FLAG);

          /**
           * This method is like `_.curry` except that arguments are applied to `func`
           * in the manner of `_.partialRight` instead of `_.partial`.
           *
           * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for provided arguments.
           *
           * **Note:** This method does not set the "length" property of curried functions.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to curry.
           * @param {number} [arity=func.length] The arity of `func`.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Function} Returns the new curried function.
           * @example
           *
           * var abc = function(a, b, c) {
           *   return [a, b, c];
           * };
           *
           * var curried = _.curryRight(abc);
           *
           * curried(3)(2)(1);
           * // => [1, 2, 3]
           *
           * curried(2, 3)(1);
           * // => [1, 2, 3]
           *
           * curried(1, 2, 3);
           * // => [1, 2, 3]
           *
           * // using placeholders
           * curried(3)(1, _)(2);
           * // => [1, 2, 3]
           */
          var curryRight = createCurry(CURRY_RIGHT_FLAG);

          /**
           * Creates a debounced function that delays invoking `func` until after `wait`
           * milliseconds have elapsed since the last time the debounced function was
           * invoked. The debounced function comes with a `cancel` method to cancel
           * delayed invocations. Provide an options object to indicate that `func`
           * should be invoked on the leading and/or trailing edge of the `wait` timeout.
           * Subsequent calls to the debounced function return the result of the last
           * `func` invocation.
           *
           * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
           * on the trailing edge of the timeout only if the the debounced function is
           * invoked more than once during the `wait` timeout.
           *
           * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
           * for details over the differences between `_.debounce` and `_.throttle`.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to debounce.
           * @param {number} [wait=0] The number of milliseconds to delay.
           * @param {Object} [options] The options object.
           * @param {boolean} [options.leading=false] Specify invoking on the leading
           *  edge of the timeout.
           * @param {number} [options.maxWait] The maximum time `func` is allowed to be
           *  delayed before it is invoked.
           * @param {boolean} [options.trailing=true] Specify invoking on the trailing
           *  edge of the timeout.
           * @returns {Function} Returns the new debounced function.
           * @example
           *
           * // avoid costly calculations while the window size is in flux
           * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
           *
           * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
           * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
           *   'leading': true,
           *   'trailing': false
           * }));
           *
           * // ensure `batchLog` is invoked once after 1 second of debounced calls
           * var source = new EventSource('/stream');
           * jQuery(source).on('message', _.debounce(batchLog, 250, {
           *   'maxWait': 1000
           * }));
           *
           * // cancel a debounced call
           * var todoChanges = _.debounce(batchLog, 1000);
           * Object.observe(models.todo, todoChanges);
           *
           * Object.observe(models, function(changes) {
           *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
           *     todoChanges.cancel();
           *   }
           * }, ['delete']);
           *
           * // ...at some point `models.todo` is changed
           * models.todo.completed = true;
           *
           * // ...before 1 second has passed `models.todo` is deleted
           * // which cancels the debounced `todoChanges` call
           * delete models.todo;
           */
          function debounce(func, wait, options) {
            var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;

            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            wait = wait < 0 ? 0 : (+wait || 0);
            if (options === true) {
              var leading = true;
              trailing = false;
            } else if (isObject(options)) {
              leading = options.leading;
              maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
              trailing = 'trailing' in options ? options.trailing : trailing;
            }

            function cancel() {
              if (timeoutId) {
                clearTimeout(timeoutId);
              }
              if (maxTimeoutId) {
                clearTimeout(maxTimeoutId);
              }
              maxTimeoutId = timeoutId = trailingCall = undefined;
            }

            function delayed() {
              var remaining = wait - (now() - stamp);
              if (remaining <= 0 || remaining > wait) {
                if (maxTimeoutId) {
                  clearTimeout(maxTimeoutId);
                }
                var isCalled = trailingCall;
                maxTimeoutId = timeoutId = trailingCall = undefined;
                if (isCalled) {
                  lastCalled = now();
                  result = func.apply(thisArg, args);
                  if (!timeoutId && !maxTimeoutId) {
                    args = thisArg = null;
                  }
                }
              } else {
                timeoutId = setTimeout(delayed, remaining);
              }
            }

            function maxDelayed() {
              if (timeoutId) {
                clearTimeout(timeoutId);
              }
              maxTimeoutId = timeoutId = trailingCall = undefined;
              if (trailing || (maxWait !== wait)) {
                lastCalled = now();
                result = func.apply(thisArg, args);
                if (!timeoutId && !maxTimeoutId) {
                  args = thisArg = null;
                }
              }
            }

            function debounced() {
              args = arguments;
              stamp = now();
              thisArg = this;
              trailingCall = trailing && (timeoutId || !leading);

              if (maxWait === false) {
                var leadingCall = leading && !timeoutId;
              } else {
                if (!maxTimeoutId && !leading) {
                  lastCalled = stamp;
                }
                var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0 || remaining > maxWait;

                if (isCalled) {
                  if (maxTimeoutId) {
                    maxTimeoutId = clearTimeout(maxTimeoutId);
                  }
                  lastCalled = stamp;
                  result = func.apply(thisArg, args);
                }
                else if (!maxTimeoutId) {
                  maxTimeoutId = setTimeout(maxDelayed, remaining);
                }
              }
              if (isCalled && timeoutId) {
                timeoutId = clearTimeout(timeoutId);
              }
              else if (!timeoutId && wait !== maxWait) {
                timeoutId = setTimeout(delayed, wait);
              }
              if (leadingCall) {
                isCalled = true;
                result = func.apply(thisArg, args);
              }
              if (isCalled && !timeoutId && !maxTimeoutId) {
                args = thisArg = null;
              }
              return result;
            }
            debounced.cancel = cancel;
            return debounced;
          }

          /**
           * Defers invoking the `func` until the current call stack has cleared. Any
           * additional arguments are provided to `func` when it is invoked.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to defer.
           * @param {...*} [args] The arguments to invoke the function with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.defer(function(text) {
           *   console.log(text);
           * }, 'deferred');
           * // logs 'deferred' after one or more milliseconds
           */
          var defer = restParam(function (func, args) {
            return baseDelay(func, 1, args);
          });

          /**
           * Invokes `func` after `wait` milliseconds. Any additional arguments are
           * provided to `func` when it is invoked.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @param {...*} [args] The arguments to invoke the function with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.delay(function(text) {
           *   console.log(text);
           * }, 1000, 'later');
           * // => logs 'later' after one second
           */
          var delay = restParam(function (func, wait, args) {
            return baseDelay(func, wait, args);
          });

          /**
           * Creates a function that returns the result of invoking the provided
           * functions with the `this` binding of the created function, where each
           * successive invocation is supplied the return value of the previous.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {...Function} [funcs] Functions to invoke.
           * @returns {Function} Returns the new function.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var addSquare = _.flow(_.add, square);
           * addSquare(1, 2);
           * // => 9
           */
          var flow = createFlow();

          /**
           * This method is like `_.flow` except that it creates a function that
           * invokes the provided functions from right to left.
           *
           * @static
           * @memberOf _
           * @alias backflow, compose
           * @category Function
           * @param {...Function} [funcs] Functions to invoke.
           * @returns {Function} Returns the new function.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var addSquare = _.flowRight(square, _.add);
           * addSquare(1, 2);
           * // => 9
           */
          var flowRight = createFlow(true);

          /**
           * Creates a function that memoizes the result of `func`. If `resolver` is
           * provided it determines the cache key for storing the result based on the
           * arguments provided to the memoized function. By default, the first argument
           * provided to the memoized function is coerced to a string and used as the
           * cache key. The `func` is invoked with the `this` binding of the memoized
           * function.
           *
           * **Note:** The cache is exposed as the `cache` property on the memoized
           * function. Its creation may be customized by replacing the `_.memoize.Cache`
           * constructor with one whose instances implement the [`Map`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-map-prototype-object)
           * method interface of `get`, `has`, and `set`.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to have its output memoized.
           * @param {Function} [resolver] The function to resolve the cache key.
           * @returns {Function} Returns the new memoizing function.
           * @example
           *
           * var upperCase = _.memoize(function(string) {
           *   return string.toUpperCase();
           * });
           *
           * upperCase('fred');
           * // => 'FRED'
           *
           * // modifying the result cache
           * upperCase.cache.set('fred', 'BARNEY');
           * upperCase('fred');
           * // => 'BARNEY'
           *
           * // replacing `_.memoize.Cache`
           * var object = { 'user': 'fred' };
           * var other = { 'user': 'barney' };
           * var identity = _.memoize(_.identity);
           *
           * identity(object);
           * // => { 'user': 'fred' }
           * identity(other);
           * // => { 'user': 'fred' }
           *
           * _.memoize.Cache = WeakMap;
           * var identity = _.memoize(_.identity);
           *
           * identity(object);
           * // => { 'user': 'fred' }
           * identity(other);
           * // => { 'user': 'barney' }
           */
          function memoize(func, resolver) {
            if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            var memoized = function () {
              var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;

              if (cache.has(key)) {
                return cache.get(key);
              }
              var result = func.apply(this, args);
              memoized.cache = cache.set(key, result);
              return result;
            };
            memoized.cache = new memoize.Cache;
            return memoized;
          }

          /**
           * Creates a function that negates the result of the predicate `func`. The
           * `func` predicate is invoked with the `this` binding and arguments of the
           * created function.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} predicate The predicate to negate.
           * @returns {Function} Returns the new function.
           * @example
           *
           * function isEven(n) {
           *   return n % 2 == 0;
           * }
           *
           * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
           * // => [1, 3, 5]
           */
          function negate(predicate) {
            if (typeof predicate != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            return function () {
              return !predicate.apply(this, arguments);
            };
          }

          /**
           * Creates a function that is restricted to invoking `func` once. Repeat calls
           * to the function return the value of the first call. The `func` is invoked
           * with the `this` binding and arguments of the created function.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var initialize = _.once(createApplication);
           * initialize();
           * initialize();
           * // `initialize` invokes `createApplication` once
           */
          function once(func) {
            return beforeAll(2, func);
          }

          /**
           * Creates a function that invokes `func` with `partial` arguments prepended
           * to those provided to the new function. This method is like `_.bind` except
           * it does **not** alter the `this` binding.
           *
           * The `_.partial.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * **Note:** This method does not set the "length" property of partially
           * applied functions.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * var greet = function(greeting, name) {
           *   return greeting + ' ' + name;
           * };
           *
           * var sayHelloTo = _.partial(greet, 'hello');
           * sayHelloTo('fred');
           * // => 'hello fred'
           *
           * // using placeholders
           * var greetFred = _.partial(greet, _, 'fred');
           * greetFred('hi');
           * // => 'hi fred'
           */
          var partial = createPartial(PARTIAL_FLAG);

          /**
           * This method is like `_.partial` except that partially applied arguments
           * are appended to those provided to the new function.
           *
           * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * **Note:** This method does not set the "length" property of partially
           * applied functions.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * var greet = function(greeting, name) {
           *   return greeting + ' ' + name;
           * };
           *
           * var greetFred = _.partialRight(greet, 'fred');
           * greetFred('hi');
           * // => 'hi fred'
           *
           * // using placeholders
           * var sayHelloTo = _.partialRight(greet, 'hello', _);
           * sayHelloTo('fred');
           * // => 'hello fred'
           */
          var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

          /**
           * Creates a function that invokes `func` with arguments arranged according
           * to the specified indexes where the argument value at the first index is
           * provided as the first argument, the argument value at the second index is
           * provided as the second argument, and so on.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to rearrange arguments for.
           * @param {...(number|number[])} indexes The arranged argument indexes,
           *  specified as individual indexes or arrays of indexes.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var rearged = _.rearg(function(a, b, c) {
           *   return [a, b, c];
           * }, 2, 0, 1);
           *
           * rearged('b', 'c', 'a')
           * // => ['a', 'b', 'c']
           *
           * var map = _.rearg(_.map, [1, 0]);
           * map(function(n) {
           *   return n * 3;
           * }, [1, 2, 3]);
           * // => [3, 6, 9]
           */
          var rearg = restParam(function (func, indexes) {
            return createWrapper(func, REARG_FLAG, null, null, null, baseFlatten(indexes));
          });

          /**
           * Creates a function that invokes `func` with the `this` binding of the
           * created function and arguments from `start` and beyond provided as an array.
           *
           * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var say = _.restParam(function(what, names) {
           *   return what + ' ' + _.initial(names).join(', ') +
           *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
           * });
           *
           * say('hello', 'fred', 'barney', 'pebbles');
           * // => 'hello fred, barney, & pebbles'
           */
          function restParam(func, start) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
            return function () {
              var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                rest = Array(length);

              while (++index < length) {
                rest[index] = args[start + index];
              }
              switch (start) {
                case 0: return func.call(this, rest);
                case 1: return func.call(this, args[0], rest);
                case 2: return func.call(this, args[0], args[1], rest);
              }
              var otherArgs = Array(start + 1);
              index = -1;
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = rest;
              return func.apply(this, otherArgs);
            };
          }

          /**
           * Creates a function that invokes `func` with the `this` binding of the created
           * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
           *
           * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to spread arguments over.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var say = _.spread(function(who, what) {
           *   return who + ' says ' + what;
           * });
           *
           * say(['fred', 'hello']);
           * // => 'fred says hello'
           *
           * // with a Promise
           * var numbers = Promise.all([
           *   Promise.resolve(40),
           *   Promise.resolve(36)
           * ]);
           *
           * numbers.then(_.spread(function(x, y) {
           *   return x + y;
           * }));
           * // => a Promise of 76
           */
          function spread(func) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            return function (array) {
              return func.apply(this, array);
            };
          }

          /**
           * Creates a throttled function that only invokes `func` at most once per
           * every `wait` milliseconds. The throttled function comes with a `cancel`
           * method to cancel delayed invocations. Provide an options object to indicate
           * that `func` should be invoked on the leading and/or trailing edge of the
           * `wait` timeout. Subsequent calls to the throttled function return the
           * result of the last `func` call.
           *
           * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
           * on the trailing edge of the timeout only if the the throttled function is
           * invoked more than once during the `wait` timeout.
           *
           * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
           * for details over the differences between `_.throttle` and `_.debounce`.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to throttle.
           * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
           * @param {Object} [options] The options object.
           * @param {boolean} [options.leading=true] Specify invoking on the leading
           *  edge of the timeout.
           * @param {boolean} [options.trailing=true] Specify invoking on the trailing
           *  edge of the timeout.
           * @returns {Function} Returns the new throttled function.
           * @example
           *
           * // avoid excessively updating the position while scrolling
           * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
           *
           * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
           * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
           *   'trailing': false
           * }));
           *
           * // cancel a trailing throttled call
           * jQuery(window).on('popstate', throttled.cancel);
           */
          function throttle(func, wait, options) {
            var leading = true,
              trailing = true;

            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            if (options === false) {
              leading = false;
            } else if (isObject(options)) {
              leading = 'leading' in options ? !!options.leading : leading;
              trailing = 'trailing' in options ? !!options.trailing : trailing;
            }
            debounceOptions.leading = leading;
            debounceOptions.maxWait = +wait;
            debounceOptions.trailing = trailing;
            return debounce(func, wait, debounceOptions);
          }

          /**
           * Creates a function that provides `value` to the wrapper function as its
           * first argument. Any additional arguments provided to the function are
           * appended to those provided to the wrapper function. The wrapper is invoked
           * with the `this` binding of the created function.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {*} value The value to wrap.
           * @param {Function} wrapper The wrapper function.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var p = _.wrap(_.escape, function(func, text) {
           *   return '<p>' + func(text) + '</p>';
           * });
           *
           * p('fred, barney, & pebbles');
           * // => '<p>fred, barney, &amp; pebbles</p>'
           */
          function wrap(value, wrapper) {
            wrapper = wrapper == null ? identity : wrapper;
            return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
          }

          /*------------------------------------------------------------------------*/

          /**
           * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
           * otherwise they are assigned by reference. If `customizer` is provided it is
           * invoked to produce the cloned values. If `customizer` returns `undefined`
           * cloning is handled by the method instead. The `customizer` is bound to
           * `thisArg` and invoked with two argument; (value [, index|key, object]).
           *
           * **Note:** This method is loosely based on the
           * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
           * The enumerable properties of `arguments` objects and objects created by
           * constructors other than `Object` are cloned to plain `Object` objects. An
           * empty object is returned for uncloneable values such as functions, DOM nodes,
           * Maps, Sets, and WeakMaps.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @param {Function} [customizer] The function to customize cloning values.
           * @param {*} [thisArg] The `this` binding of `customizer`.
           * @returns {*} Returns the cloned value.
           * @example
           *
           * var users = [
           *   { 'user': 'barney' },
           *   { 'user': 'fred' }
           * ];
           *
           * var shallow = _.clone(users);
           * shallow[0] === users[0];
           * // => true
           *
           * var deep = _.clone(users, true);
           * deep[0] === users[0];
           * // => false
           *
           * // using a customizer callback
           * var el = _.clone(document.body, function(value) {
           *   if (_.isElement(value)) {
           *     return value.cloneNode(false);
           *   }
           * });
           *
           * el === document.body
           * // => false
           * el.nodeName
           * // => BODY
           * el.childNodes.length;
           * // => 0
           */
          function clone(value, isDeep, customizer, thisArg) {
            if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
              isDeep = false;
            }
            else if (typeof isDeep == 'function') {
              thisArg = customizer;
              customizer = isDeep;
              isDeep = false;
            }
            return typeof customizer == 'function'
              ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
              : baseClone(value, isDeep);
          }

          /**
           * Creates a deep clone of `value`. If `customizer` is provided it is invoked
           * to produce the cloned values. If `customizer` returns `undefined` cloning
           * is handled by the method instead. The `customizer` is bound to `thisArg`
           * and invoked with two argument; (value [, index|key, object]).
           *
           * **Note:** This method is loosely based on the
           * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
           * The enumerable properties of `arguments` objects and objects created by
           * constructors other than `Object` are cloned to plain `Object` objects. An
           * empty object is returned for uncloneable values such as functions, DOM nodes,
           * Maps, Sets, and WeakMaps.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to deep clone.
           * @param {Function} [customizer] The function to customize cloning values.
           * @param {*} [thisArg] The `this` binding of `customizer`.
           * @returns {*} Returns the deep cloned value.
           * @example
           *
           * var users = [
           *   { 'user': 'barney' },
           *   { 'user': 'fred' }
           * ];
           *
           * var deep = _.cloneDeep(users);
           * deep[0] === users[0];
           * // => false
           *
           * // using a customizer callback
           * var el = _.cloneDeep(document.body, function(value) {
           *   if (_.isElement(value)) {
           *     return value.cloneNode(true);
           *   }
           * });
           *
           * el === document.body
           * // => false
           * el.nodeName
           * // => BODY
           * el.childNodes.length;
           * // => 20
           */
          function cloneDeep(value, customizer, thisArg) {
            return typeof customizer == 'function'
              ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
              : baseClone(value, true);
          }

          /**
           * Checks if `value` is greater than `other`.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
           * @example
           *
           * _.gt(3, 1);
           * // => true
           *
           * _.gt(3, 3);
           * // => false
           *
           * _.gt(1, 3);
           * // => false
           */
          function gt(value, other) {
            return value > other;
          }

          /**
           * Checks if `value` is greater than or equal to `other`.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
           * @example
           *
           * _.gte(3, 1);
           * // => true
           *
           * _.gte(3, 3);
           * // => true
           *
           * _.gte(1, 3);
           * // => false
           */
          function gte(value, other) {
            return value >= other;
          }

          /**
           * Checks if `value` is classified as an `arguments` object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isArguments(function() { return arguments; }());
           * // => true
           *
           * _.isArguments([1, 2, 3]);
           * // => false
           */
          function isArguments(value) {
            return isObjectLike(value) && isArrayLike(value) && objToString.call(value) == argsTag;
          }

          /**
           * Checks if `value` is classified as an `Array` object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isArray([1, 2, 3]);
           * // => true
           *
           * _.isArray(function() { return arguments; }());
           * // => false
           */
          var isArray = nativeIsArray || function (value) {
            return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
          };

          /**
           * Checks if `value` is classified as a boolean primitive or object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isBoolean(false);
           * // => true
           *
           * _.isBoolean(null);
           * // => false
           */
          function isBoolean(value) {
            return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
          }

          /**
           * Checks if `value` is classified as a `Date` object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isDate(new Date);
           * // => true
           *
           * _.isDate('Mon April 23 2012');
           * // => false
           */
          function isDate(value) {
            return isObjectLike(value) && objToString.call(value) == dateTag;
          }

          /**
           * Checks if `value` is a DOM element.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
           * @example
           *
           * _.isElement(document.body);
           * // => true
           *
           * _.isElement('<body>');
           * // => false
           */
          function isElement(value) {
            return !!value && value.nodeType === 1 && isObjectLike(value) &&
              (objToString.call(value).indexOf('Element') > -1);
          }
          // Fallback for environments without DOM support.
          if (!support.dom) {
            isElement = function (value) {
              return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
            };
          }

          /**
           * Checks if `value` is empty. A value is considered empty unless it is an
           * `arguments` object, array, string, or jQuery-like collection with a length
           * greater than `0` or an object with own enumerable properties.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {Array|Object|string} value The value to inspect.
           * @returns {boolean} Returns `true` if `value` is empty, else `false`.
           * @example
           *
           * _.isEmpty(null);
           * // => true
           *
           * _.isEmpty(true);
           * // => true
           *
           * _.isEmpty(1);
           * // => true
           *
           * _.isEmpty([1, 2, 3]);
           * // => false
           *
           * _.isEmpty({ 'a': 1 });
           * // => false
           */
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
              (isObjectLike(value) && isFunction(value.splice)))) {
              return !value.length;
            }
            return !keys(value).length;
          }

          /**
           * Performs a deep comparison between two values to determine if they are
           * equivalent. If `customizer` is provided it is invoked to compare values.
           * If `customizer` returns `undefined` comparisons are handled by the method
           * instead. The `customizer` is bound to `thisArg` and invoked with three
           * arguments: (value, other [, index|key]).
           *
           * **Note:** This method supports comparing arrays, booleans, `Date` objects,
           * numbers, `Object` objects, regexes, and strings. Objects are compared by
           * their own, not inherited, enumerable properties. Functions and DOM nodes
           * are **not** supported. Provide a customizer function to extend support
           * for comparing other values.
           *
           * @static
           * @memberOf _
           * @alias eq
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @param {Function} [customizer] The function to customize value comparisons.
           * @param {*} [thisArg] The `this` binding of `customizer`.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'user': 'fred' };
           * var other = { 'user': 'fred' };
           *
           * object == other;
           * // => false
           *
           * _.isEqual(object, other);
           * // => true
           *
           * // using a customizer callback
           * var array = ['hello', 'goodbye'];
           * var other = ['hi', 'goodbye'];
           *
           * _.isEqual(array, other, function(value, other) {
           *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
           *     return true;
           *   }
           * });
           * // => true
           */
          function isEqual(value, other, customizer, thisArg) {
            customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
            var result = customizer ? customizer(value, other) : undefined;
            return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
          }

          /**
           * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
           * `SyntaxError`, `TypeError`, or `URIError` object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
           * @example
           *
           * _.isError(new Error);
           * // => true
           *
           * _.isError(Error);
           * // => false
           */
          function isError(value) {
            return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
          }

          /**
           * Checks if `value` is a finite primitive number.
           *
           * **Note:** This method is based on [`Number.isFinite`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite).
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
           * @example
           *
           * _.isFinite(10);
           * // => true
           *
           * _.isFinite('10');
           * // => false
           *
           * _.isFinite(true);
           * // => false
           *
           * _.isFinite(Object(10));
           * // => false
           *
           * _.isFinite(Infinity);
           * // => false
           */
          var isFinite = nativeNumIsFinite || function (value) {
            return typeof value == 'number' && nativeIsFinite(value);
          };

          /**
           * Checks if `value` is classified as a `Function` object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isFunction(_);
           * // => true
           *
           * _.isFunction(/abc/);
           * // => false
           */
          var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function (value) {
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in older versions of Chrome and Safari which return 'function' for regexes
            // and Safari 8 equivalents which return 'object' for typed array constructors.
            return objToString.call(value) == funcTag;
          };

          /**
           * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
           * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an object, else `false`.
           * @example
           *
           * _.isObject({});
           * // => true
           *
           * _.isObject([1, 2, 3]);
           * // => true
           *
           * _.isObject(1);
           * // => false
           */
          function isObject(value) {
            // Avoid a V8 JIT bug in Chrome 19-20.
            // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
            var type = typeof value;
            return !!value && (type == 'object' || type == 'function');
          }

          /**
           * Performs a deep comparison between `object` and `source` to determine if
           * `object` contains equivalent property values. If `customizer` is provided
           * it is invoked to compare values. If `customizer` returns `undefined`
           * comparisons are handled by the method instead. The `customizer` is bound
           * to `thisArg` and invoked with three arguments: (value, other, index|key).
           *
           * **Note:** This method supports comparing properties of arrays, booleans,
           * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
           * and DOM nodes are **not** supported. Provide a customizer function to extend
           * support for comparing other values.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property values to match.
           * @param {Function} [customizer] The function to customize value comparisons.
           * @param {*} [thisArg] The `this` binding of `customizer`.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           * @example
           *
           * var object = { 'user': 'fred', 'age': 40 };
           *
           * _.isMatch(object, { 'age': 40 });
           * // => true
           *
           * _.isMatch(object, { 'age': 36 });
           * // => false
           *
           * // using a customizer callback
           * var object = { 'greeting': 'hello' };
           * var source = { 'greeting': 'hi' };
           *
           * _.isMatch(object, source, function(value, other) {
           *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
           * });
           * // => true
           */
          function isMatch(object, source, customizer, thisArg) {
            customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
            return baseIsMatch(object, getMatchData(source), customizer);
          }

          /**
           * Checks if `value` is `NaN`.
           *
           * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
           * which returns `true` for `undefined` and other non-numeric values.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
           * @example
           *
           * _.isNaN(NaN);
           * // => true
           *
           * _.isNaN(new Number(NaN));
           * // => true
           *
           * isNaN(undefined);
           * // => true
           *
           * _.isNaN(undefined);
           * // => false
           */
          function isNaN(value) {
            // An `NaN` primitive is the only value that is not equal to itself.
            // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
            return isNumber(value) && value != +value;
          }

          /**
           * Checks if `value` is a native function.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
           * @example
           *
           * _.isNative(Array.prototype.push);
           * // => true
           *
           * _.isNative(_);
           * // => false
           */
          function isNative(value) {
            if (value == null) {
              return false;
            }
            if (objToString.call(value) == funcTag) {
              return reIsNative.test(fnToString.call(value));
            }
            return isObjectLike(value) && reIsHostCtor.test(value);
          }

          /**
           * Checks if `value` is `null`.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
           * @example
           *
           * _.isNull(null);
           * // => true
           *
           * _.isNull(void 0);
           * // => false
           */
          function isNull(value) {
            return value === null;
          }

          /**
           * Checks if `value` is classified as a `Number` primitive or object.
           *
           * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
           * as numbers, use the `_.isFinite` method.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isNumber(8.4);
           * // => true
           *
           * _.isNumber(NaN);
           * // => true
           *
           * _.isNumber('8.4');
           * // => false
           */
          function isNumber(value) {
            return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
          }

          /**
           * Checks if `value` is a plain object, that is, an object created by the
           * `Object` constructor or one with a `[[Prototype]]` of `null`.
           *
           * **Note:** This method assumes objects created by the `Object` constructor
           * have no inherited enumerable properties.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * _.isPlainObject(new Foo);
           * // => false
           *
           * _.isPlainObject([1, 2, 3]);
           * // => false
           *
           * _.isPlainObject({ 'x': 0, 'y': 0 });
           * // => true
           *
           * _.isPlainObject(Object.create(null));
           * // => true
           */
          var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function (value) {
            if (!(value && objToString.call(value) == objectTag)) {
              return false;
            }
            var valueOf = getNative(value, 'valueOf'),
              objProto = valueOf && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

            return objProto
              ? (value == objProto || getPrototypeOf(value) == objProto)
              : shimIsPlainObject(value);
          };

          /**
           * Checks if `value` is classified as a `RegExp` object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isRegExp(/abc/);
           * // => true
           *
           * _.isRegExp('/abc/');
           * // => false
           */
          function isRegExp(value) {
            return isObjectLike(value) && objToString.call(value) == regexpTag;
          }

          /**
           * Checks if `value` is classified as a `String` primitive or object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isString('abc');
           * // => true
           *
           * _.isString(1);
           * // => false
           */
          function isString(value) {
            return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
          }

          /**
           * Checks if `value` is classified as a typed array.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isTypedArray(new Uint8Array);
           * // => true
           *
           * _.isTypedArray([]);
           * // => false
           */
          function isTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
          }

          /**
           * Checks if `value` is `undefined`.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
           * @example
           *
           * _.isUndefined(void 0);
           * // => true
           *
           * _.isUndefined(null);
           * // => false
           */
          function isUndefined(value) {
            return value === undefined;
          }

          /**
           * Checks if `value` is less than `other`.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
           * @example
           *
           * _.lt(1, 3);
           * // => true
           *
           * _.lt(3, 3);
           * // => false
           *
           * _.lt(3, 1);
           * // => false
           */
          function lt(value, other) {
            return value < other;
          }

          /**
           * Checks if `value` is less than or equal to `other`.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
           * @example
           *
           * _.lte(1, 3);
           * // => true
           *
           * _.lte(3, 3);
           * // => true
           *
           * _.lte(3, 1);
           * // => false
           */
          function lte(value, other) {
            return value <= other;
          }

          /**
           * Converts `value` to an array.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {Array} Returns the converted array.
           * @example
           *
           * (function() {
           *   return _.toArray(arguments).slice(1);
           * }(1, 2, 3));
           * // => [2, 3]
           */
          function toArray(value) {
            var length = value ? getLength(value) : 0;
            if (!isLength(length)) {
              return values(value);
            }
            if (!length) {
              return [];
            }
            return arrayCopy(value);
          }

          /**
           * Converts `value` to a plain object flattening inherited enumerable
           * properties of `value` to own properties of the plain object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {Object} Returns the converted plain object.
           * @example
           *
           * function Foo() {
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.assign({ 'a': 1 }, new Foo);
           * // => { 'a': 1, 'b': 2 }
           *
           * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
           * // => { 'a': 1, 'b': 2, 'c': 3 }
           */
          function toPlainObject(value) {
            return baseCopy(value, keysIn(value));
          }

          /*------------------------------------------------------------------------*/

          /**
           * Assigns own enumerable properties of source object(s) to the destination
           * object. Subsequent sources overwrite property assignments of previous sources.
           * If `customizer` is provided it is invoked to produce the assigned values.
           * The `customizer` is bound to `thisArg` and invoked with five arguments:
           * (objectValue, sourceValue, key, object, source).
           *
           * **Note:** This method mutates `object` and is based on
           * [`Object.assign`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign).
           *
           * @static
           * @memberOf _
           * @alias extend
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @param {Function} [customizer] The function to customize assigned values.
           * @param {*} [thisArg] The `this` binding of `customizer`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
           * // => { 'user': 'fred', 'age': 40 }
           *
           * // using a customizer callback
           * var defaults = _.partialRight(_.assign, function(value, other) {
           *   return _.isUndefined(value) ? other : value;
           * });
           *
           * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
           * // => { 'user': 'barney', 'age': 36 }
           */
          var assign = createAssigner(function (object, source, customizer) {
            return customizer
              ? assignWith(object, source, customizer)
              : baseAssign(object, source);
          });

          /**
           * Creates an object that inherits from the given `prototype` object. If a
           * `properties` object is provided its own enumerable properties are assigned
           * to the created object.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} prototype The object to inherit from.
           * @param {Object} [properties] The properties to assign to the object.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Object} Returns the new object.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * function Circle() {
           *   Shape.call(this);
           * }
           *
           * Circle.prototype = _.create(Shape.prototype, {
           *   'constructor': Circle
           * });
           *
           * var circle = new Circle;
           * circle instanceof Circle;
           * // => true
           *
           * circle instanceof Shape;
           * // => true
           */
          function create(prototype, properties, guard) {
            var result = baseCreate(prototype);
            if (guard && isIterateeCall(prototype, properties, guard)) {
              properties = null;
            }
            return properties ? baseAssign(result, properties) : result;
          }

          /**
           * Assigns own enumerable properties of source object(s) to the destination
           * object for all destination properties that resolve to `undefined`. Once a
           * property is set, additional values of the same property are ignored.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @example
           *
           * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
           * // => { 'user': 'barney', 'age': 36 }
           */
          var defaults = restParam(function (args) {
            var object = args[0];
            if (object == null) {
              return object;
            }
            args.push(assignDefaults);
            return assign.apply(undefined, args);
          });

          /**
           * This method is like `_.find` except that it returns the key of the first
           * element `predicate` returns truthy for instead of the element itself.
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to search.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
           * @example
           *
           * var users = {
           *   'barney':  { 'age': 36, 'active': true },
           *   'fred':    { 'age': 40, 'active': false },
           *   'pebbles': { 'age': 1,  'active': true }
           * };
           *
           * _.findKey(users, function(chr) {
           *   return chr.age < 40;
           * });
           * // => 'barney' (iteration order is not guaranteed)
           *
           * // using the `_.matches` callback shorthand
           * _.findKey(users, { 'age': 1, 'active': true });
           * // => 'pebbles'
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.findKey(users, 'active', false);
           * // => 'fred'
           *
           * // using the `_.property` callback shorthand
           * _.findKey(users, 'active');
           * // => 'barney'
           */
          var findKey = createFindKey(baseForOwn);

          /**
           * This method is like `_.findKey` except that it iterates over elements of
           * a collection in the opposite order.
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to search.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
           * @example
           *
           * var users = {
           *   'barney':  { 'age': 36, 'active': true },
           *   'fred':    { 'age': 40, 'active': false },
           *   'pebbles': { 'age': 1,  'active': true }
           * };
           *
           * _.findLastKey(users, function(chr) {
           *   return chr.age < 40;
           * });
           * // => returns `pebbles` assuming `_.findKey` returns `barney`
           *
           * // using the `_.matches` callback shorthand
           * _.findLastKey(users, { 'age': 36, 'active': true });
           * // => 'barney'
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.findLastKey(users, 'active', false);
           * // => 'fred'
           *
           * // using the `_.property` callback shorthand
           * _.findLastKey(users, 'active');
           * // => 'pebbles'
           */
          var findLastKey = createFindKey(baseForOwnRight);

          /**
           * Iterates over own and inherited enumerable properties of an object invoking
           * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
           * with three arguments: (value, key, object). Iteratee functions may exit
           * iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forIn(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
           */
          var forIn = createForIn(baseFor);

          /**
           * This method is like `_.forIn` except that it iterates over properties of
           * `object` in the opposite order.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forInRight(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
           */
          var forInRight = createForIn(baseForRight);

          /**
           * Iterates over own enumerable properties of an object invoking `iteratee`
           * for each property. The `iteratee` is bound to `thisArg` and invoked with
           * three arguments: (value, key, object). Iteratee functions may exit iteration
           * early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forOwn(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => logs 'a' and 'b' (iteration order is not guaranteed)
           */
          var forOwn = createForOwn(baseForOwn);

          /**
           * This method is like `_.forOwn` except that it iterates over properties of
           * `object` in the opposite order.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forOwnRight(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
           */
          var forOwnRight = createForOwn(baseForOwnRight);

          /**
           * Creates an array of function property names from all enumerable properties,
           * own and inherited, of `object`.
           *
           * @static
           * @memberOf _
           * @alias methods
           * @category Object
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns the new array of property names.
           * @example
           *
           * _.functions(_);
           * // => ['after', 'ary', 'assign', ...]
           */
          function functions(object) {
            return baseFunctions(object, keysIn(object));
          }

          /**
           * Gets the property value at `path` of `object`. If the resolved value is
           * `undefined` the `defaultValue` is used in its place.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to get.
           * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.get(object, 'a[0].b.c');
           * // => 3
           *
           * _.get(object, ['a', '0', 'b', 'c']);
           * // => 3
           *
           * _.get(object, 'a.b.c', 'default');
           * // => 'default'
           */
          function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
            return result === undefined ? defaultValue : result;
          }

          /**
           * Checks if `path` is a direct property.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path to check.
           * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
           * @example
           *
           * var object = { 'a': { 'b': { 'c': 3 } } };
           *
           * _.has(object, 'a');
           * // => true
           *
           * _.has(object, 'a.b.c');
           * // => true
           *
           * _.has(object, ['a', 'b', 'c']);
           * // => true
           */
          function has(object, path) {
            if (object == null) {
              return false;
            }
            var result = hasOwnProperty.call(object, path);
            if (!result && !isKey(path)) {
              path = toPath(path);
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              if (object == null) {
                return false;
              }
              path = last(path);
              result = hasOwnProperty.call(object, path);
            }
            return result || (isLength(object.length) && isIndex(path, object.length) &&
              (isArray(object) || isArguments(object)));
          }

          /**
           * Creates an object composed of the inverted keys and values of `object`.
           * If `object` contains duplicate values, subsequent values overwrite property
           * assignments of previous values unless `multiValue` is `true`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to invert.
           * @param {boolean} [multiValue] Allow multiple values per key.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Object} Returns the new inverted object.
           * @example
           *
           * var object = { 'a': 1, 'b': 2, 'c': 1 };
           *
           * _.invert(object);
           * // => { '1': 'c', '2': 'b' }
           *
           * // with `multiValue`
           * _.invert(object, true);
           * // => { '1': ['a', 'c'], '2': ['b'] }
           */
          function invert(object, multiValue, guard) {
            if (guard && isIterateeCall(object, multiValue, guard)) {
              multiValue = null;
            }
            var index = -1,
              props = keys(object),
              length = props.length,
              result = {};

            while (++index < length) {
              var key = props[index],
                value = object[key];

              if (multiValue) {
                if (hasOwnProperty.call(result, value)) {
                  result[value].push(key);
                } else {
                  result[value] = [key];
                }
              }
              else {
                result[value] = key;
              }
            }
            return result;
          }

          /**
           * Creates an array of the own enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects. See the
           * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
           * for more details.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keys(new Foo);
           * // => ['a', 'b'] (iteration order is not guaranteed)
           *
           * _.keys('hi');
           * // => ['0', '1']
           */
          var keys = !nativeKeys ? shimKeys : function (object) {
            var Ctor = object == null ? null : object.constructor;
            if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
              (typeof object != 'function' && isArrayLike(object))) {
              return shimKeys(object);
            }
            return isObject(object) ? nativeKeys(object) : [];
          };

          /**
           * Creates an array of the own and inherited enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keysIn(new Foo);
           * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
           */
          function keysIn(object) {
            if (object == null) {
              return [];
            }
            if (!isObject(object)) {
              object = Object(object);
            }
            var length = object.length;
            length = (length && isLength(length) &&
              (isArray(object) || isArguments(object)) && length) || 0;

            var Ctor = object.constructor,
              index = -1,
              isProto = typeof Ctor == 'function' && Ctor.prototype === object,
              result = Array(length),
              skipIndexes = length > 0;

            while (++index < length) {
              result[index] = (index + '');
            }
            for (var key in object) {
              if (!(skipIndexes && isIndex(key, length)) &&
                !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * The opposite of `_.mapValues`; this method creates an object with the
           * same values as `object` and keys generated by running each own enumerable
           * property of `object` through `iteratee`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns the new mapped object.
           * @example
           *
           * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
           *   return key + value;
           * });
           * // => { 'a1': 1, 'b2': 2 }
           */
          var mapKeys = createObjectMapper(true);

          /**
           * Creates an object with the same keys as `object` and values generated by
           * running each own enumerable property of `object` through `iteratee`. The
           * iteratee function is bound to `thisArg` and invoked with three arguments:
           * (value, key, object).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns the new mapped object.
           * @example
           *
           * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
           *   return n * 3;
           * });
           * // => { 'a': 3, 'b': 6 }
           *
           * var users = {
           *   'fred':    { 'user': 'fred',    'age': 40 },
           *   'pebbles': { 'user': 'pebbles', 'age': 1 }
           * };
           *
           * // using the `_.property` callback shorthand
           * _.mapValues(users, 'age');
           * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
           */
          var mapValues = createObjectMapper();

          /**
           * Recursively merges own enumerable properties of the source object(s), that
           * don't resolve to `undefined` into the destination object. Subsequent sources
           * overwrite property assignments of previous sources. If `customizer` is
           * provided it is invoked to produce the merged values of the destination and
           * source properties. If `customizer` returns `undefined` merging is handled
           * by the method instead. The `customizer` is bound to `thisArg` and invoked
           * with five arguments: (objectValue, sourceValue, key, object, source).
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @param {Function} [customizer] The function to customize assigned values.
           * @param {*} [thisArg] The `this` binding of `customizer`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var users = {
           *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
           * };
           *
           * var ages = {
           *   'data': [{ 'age': 36 }, { 'age': 40 }]
           * };
           *
           * _.merge(users, ages);
           * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
           *
           * // using a customizer callback
           * var object = {
           *   'fruits': ['apple'],
           *   'vegetables': ['beet']
           * };
           *
           * var other = {
           *   'fruits': ['banana'],
           *   'vegetables': ['carrot']
           * };
           *
           * _.merge(object, other, function(a, b) {
           *   if (_.isArray(a)) {
           *     return a.concat(b);
           *   }
           * });
           * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
           */
          var merge = createAssigner(baseMerge);

          /**
           * The opposite of `_.pick`; this method creates an object composed of the
           * own and inherited enumerable properties of `object` that are not omitted.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The source object.
           * @param {Function|...(string|string[])} [predicate] The function invoked per
           *  iteration or property names to omit, specified as individual property
           *  names or arrays of property names.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'user': 'fred', 'age': 40 };
           *
           * _.omit(object, 'age');
           * // => { 'user': 'fred' }
           *
           * _.omit(object, _.isNumber);
           * // => { 'user': 'fred' }
           */
          var omit = restParam(function (object, props) {
            if (object == null) {
              return {};
            }
            if (typeof props[0] != 'function') {
              var props = arrayMap(baseFlatten(props), String);
              return pickByArray(object, baseDifference(keysIn(object), props));
            }
            var predicate = bindCallback(props[0], props[1], 3);
            return pickByCallback(object, function (value, key, object) {
              return !predicate(value, key, object);
            });
          });

          /**
           * Creates a two dimensional array of the key-value pairs for `object`,
           * e.g. `[[key1, value1], [key2, value2]]`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the new array of key-value pairs.
           * @example
           *
           * _.pairs({ 'barney': 36, 'fred': 40 });
           * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
           */
          function pairs(object) {
            object = toObject(object);

            var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);

            while (++index < length) {
              var key = props[index];
              result[index] = [key, object[key]];
            }
            return result;
          }

          /**
           * Creates an object composed of the picked `object` properties. Property
           * names may be specified as individual arguments or as arrays of property
           * names. If `predicate` is provided it is invoked for each property of `object`
           * picking the properties `predicate` returns truthy for. The predicate is
           * bound to `thisArg` and invoked with three arguments: (value, key, object).
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The source object.
           * @param {Function|...(string|string[])} [predicate] The function invoked per
           *  iteration or property names to pick, specified as individual property
           *  names or arrays of property names.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'user': 'fred', 'age': 40 };
           *
           * _.pick(object, 'user');
           * // => { 'user': 'fred' }
           *
           * _.pick(object, _.isString);
           * // => { 'user': 'fred' }
           */
          var pick = restParam(function (object, props) {
            if (object == null) {
              return {};
            }
            return typeof props[0] == 'function'
              ? pickByCallback(object, bindCallback(props[0], props[1], 3))
              : pickByArray(object, baseFlatten(props));
          });

          /**
           * This method is like `_.get` except that if the resolved value is a function
           * it is invoked with the `this` binding of its parent object and its result
           * is returned.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to resolve.
           * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
           *
           * _.result(object, 'a[0].b.c1');
           * // => 3
           *
           * _.result(object, 'a[0].b.c2');
           * // => 4
           *
           * _.result(object, 'a.b.c', 'default');
           * // => 'default'
           *
           * _.result(object, 'a.b.c', _.constant('default'));
           * // => 'default'
           */
          function result(object, path, defaultValue) {
            var result = object == null ? undefined : object[path];
            if (result === undefined) {
              if (object != null && !isKey(path, object)) {
                path = toPath(path);
                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                result = object == null ? undefined : object[last(path)];
              }
              result = result === undefined ? defaultValue : result;
            }
            return isFunction(result) ? result.call(object) : result;
          }

          /**
           * Sets the property value of `path` on `object`. If a portion of `path`
           * does not exist it is created.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to augment.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.set(object, 'a[0].b.c', 4);
           * console.log(object.a[0].b.c);
           * // => 4
           *
           * _.set(object, 'x[0].y.z', 5);
           * console.log(object.x[0].y.z);
           * // => 5
           */
          function set(object, path, value) {
            if (object == null) {
              return object;
            }
            var pathKey = (path + '');
            path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

            var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;

            while (nested != null && ++index < length) {
              var key = path[index];
              if (isObject(nested)) {
                if (index == lastIndex) {
                  nested[key] = value;
                } else if (nested[key] == null) {
                  nested[key] = isIndex(path[index + 1]) ? [] : {};
                }
              }
              nested = nested[key];
            }
            return object;
          }

          /**
           * An alternative to `_.reduce`; this method transforms `object` to a new
           * `accumulator` object which is the result of running each of its own enumerable
           * properties through `iteratee`, with each invocation potentially mutating
           * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
           * with four arguments: (accumulator, value, key, object). Iteratee functions
           * may exit iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Array|Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The custom accumulator value.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * _.transform([2, 3, 4], function(result, n) {
           *   result.push(n *= n);
           *   return n % 2 == 0;
           * });
           * // => [4, 9]
           *
           * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
           *   result[key] = n * 3;
           * });
           * // => { 'a': 3, 'b': 6 }
           */
          function transform(object, iteratee, accumulator, thisArg) {
            var isArr = isArray(object) || isTypedArray(object);
            iteratee = getCallback(iteratee, thisArg, 4);

            if (accumulator == null) {
              if (isArr || isObject(object)) {
                var Ctor = object.constructor;
                if (isArr) {
                  accumulator = isArray(object) ? new Ctor : [];
                } else {
                  accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : null);
                }
              } else {
                accumulator = {};
              }
            }
            (isArr ? arrayEach : baseForOwn)(object, function (value, index, object) {
              return iteratee(accumulator, value, index, object);
            });
            return accumulator;
          }

          /**
           * Creates an array of the own enumerable property values of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property values.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.values(new Foo);
           * // => [1, 2] (iteration order is not guaranteed)
           *
           * _.values('hi');
           * // => ['h', 'i']
           */
          function values(object) {
            return baseValues(object, keys(object));
          }

          /**
           * Creates an array of the own and inherited enumerable property values
           * of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property values.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.valuesIn(new Foo);
           * // => [1, 2, 3] (iteration order is not guaranteed)
           */
          function valuesIn(object) {
            return baseValues(object, keysIn(object));
          }

          /*------------------------------------------------------------------------*/

          /**
           * Checks if `n` is between `start` and up to but not including, `end`. If
           * `end` is not specified it is set to `start` with `start` then set to `0`.
           *
           * @static
           * @memberOf _
           * @category Number
           * @param {number} n The number to check.
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
           * @example
           *
           * _.inRange(3, 2, 4);
           * // => true
           *
           * _.inRange(4, 8);
           * // => true
           *
           * _.inRange(4, 2);
           * // => false
           *
           * _.inRange(2, 2);
           * // => false
           *
           * _.inRange(1.2, 2);
           * // => true
           *
           * _.inRange(5.2, 4);
           * // => false
           */
          function inRange(value, start, end) {
            start = +start || 0;
            if (typeof end === 'undefined') {
              end = start;
              start = 0;
            } else {
              end = +end || 0;
            }
            return value >= nativeMin(start, end) && value < nativeMax(start, end);
          }

          /**
           * Produces a random number between `min` and `max` (inclusive). If only one
           * argument is provided a number between `0` and the given number is returned.
           * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
           * number is returned instead of an integer.
           *
           * @static
           * @memberOf _
           * @category Number
           * @param {number} [min=0] The minimum possible value.
           * @param {number} [max=1] The maximum possible value.
           * @param {boolean} [floating] Specify returning a floating-point number.
           * @returns {number} Returns the random number.
           * @example
           *
           * _.random(0, 5);
           * // => an integer between 0 and 5
           *
           * _.random(5);
           * // => also an integer between 0 and 5
           *
           * _.random(5, true);
           * // => a floating-point number between 0 and 5
           *
           * _.random(1.2, 5.2);
           * // => a floating-point number between 1.2 and 5.2
           */
          function random(min, max, floating) {
            if (floating && isIterateeCall(min, max, floating)) {
              max = floating = null;
            }
            var noMin = min == null,
              noMax = max == null;

            if (floating == null) {
              if (noMax && typeof min == 'boolean') {
                floating = min;
                min = 1;
              }
              else if (typeof max == 'boolean') {
                floating = max;
                noMax = true;
              }
            }
            if (noMin && noMax) {
              max = 1;
              noMax = false;
            }
            min = +min || 0;
            if (noMax) {
              max = min;
              min = 0;
            } else {
              max = +max || 0;
            }
            if (floating || min % 1 || max % 1) {
              var rand = nativeRandom();
              return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
            }
            return baseRandom(min, max);
          }

          /*------------------------------------------------------------------------*/

          /**
           * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the camel cased string.
           * @example
           *
           * _.camelCase('Foo Bar');
           * // => 'fooBar'
           *
           * _.camelCase('--foo-bar');
           * // => 'fooBar'
           *
           * _.camelCase('__foo_bar__');
           * // => 'fooBar'
           */
          var camelCase = createCompounder(function (result, word, index) {
            word = word.toLowerCase();
            return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
          });

          /**
           * Capitalizes the first character of `string`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to capitalize.
           * @returns {string} Returns the capitalized string.
           * @example
           *
           * _.capitalize('fred');
           * // => 'Fred'
           */
          function capitalize(string) {
            string = baseToString(string);
            return string && (string.charAt(0).toUpperCase() + string.slice(1));
          }

          /**
           * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
           * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to deburr.
           * @returns {string} Returns the deburred string.
           * @example
           *
           * _.deburr('déjà vu');
           * // => 'deja vu'
           */
          function deburr(string) {
            string = baseToString(string);
            return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
          }

          /**
           * Checks if `string` ends with the given target string.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to search.
           * @param {string} [target] The string to search for.
           * @param {number} [position=string.length] The position to search from.
           * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
           * @example
           *
           * _.endsWith('abc', 'c');
           * // => true
           *
           * _.endsWith('abc', 'b');
           * // => false
           *
           * _.endsWith('abc', 'b', 2);
           * // => true
           */
          function endsWith(string, target, position) {
            string = baseToString(string);
            target = (target + '');

            var length = string.length;
            position = position === undefined
              ? length
              : nativeMin(position < 0 ? 0 : (+position || 0), length);

            position -= target.length;
            return position >= 0 && string.indexOf(target, position) == position;
          }

          /**
           * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
           * their corresponding HTML entities.
           *
           * **Note:** No other characters are escaped. To escape additional characters
           * use a third-party library like [_he_](https://mths.be/he).
           *
           * Though the ">" character is escaped for symmetry, characters like
           * ">" and "/" don't need escaping in HTML and have no special meaning
           * unless they're part of a tag or unquoted attribute value.
           * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
           * (under "semi-related fun fact") for more details.
           *
           * Backticks are escaped because in Internet Explorer < 9, they can break out
           * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
           * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
           * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
           * for more details.
           *
           * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
           * to reduce XSS vectors.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to escape.
           * @returns {string} Returns the escaped string.
           * @example
           *
           * _.escape('fred, barney, & pebbles');
           * // => 'fred, barney, &amp; pebbles'
           */
          function escape(string) {
            // Reset `lastIndex` because in IE < 9 `String#replace` does not.
            string = baseToString(string);
            return (string && reHasUnescapedHtml.test(string))
              ? string.replace(reUnescapedHtml, escapeHtmlChar)
              : string;
          }

          /**
           * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
           * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to escape.
           * @returns {string} Returns the escaped string.
           * @example
           *
           * _.escapeRegExp('[lodash](https://lodash.com/)');
           * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
           */
          function escapeRegExp(string) {
            string = baseToString(string);
            return (string && reHasRegExpChars.test(string))
              ? string.replace(reRegExpChars, '\\$&')
              : string;
          }

          /**
           * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the kebab cased string.
           * @example
           *
           * _.kebabCase('Foo Bar');
           * // => 'foo-bar'
           *
           * _.kebabCase('fooBar');
           * // => 'foo-bar'
           *
           * _.kebabCase('__foo_bar__');
           * // => 'foo-bar'
           */
          var kebabCase = createCompounder(function (result, word, index) {
            return result + (index ? '-' : '') + word.toLowerCase();
          });

          /**
           * Pads `string` on the left and right sides if it's shorter than `length`.
           * Padding characters are truncated if they can't be evenly divided by `length`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.pad('abc', 8);
           * // => '  abc   '
           *
           * _.pad('abc', 8, '_-');
           * // => '_-abc_-_'
           *
           * _.pad('abc', 3);
           * // => 'abc'
           */
          function pad(string, length, chars) {
            string = baseToString(string);
            length = +length;

            var strLength = string.length;
            if (strLength >= length || !nativeIsFinite(length)) {
              return string;
            }
            var mid = (length - strLength) / 2,
              leftLength = floor(mid),
              rightLength = ceil(mid);

            chars = createPadding('', rightLength, chars);
            return chars.slice(0, leftLength) + string + chars;
          }

          /**
           * Pads `string` on the left side if it's shorter than `length`. Padding
           * characters are truncated if they exceed `length`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.padLeft('abc', 6);
           * // => '   abc'
           *
           * _.padLeft('abc', 6, '_-');
           * // => '_-_abc'
           *
           * _.padLeft('abc', 3);
           * // => 'abc'
           */
          var padLeft = createPadDir();

          /**
           * Pads `string` on the right side if it's shorter than `length`. Padding
           * characters are truncated if they exceed `length`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.padRight('abc', 6);
           * // => 'abc   '
           *
           * _.padRight('abc', 6, '_-');
           * // => 'abc_-_'
           *
           * _.padRight('abc', 3);
           * // => 'abc'
           */
          var padRight = createPadDir(true);

          /**
           * Converts `string` to an integer of the specified radix. If `radix` is
           * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
           * in which case a `radix` of `16` is used.
           *
           * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
           * of `parseInt`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} string The string to convert.
           * @param {number} [radix] The radix to interpret `value` by.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.parseInt('08');
           * // => 8
           *
           * _.map(['6', '08', '10'], _.parseInt);
           * // => [6, 8, 10]
           */
          function parseInt(string, radix, guard) {
            if (guard && isIterateeCall(string, radix, guard)) {
              radix = 0;
            }
            return nativeParseInt(string, radix);
          }
          // Fallback for environments with pre-ES5 implementations.
          if (nativeParseInt(whitespace + '08') != 8) {
            parseInt = function (string, radix, guard) {
              // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
              // Chrome fails to trim leading <BOM> whitespace characters.
              // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
              if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
                radix = 0;
              } else if (radix) {
                radix = +radix;
              }
              string = trim(string);
              return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
            };
          }

          /**
           * Repeats the given string `n` times.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to repeat.
           * @param {number} [n=0] The number of times to repeat the string.
           * @returns {string} Returns the repeated string.
           * @example
           *
           * _.repeat('*', 3);
           * // => '***'
           *
           * _.repeat('abc', 2);
           * // => 'abcabc'
           *
           * _.repeat('abc', 0);
           * // => ''
           */
          function repeat(string, n) {
            var result = '';
            string = baseToString(string);
            n = +n;
            if (n < 1 || !string || !nativeIsFinite(n)) {
              return result;
            }
            // Leverage the exponentiation by squaring algorithm for a faster repeat.
            // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
            do {
              if (n % 2) {
                result += string;
              }
              n = floor(n / 2);
              string += string;
            } while (n);

            return result;
          }

          /**
           * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the snake cased string.
           * @example
           *
           * _.snakeCase('Foo Bar');
           * // => 'foo_bar'
           *
           * _.snakeCase('fooBar');
           * // => 'foo_bar'
           *
           * _.snakeCase('--foo-bar');
           * // => 'foo_bar'
           */
          var snakeCase = createCompounder(function (result, word, index) {
            return result + (index ? '_' : '') + word.toLowerCase();
          });

          /**
           * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the start cased string.
           * @example
           *
           * _.startCase('--foo-bar');
           * // => 'Foo Bar'
           *
           * _.startCase('fooBar');
           * // => 'Foo Bar'
           *
           * _.startCase('__foo_bar__');
           * // => 'Foo Bar'
           */
          var startCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
          });

          /**
           * Checks if `string` starts with the given target string.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to search.
           * @param {string} [target] The string to search for.
           * @param {number} [position=0] The position to search from.
           * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
           * @example
           *
           * _.startsWith('abc', 'a');
           * // => true
           *
           * _.startsWith('abc', 'b');
           * // => false
           *
           * _.startsWith('abc', 'b', 1);
           * // => true
           */
          function startsWith(string, target, position) {
            string = baseToString(string);
            position = position == null
              ? 0
              : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

            return string.lastIndexOf(target, position) == position;
          }

          /**
           * Creates a compiled template function that can interpolate data properties
           * in "interpolate" delimiters, HTML-escape interpolated data properties in
           * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
           * properties may be accessed as free variables in the template. If a setting
           * object is provided it takes precedence over `_.templateSettings` values.
           *
           * **Note:** In the development build `_.template` utilizes
           * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
           * for easier debugging.
           *
           * For more information on precompiling templates see
           * [lodash's custom builds documentation](https://lodash.com/custom-builds).
           *
           * For more information on Chrome extension sandboxes see
           * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The template string.
           * @param {Object} [options] The options object.
           * @param {RegExp} [options.escape] The HTML "escape" delimiter.
           * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
           * @param {Object} [options.imports] An object to import into the template as free variables.
           * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
           * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
           * @param {string} [options.variable] The data object variable name.
           * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
           * @returns {Function} Returns the compiled template function.
           * @example
           *
           * // using the "interpolate" delimiter to create a compiled template
           * var compiled = _.template('hello <%= user %>!');
           * compiled({ 'user': 'fred' });
           * // => 'hello fred!'
           *
           * // using the HTML "escape" delimiter to escape data property values
           * var compiled = _.template('<b><%- value %></b>');
           * compiled({ 'value': '<script>' });
           * // => '<b>&lt;script&gt;</b>'
           *
           * // using the "evaluate" delimiter to execute JavaScript and generate HTML
           * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
           * compiled({ 'users': ['fred', 'barney'] });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // using the internal `print` function in "evaluate" delimiters
           * var compiled = _.template('<% print("hello " + user); %>!');
           * compiled({ 'user': 'barney' });
           * // => 'hello barney!'
           *
           * // using the ES delimiter as an alternative to the default "interpolate" delimiter
           * var compiled = _.template('hello ${ user }!');
           * compiled({ 'user': 'pebbles' });
           * // => 'hello pebbles!'
           *
           * // using custom template delimiters
           * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
           * var compiled = _.template('hello {{ user }}!');
           * compiled({ 'user': 'mustache' });
           * // => 'hello mustache!'
           *
           * // using backslashes to treat delimiters as plain text
           * var compiled = _.template('<%= "\\<%- value %\\>" %>');
           * compiled({ 'value': 'ignored' });
           * // => '<%- value %>'
           *
           * // using the `imports` option to import `jQuery` as `jq`
           * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
           * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
           * compiled({ 'users': ['fred', 'barney'] });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // using the `sourceURL` option to specify a custom sourceURL for the template
           * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
           * compiled(data);
           * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
           *
           * // using the `variable` option to ensure a with-statement isn't used in the compiled template
           * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
           * compiled.source;
           * // => function(data) {
           * //   var __t, __p = '';
           * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
           * //   return __p;
           * // }
           *
           * // using the `source` property to inline compiled templates for meaningful
           * // line numbers in error messages and a stack trace
           * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
           *   var JST = {\
           *     "main": ' + _.template(mainText).source + '\
           *   };\
           * ');
           */
          function template(string, options, otherOptions) {
            // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
            // and Laura Doktorova's doT.js (https://github.com/olado/doT).
            var settings = lodash.templateSettings;

            if (otherOptions && isIterateeCall(string, options, otherOptions)) {
              options = otherOptions = null;
            }
            string = baseToString(string);
            options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

            var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);

            var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";

            // Compile the regexp to match each delimiter.
            var reDelimiters = RegExp(
              (options.escape || reNoMatch).source + '|' +
              interpolate.source + '|' +
              (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
              (options.evaluate || reNoMatch).source + '|$'
              , 'g');

            // Use a sourceURL for easier debugging.
            var sourceURL = '//# sourceURL=' +
              ('sourceURL' in options
                ? options.sourceURL
                : ('lodash.templateSources[' + (++templateCounter) + ']')
              ) + '\n';

            string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);

              // Escape characters that can't be included in string literals.
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

              // Replace delimiters with snippets.
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;

              // The JS engine embedded in Adobe products requires returning the `match`
              // string in order to produce the correct `offset` value.
              return match;
            });

            source += "';\n";

            // If `variable` is not specified wrap a with-statement around the generated
            // code to add the data object to the top of the scope chain.
            var variable = options.variable;
            if (!variable) {
              source = 'with (obj) {\n' + source + '\n}\n';
            }
            // Cleanup code by stripping empty strings.
            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
              .replace(reEmptyStringMiddle, '$1')
              .replace(reEmptyStringTrailing, '$1;');

            // Frame code as the function body.
            source = 'function(' + (variable || 'obj') + ') {\n' +
              (variable
                ? ''
                : 'obj || (obj = {});\n'
              ) +
              "var __t, __p = ''" +
              (isEscaping
                ? ', __e = _.escape'
                : ''
              ) +
              (isEvaluating
                ? ', __j = Array.prototype.join;\n' +
                "function print() { __p += __j.call(arguments, '') }\n"
                : ';\n'
              ) +
              source +
              'return __p\n}';

            var result = attempt(function () {
              return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
            });

            // Provide the compiled function's source by its `toString` method or
            // the `source` property as a convenience for inlining compiled templates.
            result.source = source;
            if (isError(result)) {
              throw result;
            }
            return result;
          }

          /**
           * Removes leading and trailing whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trim('  abc  ');
           * // => 'abc'
           *
           * _.trim('-_-abc-_-', '_-');
           * // => 'abc'
           *
           * _.map(['  foo  ', '  bar  '], _.trim);
           * // => ['foo', 'bar']
           */
          function trim(string, chars, guard) {
            var value = string;
            string = baseToString(string);
            if (!string) {
              return string;
            }
            if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
              return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
            }
            chars = (chars + '');
            return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
          }

          /**
           * Removes leading whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trimLeft('  abc  ');
           * // => 'abc  '
           *
           * _.trimLeft('-_-abc-_-', '_-');
           * // => 'abc-_-'
           */
          function trimLeft(string, chars, guard) {
            var value = string;
            string = baseToString(string);
            if (!string) {
              return string;
            }
            if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
              return string.slice(trimmedLeftIndex(string));
            }
            return string.slice(charsLeftIndex(string, (chars + '')));
          }

          /**
           * Removes trailing whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trimRight('  abc  ');
           * // => '  abc'
           *
           * _.trimRight('-_-abc-_-', '_-');
           * // => '-_-abc'
           */
          function trimRight(string, chars, guard) {
            var value = string;
            string = baseToString(string);
            if (!string) {
              return string;
            }
            if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
              return string.slice(0, trimmedRightIndex(string) + 1);
            }
            return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
          }

          /**
           * Truncates `string` if it's longer than the given maximum string length.
           * The last characters of the truncated string are replaced with the omission
           * string which defaults to "...".
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to truncate.
           * @param {Object|number} [options] The options object or maximum string length.
           * @param {number} [options.length=30] The maximum string length.
           * @param {string} [options.omission='...'] The string to indicate text is omitted.
           * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {string} Returns the truncated string.
           * @example
           *
           * _.trunc('hi-diddly-ho there, neighborino');
           * // => 'hi-diddly-ho there, neighbo...'
           *
           * _.trunc('hi-diddly-ho there, neighborino', 24);
           * // => 'hi-diddly-ho there, n...'
           *
           * _.trunc('hi-diddly-ho there, neighborino', {
           *   'length': 24,
           *   'separator': ' '
           * });
           * // => 'hi-diddly-ho there,...'
           *
           * _.trunc('hi-diddly-ho there, neighborino', {
           *   'length': 24,
           *   'separator': /,? +/
           * });
           * // => 'hi-diddly-ho there...'
           *
           * _.trunc('hi-diddly-ho there, neighborino', {
           *   'omission': ' [...]'
           * });
           * // => 'hi-diddly-ho there, neig [...]'
           */
          function trunc(string, options, guard) {
            if (guard && isIterateeCall(string, options, guard)) {
              options = null;
            }
            var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;

            if (options != null) {
              if (isObject(options)) {
                var separator = 'separator' in options ? options.separator : separator;
                length = 'length' in options ? (+options.length || 0) : length;
                omission = 'omission' in options ? baseToString(options.omission) : omission;
              } else {
                length = +options || 0;
              }
            }
            string = baseToString(string);
            if (length >= string.length) {
              return string;
            }
            var end = length - omission.length;
            if (end < 1) {
              return omission;
            }
            var result = string.slice(0, end);
            if (separator == null) {
              return result + omission;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match,
                  newEnd,
                  substring = string.slice(0, end);

                if (!separator.global) {
                  separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
                }
                separator.lastIndex = 0;
                while ((match = separator.exec(substring))) {
                  newEnd = match.index;
                }
                result = result.slice(0, newEnd == null ? end : newEnd);
              }
            } else if (string.indexOf(separator, end) != end) {
              var index = result.lastIndexOf(separator);
              if (index > -1) {
                result = result.slice(0, index);
              }
            }
            return result + omission;
          }

          /**
           * The inverse of `_.escape`; this method converts the HTML entities
           * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
           * corresponding characters.
           *
           * **Note:** No other HTML entities are unescaped. To unescape additional HTML
           * entities use a third-party library like [_he_](https://mths.be/he).
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to unescape.
           * @returns {string} Returns the unescaped string.
           * @example
           *
           * _.unescape('fred, barney, &amp; pebbles');
           * // => 'fred, barney, & pebbles'
           */
          function unescape(string) {
            string = baseToString(string);
            return (string && reHasEscapedHtml.test(string))
              ? string.replace(reEscapedHtml, unescapeHtmlChar)
              : string;
          }

          /**
           * Splits `string` into an array of its words.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to inspect.
           * @param {RegExp|string} [pattern] The pattern to match words.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Array} Returns the words of `string`.
           * @example
           *
           * _.words('fred, barney, & pebbles');
           * // => ['fred', 'barney', 'pebbles']
           *
           * _.words('fred, barney, & pebbles', /[^, ]+/g);
           * // => ['fred', 'barney', '&', 'pebbles']
           */
          function words(string, pattern, guard) {
            if (guard && isIterateeCall(string, pattern, guard)) {
              pattern = null;
            }
            string = baseToString(string);
            return string.match(pattern || reWords) || [];
          }

          /*------------------------------------------------------------------------*/

          /**
           * Attempts to invoke `func`, returning either the result or the caught error
           * object. Any additional arguments are provided to `func` when it is invoked.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Function} func The function to attempt.
           * @returns {*} Returns the `func` result or error object.
           * @example
           *
           * // avoid throwing errors for invalid selectors
           * var elements = _.attempt(function(selector) {
           *   return document.querySelectorAll(selector);
           * }, '>_>');
           *
           * if (_.isError(elements)) {
           *   elements = [];
           * }
           */
          var attempt = restParam(function (func, args) {
            try {
              return func.apply(undefined, args);
            } catch (e) {
              return isError(e) ? e : new Error(e);
            }
          });

          /**
           * Creates a function that invokes `func` with the `this` binding of `thisArg`
           * and arguments of the created function. If `func` is a property name the
           * created callback returns the property value for a given element. If `func`
           * is an object the created callback returns `true` for elements that contain
           * the equivalent object properties, otherwise it returns `false`.
           *
           * @static
           * @memberOf _
           * @alias iteratee
           * @category Utility
           * @param {*} [func=_.identity] The value to convert to a callback.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Function} Returns the callback.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 40 }
           * ];
           *
           * // wrap to create custom callback shorthands
           * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
           *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
           *   if (!match) {
           *     return callback(func, thisArg);
           *   }
           *   return function(object) {
           *     return match[2] == 'gt'
           *       ? object[match[1]] > match[3]
           *       : object[match[1]] < match[3];
           *   };
           * });
           *
           * _.filter(users, 'age__gt36');
           * // => [{ 'user': 'fred', 'age': 40 }]
           */
          function callback(func, thisArg, guard) {
            if (guard && isIterateeCall(func, thisArg, guard)) {
              thisArg = null;
            }
            return isObjectLike(func)
              ? matches(func)
              : baseCallback(func, thisArg);
          }

          /**
           * Creates a function that returns `value`.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {*} value The value to return from the new function.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var object = { 'user': 'fred' };
           * var getter = _.constant(object);
           *
           * getter() === object;
           * // => true
           */
          function constant(value) {
            return function () {
              return value;
            };
          }

          /**
           * This method returns the first argument provided to it.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {*} value Any value.
           * @returns {*} Returns `value`.
           * @example
           *
           * var object = { 'user': 'fred' };
           *
           * _.identity(object) === object;
           * // => true
           */
          function identity(value) {
            return value;
          }

          /**
           * Creates a function that performs a deep comparison between a given object
           * and `source`, returning `true` if the given object has equivalent property
           * values, else `false`.
           *
           * **Note:** This method supports comparing arrays, booleans, `Date` objects,
           * numbers, `Object` objects, regexes, and strings. Objects are compared by
           * their own, not inherited, enumerable properties. For comparing a single
           * own or inherited property value see `_.matchesProperty`.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Object} source The object of property values to match.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': true },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * _.filter(users, _.matches({ 'age': 40, 'active': false }));
           * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
           */
          function matches(source) {
            return baseMatches(baseClone(source, true));
          }

          /**
           * Creates a function that compares the property value of `path` on a given
           * object to `value`.
           *
           * **Note:** This method supports comparing arrays, booleans, `Date` objects,
           * numbers, `Object` objects, regexes, and strings. Objects are compared by
           * their own, not inherited, enumerable properties.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Array|string} path The path of the property to get.
           * @param {*} srcValue The value to match.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var users = [
           *   { 'user': 'barney' },
           *   { 'user': 'fred' }
           * ];
           *
           * _.find(users, _.matchesProperty('user', 'fred'));
           * // => { 'user': 'fred' }
           */
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, true));
          }

          /**
           * Creates a function that invokes the method at `path` on a given object.
           * Any additional arguments are provided to the invoked method.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Array|string} path The path of the method to invoke.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var objects = [
           *   { 'a': { 'b': { 'c': _.constant(2) } } },
           *   { 'a': { 'b': { 'c': _.constant(1) } } }
           * ];
           *
           * _.map(objects, _.method('a.b.c'));
           * // => [2, 1]
           *
           * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
           * // => [1, 2]
           */
          var method = restParam(function (path, args) {
            return function (object) {
              return invokePath(object, path, args);
            };
          });

          /**
           * The opposite of `_.method`; this method creates a function that invokes
           * the method at a given path on `object`. Any additional arguments are
           * provided to the invoked method.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Object} object The object to query.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var array = _.times(3, _.constant),
           *     object = { 'a': array, 'b': array, 'c': array };
           *
           * _.map(['a[2]', 'c[0]'], _.methodOf(object));
           * // => [2, 0]
           *
           * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
           * // => [2, 0]
           */
          var methodOf = restParam(function (object, args) {
            return function (path) {
              return invokePath(object, path, args);
            };
          });

          /**
           * Adds all own enumerable function properties of a source object to the
           * destination object. If `object` is a function then methods are added to
           * its prototype as well.
           *
           * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
           * avoid conflicts caused by modifying the original.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Function|Object} [object=lodash] The destination object.
           * @param {Object} source The object of functions to add.
           * @param {Object} [options] The options object.
           * @param {boolean} [options.chain=true] Specify whether the functions added
           *  are chainable.
           * @returns {Function|Object} Returns `object`.
           * @example
           *
           * function vowels(string) {
           *   return _.filter(string, function(v) {
           *     return /[aeiou]/i.test(v);
           *   });
           * }
           *
           * _.mixin({ 'vowels': vowels });
           * _.vowels('fred');
           * // => ['e']
           *
           * _('fred').vowels().value();
           * // => ['e']
           *
           * _.mixin({ 'vowels': vowels }, { 'chain': false });
           * _('fred').vowels();
           * // => ['e']
           */
          function mixin(object, source, options) {
            if (options == null) {
              var isObj = isObject(source),
                props = isObj ? keys(source) : null,
                methodNames = (props && props.length) ? baseFunctions(source, props) : null;

              if (!(methodNames ? methodNames.length : isObj)) {
                methodNames = false;
                options = source;
                source = object;
                object = this;
              }
            }
            if (!methodNames) {
              methodNames = baseFunctions(source, keys(source));
            }
            var chain = true,
              index = -1,
              isFunc = isFunction(object),
              length = methodNames.length;

            if (options === false) {
              chain = false;
            } else if (isObject(options) && 'chain' in options) {
              chain = options.chain;
            }
            while (++index < length) {
              var methodName = methodNames[index],
                func = source[methodName];

              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = (function (func) {
                  return function () {
                    var chainAll = this.__chain__;
                    if (chain || chainAll) {
                      var result = object(this.__wrapped__),
                        actions = result.__actions__ = arrayCopy(this.__actions__);

                      actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                      result.__chain__ = chainAll;
                      return result;
                    }
                    var args = [this.value()];
                    push.apply(args, arguments);
                    return func.apply(object, args);
                  };
                }(func));
              }
            }
            return object;
          }

          /**
           * Reverts the `_` variable to its previous value and returns a reference to
           * the `lodash` function.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @returns {Function} Returns the `lodash` function.
           * @example
           *
           * var lodash = _.noConflict();
           */
          function noConflict() {
            context._ = oldDash;
            return this;
          }

          /**
           * A no-operation function that returns `undefined` regardless of the
           * arguments it receives.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @example
           *
           * var object = { 'user': 'fred' };
           *
           * _.noop(object) === undefined;
           * // => true
           */
          function noop() {
            // No operation performed.
          }

          /**
           * Creates a function that returns the property value at `path` on a
           * given object.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Array|string} path The path of the property to get.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var objects = [
           *   { 'a': { 'b': { 'c': 2 } } },
           *   { 'a': { 'b': { 'c': 1 } } }
           * ];
           *
           * _.map(objects, _.property('a.b.c'));
           * // => [2, 1]
           *
           * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
           * // => [1, 2]
           */
          function property(path) {
            return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
          }

          /**
           * The opposite of `_.property`; this method creates a function that returns
           * the property value at a given path on `object`.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Object} object The object to query.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var array = [0, 1, 2],
           *     object = { 'a': array, 'b': array, 'c': array };
           *
           * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
           * // => [2, 0]
           *
           * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
           * // => [2, 0]
           */
          function propertyOf(object) {
            return function (path) {
              return baseGet(object, toPath(path), path + '');
            };
          }

          /**
           * Creates an array of numbers (positive and/or negative) progressing from
           * `start` up to, but not including, `end`. If `end` is not specified it is
           * set to `start` with `start` then set to `0`. If `end` is less than `start`
           * a zero-length range is created unless a negative `step` is specified.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @param {number} [step=1] The value to increment or decrement by.
           * @returns {Array} Returns the new array of numbers.
           * @example
           *
           * _.range(4);
           * // => [0, 1, 2, 3]
           *
           * _.range(1, 5);
           * // => [1, 2, 3, 4]
           *
           * _.range(0, 20, 5);
           * // => [0, 5, 10, 15]
           *
           * _.range(0, -4, -1);
           * // => [0, -1, -2, -3]
           *
           * _.range(1, 4, 0);
           * // => [1, 1, 1]
           *
           * _.range(0);
           * // => []
           */
          function range(start, end, step) {
            if (step && isIterateeCall(start, end, step)) {
              end = step = null;
            }
            start = +start || 0;
            step = step == null ? 1 : (+step || 0);

            if (end == null) {
              end = start;
              start = 0;
            } else {
              end = +end || 0;
            }
            // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
            // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
            var index = -1,
              length = nativeMax(ceil((end - start) / (step || 1)), 0),
              result = Array(length);

            while (++index < length) {
              result[index] = start;
              start += step;
            }
            return result;
          }

          /**
           * Invokes the iteratee function `n` times, returning an array of the results
           * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
           * one argument; (index).
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {number} n The number of times to invoke `iteratee`.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array} Returns the array of results.
           * @example
           *
           * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
           * // => [3, 6, 4]
           *
           * _.times(3, function(n) {
           *   mage.castSpell(n);
           * });
           * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
           *
           * _.times(3, function(n) {
           *   this.cast(n);
           * }, mage);
           * // => also invokes `mage.castSpell(n)` three times
           */
          function times(n, iteratee, thisArg) {
            n = floor(n);

            // Exit early to avoid a JSC JIT bug in Safari 8
            // where `Array(0)` is treated as `Array(1)`.
            if (n < 1 || !nativeIsFinite(n)) {
              return [];
            }
            var index = -1,
              result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

            iteratee = bindCallback(iteratee, thisArg, 1);
            while (++index < n) {
              if (index < MAX_ARRAY_LENGTH) {
                result[index] = iteratee(index);
              } else {
                iteratee(index);
              }
            }
            return result;
          }

          /**
           * Generates a unique ID. If `prefix` is provided the ID is appended to it.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {string} [prefix] The value to prefix the ID with.
           * @returns {string} Returns the unique ID.
           * @example
           *
           * _.uniqueId('contact_');
           * // => 'contact_104'
           *
           * _.uniqueId();
           * // => '105'
           */
          function uniqueId(prefix) {
            var id = ++idCounter;
            return baseToString(prefix) + id;
          }

          /*------------------------------------------------------------------------*/

          /**
           * Adds two numbers.
           *
           * @static
           * @memberOf _
           * @category Math
           * @param {number} augend The first number to add.
           * @param {number} addend The second number to add.
           * @returns {number} Returns the sum.
           * @example
           *
           * _.add(6, 4);
           * // => 10
           */
          function add(augend, addend) {
            return (+augend || 0) + (+addend || 0);
          }

          /**
           * Gets the maximum value of `collection`. If `collection` is empty or falsey
           * `-Infinity` is returned. If an iteratee function is provided it is invoked
           * for each value in `collection` to generate the criterion by which the value
           * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
           * arguments: (value, index, collection).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Math
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {*} Returns the maximum value.
           * @example
           *
           * _.max([4, 2, 8, 6]);
           * // => 8
           *
           * _.max([]);
           * // => -Infinity
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 40 }
           * ];
           *
           * _.max(users, function(chr) {
           *   return chr.age;
           * });
           * // => { 'user': 'fred', 'age': 40 }
           *
           * // using the `_.property` callback shorthand
           * _.max(users, 'age');
           * // => { 'user': 'fred', 'age': 40 }
           */
          var max = createExtremum(gt, NEGATIVE_INFINITY);

          /**
           * Gets the minimum value of `collection`. If `collection` is empty or falsey
           * `Infinity` is returned. If an iteratee function is provided it is invoked
           * for each value in `collection` to generate the criterion by which the value
           * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
           * arguments: (value, index, collection).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Math
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {*} Returns the minimum value.
           * @example
           *
           * _.min([4, 2, 8, 6]);
           * // => 2
           *
           * _.min([]);
           * // => Infinity
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 40 }
           * ];
           *
           * _.min(users, function(chr) {
           *   return chr.age;
           * });
           * // => { 'user': 'barney', 'age': 36 }
           *
           * // using the `_.property` callback shorthand
           * _.min(users, 'age');
           * // => { 'user': 'barney', 'age': 36 }
           */
          var min = createExtremum(lt, POSITIVE_INFINITY);

          /**
           * Gets the sum of the values in `collection`.
           *
           * @static
           * @memberOf _
           * @category Math
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {number} Returns the sum.
           * @example
           *
           * _.sum([4, 6]);
           * // => 10
           *
           * _.sum({ 'a': 4, 'b': 6 });
           * // => 10
           *
           * var objects = [
           *   { 'n': 4 },
           *   { 'n': 6 }
           * ];
           *
           * _.sum(objects, function(object) {
           *   return object.n;
           * });
           * // => 10
           *
           * // using the `_.property` callback shorthand
           * _.sum(objects, 'n');
           * // => 10
           */
          function sum(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = null;
            }
            var callback = getCallback(),
              noIteratee = iteratee == null;

            if (!(noIteratee && callback === baseCallback)) {
              noIteratee = false;
              iteratee = callback(iteratee, thisArg, 3);
            }
            return noIteratee
              ? arraySum(isArray(collection) ? collection : toIterable(collection))
              : baseSum(collection, iteratee);
          }

          /*------------------------------------------------------------------------*/

          // Ensure wrappers are instances of `baseLodash`.
          lodash.prototype = baseLodash.prototype;

          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;

          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;

          // Add functions to the `Map` cache.
          MapCache.prototype['delete'] = mapDelete;
          MapCache.prototype.get = mapGet;
          MapCache.prototype.has = mapHas;
          MapCache.prototype.set = mapSet;

          // Add functions to the `Set` cache.
          SetCache.prototype.push = cachePush;

          // Assign cache to `_.memoize`.
          memoize.Cache = MapCache;

          // Add functions that return wrapped values when chaining.
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.callback = callback;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.functions = functions;
          lodash.groupBy = groupBy;
          lodash.indexBy = indexBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.invert = invert;
          lodash.invoke = invoke;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.omit = omit;
          lodash.once = once;
          lodash.pairs = pairs;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pluck = pluck;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.restParam = restParam;
          lodash.set = set;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortByAll = sortByAll;
          lodash.sortByOrder = sortByOrder;
          lodash.spread = spread;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.times = times;
          lodash.toArray = toArray;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.union = union;
          lodash.uniq = uniq;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.where = where;
          lodash.without = without;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipWith = zipWith;

          // Add aliases.
          lodash.backflow = flowRight;
          lodash.collect = map;
          lodash.compose = flowRight;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.extend = assign;
          lodash.iteratee = callback;
          lodash.methods = functions;
          lodash.object = zipObject;
          lodash.select = filter;
          lodash.tail = rest;
          lodash.unique = uniq;

          // Add functions to `lodash.prototype`.
          mixin(lodash, lodash);

          /*------------------------------------------------------------------------*/

          // Add functions that return unwrapped values when chaining.
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.deburr = deburr;
          lodash.endsWith = endsWith;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.findWhere = findWhere;
          lodash.first = first;
          lodash.get = get;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isBoolean = isBoolean;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isError = isError;
          lodash.isFinite = isFinite;
          lodash.isFunction = isFunction;
          lodash.isMatch = isMatch;
          lodash.isNaN = isNaN;
          lodash.isNative = isNative;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isString = isString;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.min = min;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padLeft = padLeft;
          lodash.padRight = padRight;
          lodash.parseInt = parseInt;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.result = result;
          lodash.runInContext = runInContext;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.sum = sum;
          lodash.template = template;
          lodash.trim = trim;
          lodash.trimLeft = trimLeft;
          lodash.trimRight = trimRight;
          lodash.trunc = trunc;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.words = words;

          // Add aliases.
          lodash.all = every;
          lodash.any = some;
          lodash.contains = includes;
          lodash.eq = isEqual;
          lodash.detect = find;
          lodash.foldl = reduce;
          lodash.foldr = reduceRight;
          lodash.head = first;
          lodash.include = includes;
          lodash.inject = reduce;

          mixin(lodash, (function () {
            var source = {};
            baseForOwn(lodash, function (func, methodName) {
              if (!lodash.prototype[methodName]) {
                source[methodName] = func;
              }
            });
            return source;
          }()), false);

          /*------------------------------------------------------------------------*/

          // Add functions capable of returning wrapped and unwrapped values when chaining.
          lodash.sample = sample;

          lodash.prototype.sample = function (n) {
            if (!this.__chain__ && n == null) {
              return sample(this.value());
            }
            return this.thru(function (value) {
              return sample(value, n);
            });
          };

          /*------------------------------------------------------------------------*/

          /**
           * The semantic version number.
           *
           * @static
           * @memberOf _
           * @type string
           */
          lodash.VERSION = VERSION;

          // Assign default placeholders.
          arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
            lodash[methodName].placeholder = lodash;
          });

          // Add `LazyWrapper` methods that accept an `iteratee` value.
          arrayEach(['dropWhile', 'filter', 'map', 'takeWhile'], function (methodName, type) {
            var isFilter = type != LAZY_MAP_FLAG,
              isDropWhile = type == LAZY_DROP_WHILE_FLAG;

            LazyWrapper.prototype[methodName] = function (iteratee, thisArg) {
              var filtered = this.__filtered__,
                result = (filtered && isDropWhile) ? new LazyWrapper(this) : this.clone(),
                iteratees = result.__iteratees__ || (result.__iteratees__ = []);

              iteratees.push({
                'done': false,
                'count': 0,
                'index': 0,
                'iteratee': getCallback(iteratee, thisArg, 1),
                'limit': -1,
                'type': type
              });

              result.__filtered__ = filtered || isFilter;
              return result;
            };
          });

          // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
          arrayEach(['drop', 'take'], function (methodName, index) {
            var whileName = methodName + 'While';

            LazyWrapper.prototype[methodName] = function (n) {
              var filtered = this.__filtered__,
                result = (filtered && !index) ? this.dropWhile() : this.clone();

              n = n == null ? 1 : nativeMax(floor(n) || 0, 0);
              if (filtered) {
                if (index) {
                  result.__takeCount__ = nativeMin(result.__takeCount__, n);
                } else {
                  last(result.__iteratees__).limit = n;
                }
              } else {
                var views = result.__views__ || (result.__views__ = []);
                views.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
              }
              return result;
            };

            LazyWrapper.prototype[methodName + 'Right'] = function (n) {
              return this.reverse()[methodName](n).reverse();
            };

            LazyWrapper.prototype[methodName + 'RightWhile'] = function (predicate, thisArg) {
              return this.reverse()[whileName](predicate, thisArg).reverse();
            };
          });

          // Add `LazyWrapper` methods for `_.first` and `_.last`.
          arrayEach(['first', 'last'], function (methodName, index) {
            var takeName = 'take' + (index ? 'Right' : '');

            LazyWrapper.prototype[methodName] = function () {
              return this[takeName](1).value()[0];
            };
          });

          // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
          arrayEach(['initial', 'rest'], function (methodName, index) {
            var dropName = 'drop' + (index ? '' : 'Right');

            LazyWrapper.prototype[methodName] = function () {
              return this[dropName](1);
            };
          });

          // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
          arrayEach(['pluck', 'where'], function (methodName, index) {
            var operationName = index ? 'filter' : 'map',
              createCallback = index ? baseMatches : property;

            LazyWrapper.prototype[methodName] = function (value) {
              return this[operationName](createCallback(value));
            };
          });

          LazyWrapper.prototype.compact = function () {
            return this.filter(identity);
          };

          LazyWrapper.prototype.reject = function (predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 1);
            return this.filter(function (value) {
              return !predicate(value);
            });
          };

          LazyWrapper.prototype.slice = function (start, end) {
            start = start == null ? 0 : (+start || 0);

            var result = this;
            if (start < 0) {
              result = this.takeRight(-start);
            } else if (start) {
              result = this.drop(start);
            }
            if (end !== undefined) {
              end = (+end || 0);
              result = end < 0 ? result.dropRight(-end) : result.take(end - start);
            }
            return result;
          };

          LazyWrapper.prototype.toArray = function () {
            return this.drop(0);
          };

          // Add `LazyWrapper` methods to `lodash.prototype`.
          baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var lodashFunc = lodash[methodName];
            if (!lodashFunc) {
              return;
            }
            var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
              retUnwrapped = /^(?:first|last)$/.test(methodName);

            lodash.prototype[methodName] = function () {
              var args = arguments,
                chainAll = this.__chain__,
                value = this.__wrapped__,
                isHybrid = !!this.__actions__.length,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);

              if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                // avoid lazy use if the iteratee has a "length" value other than `1`
                isLazy = useLazy = false;
              }
              var onlyLazy = isLazy && !isHybrid;
              if (retUnwrapped && !chainAll) {
                return onlyLazy
                  ? func.call(value)
                  : lodashFunc.call(lodash, this.value());
              }
              var interceptor = function (value) {
                var otherArgs = [value];
                push.apply(otherArgs, args);
                return lodashFunc.apply(lodash, otherArgs);
              };
              if (useLazy) {
                var wrapper = onlyLazy ? value : new LazyWrapper(this),
                  result = func.apply(wrapper, args);

                if (!retUnwrapped && (isHybrid || result.__actions__)) {
                  var actions = result.__actions__ || (result.__actions__ = []);
                  actions.push({ 'func': thru, 'args': [interceptor], 'thisArg': lodash });
                }
                return new LodashWrapper(result, chainAll);
              }
              return this.thru(interceptor);
            };
          });

          // Add `Array` and `String` methods to `lodash.prototype`.
          arrayEach(['concat', 'join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function (methodName) {
            var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

            lodash.prototype[methodName] = function () {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                return func.apply(this.value(), args);
              }
              return this[chainName](function (value) {
                return func.apply(value, args);
              });
            };
          });

          // Map minified function names to their real names.
          baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name,
                names = realNames[key] || (realNames[key] = []);

              names.push({ 'name': methodName, 'func': lodashFunc });
            }
          });

          realNames[createHybridWrapper(null, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': null }];

          // Add functions to the lazy wrapper.
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;

          // Add chaining functions to the `lodash` wrapper.
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toString = wrapperToString;
          lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

          // Add function aliases to the `lodash` wrapper.
          lodash.prototype.collect = lodash.prototype.map;
          lodash.prototype.head = lodash.prototype.first;
          lodash.prototype.select = lodash.prototype.filter;
          lodash.prototype.tail = lodash.prototype.rest;

          return lodash;
        }

        /*--------------------------------------------------------------------------*/

        // Export lodash.
        var _ = runInContext();

        // Some AMD build optimizers like r.js check for condition patterns like the following:
        if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
          // Expose lodash to the global object when an AMD loader is present to avoid
          // errors in cases where lodash is loaded by a script tag and not intended
          // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
          // more details.
          root._ = _;

          // Define as an anonymous module so, through path mapping, it can be
          // referenced as the "underscore" module.
          define(function () {
            return _;
          });
        }
        // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
        else if (freeExports && freeModule) {
          // Export for Node.js or RingoJS.
          if (moduleExports) {
            (freeModule.exports = _)._ = _;
          }
          // Export for Rhino with CommonJS support.
          else {
            freeExports._ = _;
          }
        }
        else {
          // Export for a browser or Rhino.
          root._ = _;
        }
      }.call(this));

    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, {}], 78: [function (require, module, exports) {
    /*!
     * Copyright (c) 2015 Chris O'Hara <cohara87@gmail.com>
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject to
     * the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
     * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
     * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     */

    (function (name, definition) {
      if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
        module.exports = definition();
      } else if (typeof define === 'function' && typeof define.amd === 'object') {
        define(definition);
      } else {
        this[name] = definition();
      }
    })('validator', function (validator) {

      'use strict';

      validator = { version: '3.40.1' };

      var emailUser = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e])|(\\[\x01-\x09\x0b\x0c\x0d-\x7f])))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))$/i;

      var emailUserUtf8 = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))$/i;

      var displayName = /^(?:[a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~\.]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(?:[a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~\.]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|\s)*<(.+)>$/i;

      var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/;

      var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;

      var isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/
        , isbn13Maybe = /^(?:[0-9]{13})$/;

      var ipv4Maybe = /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/
        , ipv6Block = /^[0-9A-F]{1,4}$/i;

      var uuid = {
        '3': /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i
        , '4': /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i
        , '5': /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i
        , all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
      };

      var alpha = /^[A-Z]+$/i
        , alphanumeric = /^[0-9A-Z]+$/i
        , numeric = /^[-+]?[0-9]+$/
        , int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/
        , float = /^(?:[-+]?(?:[0-9]+))?(?:\.[0-9]*)?(?:[eE][\+\-]?(?:[0-9]+))?$/
        , hexadecimal = /^[0-9A-F]+$/i
        , hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{6})$/i;

      var ascii = /^[\x00-\x7F]+$/
        , multibyte = /[^\x00-\x7F]/
        , fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/
        , halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;

      var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;

      var base64 = /^(?:[A-Z0-9+\/]{4})*(?:[A-Z0-9+\/]{2}==|[A-Z0-9+\/]{3}=|[A-Z0-9+\/]{4})$/i;

      var phones = {
        'zh-CN': /^(\+?0?86\-?)?1[345789]\d{9}$/,
        'en-ZA': /^(\+?27|0)\d{9}$/,
        'en-AU': /^(\+?61|0)4\d{8}$/,
        'en-HK': /^(\+?852\-?)?[569]\d{3}\-?\d{4}$/,
        'fr-FR': /^(\+?33|0)[67]\d{8}$/,
        'pt-PT': /^(\+351)?9[1236]\d{7}$/,
        'el-GR': /^(\+30)?((2\d{9})|(69\d{8}))$/,
        'en-GB': /^(\+?44|0)7\d{9}$/,
        'en-US': /^(\+?1)?[2-9]\d{2}[2-9](?!11)\d{6}$/,
        'en-ZM': /^(\+26)?09[567]\d{7}$/
      };

      validator.extend = function (name, fn) {
        validator[name] = function () {
          var args = Array.prototype.slice.call(arguments);
          args[0] = validator.toString(args[0]);
          return fn.apply(validator, args);
        };
      };

      //Right before exporting the validator object, pass each of the builtins
      //through extend() so that their first argument is coerced to a string
      validator.init = function () {
        for (var name in validator) {
          if (typeof validator[name] !== 'function' || name === 'toString' ||
            name === 'toDate' || name === 'extend' || name === 'init') {
            continue;
          }
          validator.extend(name, validator[name]);
        }
      };

      validator.toString = function (input) {
        if (typeof input === 'object' && input !== null && input.toString) {
          input = input.toString();
        } else if (input === null || typeof input === 'undefined' || (isNaN(input) && !input.length)) {
          input = '';
        } else if (typeof input !== 'string') {
          input += '';
        }
        return input;
      };

      validator.toDate = function (date) {
        if (Object.prototype.toString.call(date) === '[object Date]') {
          return date;
        }
        date = Date.parse(date);
        return !isNaN(date) ? new Date(date) : null;
      };

      validator.toFloat = function (str) {
        return parseFloat(str);
      };

      validator.toInt = function (str, radix) {
        return parseInt(str, radix || 10);
      };

      validator.toBoolean = function (str, strict) {
        if (strict) {
          return str === '1' || str === 'true';
        }
        return str !== '0' && str !== 'false' && str !== '';
      };

      validator.equals = function (str, comparison) {
        return str === validator.toString(comparison);
      };

      validator.contains = function (str, elem) {
        return str.indexOf(validator.toString(elem)) >= 0;
      };

      validator.matches = function (str, pattern, modifiers) {
        if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
          pattern = new RegExp(pattern, modifiers);
        }
        return pattern.test(str);
      };

      var default_email_options = {
        allow_display_name: false,
        allow_utf8_local_part: true,
        require_tld: true
      };

      validator.isEmail = function (str, options) {
        options = merge(options, default_email_options);

        if (options.allow_display_name) {
          var display_email = str.match(displayName);
          if (display_email) {
            str = display_email[1];
          }
        } else if (/\s/.test(str)) {
          return false;
        }

        var parts = str.split('@')
          , domain = parts.pop()
          , user = parts.join('@');

        if (!validator.isFQDN(domain, { require_tld: options.require_tld })) {
          return false;
        }

        return options.allow_utf8_local_part ?
          emailUserUtf8.test(user) :
          emailUser.test(user);
      };

      var default_url_options = {
        protocols: ['http', 'https', 'ftp']
        , require_tld: true
        , require_protocol: false
        , allow_underscores: false
        , allow_trailing_dot: false
        , allow_protocol_relative_urls: false
      };

      validator.isURL = function (url, options) {
        if (!url || url.length >= 2083 || /\s/.test(url)) {
          return false;
        }
        if (url.indexOf('mailto:') === 0) {
          return false;
        }
        options = merge(options, default_url_options);
        var protocol, auth, host, hostname, port,
          port_str, split;
        split = url.split('://');
        if (split.length > 1) {
          protocol = split.shift();
          if (options.protocols.indexOf(protocol) === -1) {
            return false;
          }
        } else if (options.require_protocol) {
          return false;
        } else if (options.allow_protocol_relative_urls && url.substr(0, 2) === '//') {
          split[0] = url.substr(2);
        }
        url = split.join('://');
        split = url.split('#');
        url = split.shift();

        split = url.split('?');
        url = split.shift();

        split = url.split('/');
        url = split.shift();
        split = url.split('@');
        if (split.length > 1) {
          auth = split.shift();
          if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
            return false;
          }
        }
        hostname = split.join('@');
        split = hostname.split(':');
        host = split.shift();
        if (split.length) {
          port_str = split.join(':');
          port = parseInt(port_str, 10);
          if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
            return false;
          }
        }
        if (!validator.isIP(host) && !validator.isFQDN(host, options) &&
          host !== 'localhost') {
          return false;
        }
        if (options.host_whitelist &&
          options.host_whitelist.indexOf(host) === -1) {
          return false;
        }
        if (options.host_blacklist &&
          options.host_blacklist.indexOf(host) !== -1) {
          return false;
        }
        return true;
      };

      validator.isIP = function (str, version) {
        version = validator.toString(version);
        if (!version) {
          return validator.isIP(str, 4) || validator.isIP(str, 6);
        } else if (version === '4') {
          if (!ipv4Maybe.test(str)) {
            return false;
          }
          var parts = str.split('.').sort(function (a, b) {
            return a - b;
          });
          return parts[3] <= 255;
        } else if (version === '6') {
          var blocks = str.split(':');
          var foundOmissionBlock = false; // marker to indicate ::

          // At least some OS accept the last 32 bits of an IPv6 address
          // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
          // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
          // and '::a.b.c.d' is deprecated, but also valid.
          var foundIPv4TransitionBlock = validator.isIP(blocks[blocks.length - 1], 4);
          var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;

          if (blocks.length > expectedNumberOfBlocks)
            return false;

          // initial or final ::
          if (str === '::') {
            return true;
          } else if (str.substr(0, 2) === '::') {
            blocks.shift();
            blocks.shift();
            foundOmissionBlock = true;
          } else if (str.substr(str.length - 2) === '::') {
            blocks.pop();
            blocks.pop();
            foundOmissionBlock = true;
          }

          for (var i = 0; i < blocks.length; ++i) {
            // test for a :: which can not be at the string start/end
            // since those cases have been handled above
            if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
              if (foundOmissionBlock)
                return false; // multiple :: in address
              foundOmissionBlock = true;
            } else if (foundIPv4TransitionBlock && i == blocks.length - 1) {
              // it has been checked before that the last
              // block is a valid IPv4 address
            } else if (!ipv6Block.test(blocks[i])) {
              return false;
            }
          }

          if (foundOmissionBlock) {
            return blocks.length >= 1;
          } else {
            return blocks.length === expectedNumberOfBlocks;
          }
        }
        return false;
      };

      var default_fqdn_options = {
        require_tld: true
        , allow_underscores: false
        , allow_trailing_dot: false
      };

      validator.isFQDN = function (str, options) {
        options = merge(options, default_fqdn_options);

        /* Remove the optional trailing dot before checking validity */
        if (options.allow_trailing_dot && str[str.length - 1] === '.') {
          str = str.substring(0, str.length - 1);
        }
        var parts = str.split('.');
        if (options.require_tld) {
          var tld = parts.pop();
          if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
            return false;
          }
        }
        for (var part, i = 0; i < parts.length; i++) {
          part = parts[i];
          if (options.allow_underscores) {
            if (part.indexOf('__') >= 0) {
              return false;
            }
            part = part.replace(/_/g, '');
          }
          if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
            return false;
          }
          if (part[0] === '-' || part[part.length - 1] === '-' ||
            part.indexOf('---') >= 0) {
            return false;
          }
        }
        return true;
      };

      validator.isBoolean = function (str) {
        return (['true', 'false', '1', '0'].indexOf(str) >= 0);
      };

      validator.isAlpha = function (str) {
        return alpha.test(str);
      };

      validator.isAlphanumeric = function (str) {
        return alphanumeric.test(str);
      };

      validator.isNumeric = function (str) {
        return numeric.test(str);
      };

      validator.isHexadecimal = function (str) {
        return hexadecimal.test(str);
      };

      validator.isHexColor = function (str) {
        return hexcolor.test(str);
      };

      validator.isLowercase = function (str) {
        return str === str.toLowerCase();
      };

      validator.isUppercase = function (str) {
        return str === str.toUpperCase();
      };

      validator.isInt = function (str, options) {
        options = options || {};
        return int.test(str) && (!options.hasOwnProperty('min') || str >= options.min) && (!options.hasOwnProperty('max') || str <= options.max);
      };

      validator.isFloat = function (str, options) {
        options = options || {};
        return str !== '' && float.test(str) && (!options.hasOwnProperty('min') || str >= options.min) && (!options.hasOwnProperty('max') || str <= options.max);
      };

      validator.isDivisibleBy = function (str, num) {
        return validator.toFloat(str) % validator.toInt(num) === 0;
      };

      validator.isNull = function (str) {
        return str.length === 0;
      };

      validator.isLength = function (str, min, max) {
        var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
        var len = str.length - surrogatePairs.length;
        return len >= min && (typeof max === 'undefined' || len <= max);
      };

      validator.isByteLength = function (str, min, max) {
        return str.length >= min && (typeof max === 'undefined' || str.length <= max);
      };

      validator.isUUID = function (str, version) {
        var pattern = uuid[version ? version : 'all'];
        return pattern && pattern.test(str);
      };

      validator.isDate = function (str) {
        return !isNaN(Date.parse(str));
      };

      validator.isAfter = function (str, date) {
        var comparison = validator.toDate(date || new Date())
          , original = validator.toDate(str);
        return !!(original && comparison && original > comparison);
      };

      validator.isBefore = function (str, date) {
        var comparison = validator.toDate(date || new Date())
          , original = validator.toDate(str);
        return original && comparison && original < comparison;
      };

      validator.isIn = function (str, options) {
        var i;
        if (Object.prototype.toString.call(options) === '[object Array]') {
          var array = [];
          for (i in options) {
            array[i] = validator.toString(options[i]);
          }
          return array.indexOf(str) >= 0;
        } else if (typeof options === 'object') {
          return options.hasOwnProperty(str);
        } else if (options && typeof options.indexOf === 'function') {
          return options.indexOf(str) >= 0;
        }
        return false;
      };

      validator.isCreditCard = function (str) {
        var sanitized = str.replace(/[^0-9]+/g, '');
        if (!creditCard.test(sanitized)) {
          return false;
        }
        var sum = 0, digit, tmpNum, shouldDouble;
        for (var i = sanitized.length - 1; i >= 0; i--) {
          digit = sanitized.substring(i, (i + 1));
          tmpNum = parseInt(digit, 10);
          if (shouldDouble) {
            tmpNum *= 2;
            if (tmpNum >= 10) {
              sum += ((tmpNum % 10) + 1);
            } else {
              sum += tmpNum;
            }
          } else {
            sum += tmpNum;
          }
          shouldDouble = !shouldDouble;
        }
        return !!((sum % 10) === 0 ? sanitized : false);
      };

      validator.isISIN = function (str) {
        if (!isin.test(str)) {
          return false;
        }

        var checksumStr = str.replace(/[A-Z]/g, function (character) {
          return parseInt(character, 36);
        });

        var sum = 0, digit, tmpNum, shouldDouble = true;
        for (var i = checksumStr.length - 2; i >= 0; i--) {
          digit = checksumStr.substring(i, (i + 1));
          tmpNum = parseInt(digit, 10);
          if (shouldDouble) {
            tmpNum *= 2;
            if (tmpNum >= 10) {
              sum += tmpNum + 1;
            } else {
              sum += tmpNum;
            }
          } else {
            sum += tmpNum;
          }
          shouldDouble = !shouldDouble;
        }

        return parseInt(str.substr(str.length - 1), 10) === (10000 - sum) % 10;
      };

      validator.isISBN = function (str, version) {
        version = validator.toString(version);
        if (!version) {
          return validator.isISBN(str, 10) || validator.isISBN(str, 13);
        }
        var sanitized = str.replace(/[\s-]+/g, '')
          , checksum = 0, i;
        if (version === '10') {
          if (!isbn10Maybe.test(sanitized)) {
            return false;
          }
          for (i = 0; i < 9; i++) {
            checksum += (i + 1) * sanitized.charAt(i);
          }
          if (sanitized.charAt(9) === 'X') {
            checksum += 10 * 10;
          } else {
            checksum += 10 * sanitized.charAt(9);
          }
          if ((checksum % 11) === 0) {
            return !!sanitized;
          }
        } else if (version === '13') {
          if (!isbn13Maybe.test(sanitized)) {
            return false;
          }
          var factor = [1, 3];
          for (i = 0; i < 12; i++) {
            checksum += factor[i % 2] * sanitized.charAt(i);
          }
          if (sanitized.charAt(12) - ((10 - (checksum % 10)) % 10) === 0) {
            return !!sanitized;
          }
        }
        return false;
      };

      validator.isMobilePhone = function (str, locale) {
        if (locale in phones) {
          return phones[locale].test(str);
        }
        return false;
      };

      var default_currency_options = {
        symbol: '$'
        , require_symbol: false
        , allow_space_after_symbol: false
        , symbol_after_digits: false
        , allow_negatives: true
        , parens_for_negatives: false
        , negative_sign_before_digits: false
        , negative_sign_after_digits: false
        , allow_negative_sign_placeholder: false
        , thousands_separator: ','
        , decimal_separator: '.'
        , allow_space_after_digits: false
      };

      validator.isCurrency = function (str, options) {
        options = merge(options, default_currency_options);

        return currencyRegex(options).test(str);
      };

      validator.isJSON = function (str) {
        try {
          JSON.parse(str);
        } catch (e) {
          return false;
        }
        return true;
      };

      validator.isMultibyte = function (str) {
        return multibyte.test(str);
      };

      validator.isAscii = function (str) {
        return ascii.test(str);
      };

      validator.isFullWidth = function (str) {
        return fullWidth.test(str);
      };

      validator.isHalfWidth = function (str) {
        return halfWidth.test(str);
      };

      validator.isVariableWidth = function (str) {
        return fullWidth.test(str) && halfWidth.test(str);
      };

      validator.isSurrogatePair = function (str) {
        return surrogatePair.test(str);
      };

      validator.isBase64 = function (str) {
        return base64.test(str);
      };

      validator.isMongoId = function (str) {
        return validator.isHexadecimal(str) && str.length === 24;
      };

      validator.ltrim = function (str, chars) {
        var pattern = chars ? new RegExp('^[' + chars + ']+', 'g') : /^\s+/g;
        return str.replace(pattern, '');
      };

      validator.rtrim = function (str, chars) {
        var pattern = chars ? new RegExp('[' + chars + ']+$', 'g') : /\s+$/g;
        return str.replace(pattern, '');
      };

      validator.trim = function (str, chars) {
        var pattern = chars ? new RegExp('^[' + chars + ']+|[' + chars + ']+$', 'g') : /^\s+|\s+$/g;
        return str.replace(pattern, '');
      };

      validator.escape = function (str) {
        return (str.replace(/&/g, '&amp;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#x27;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/\//g, '&#x2F;')
          .replace(/\`/g, '&#96;'));
      };

      validator.stripLow = function (str, keep_new_lines) {
        var chars = keep_new_lines ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F' : '\\x00-\\x1F\\x7F';
        return validator.blacklist(str, chars);
      };

      validator.whitelist = function (str, chars) {
        return str.replace(new RegExp('[^' + chars + ']+', 'g'), '');
      };

      validator.blacklist = function (str, chars) {
        return str.replace(new RegExp('[' + chars + ']+', 'g'), '');
      };

      var default_normalize_email_options = {
        lowercase: true
      };

      validator.normalizeEmail = function (email, options) {
        options = merge(options, default_normalize_email_options);
        if (!validator.isEmail(email)) {
          return false;
        }
        var parts = email.split('@', 2);
        parts[1] = parts[1].toLowerCase();
        if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {
          parts[0] = parts[0].toLowerCase().replace(/\./g, '');
          if (parts[0][0] === '+') {
            return false;
          }
          parts[0] = parts[0].split('+')[0];
          parts[1] = 'gmail.com';
        } else if (options.lowercase) {
          parts[0] = parts[0].toLowerCase();
        }
        return parts.join('@');
      };

      function merge(obj, defaults) {
        obj = obj || {};
        for (var key in defaults) {
          if (typeof obj[key] === 'undefined') {
            obj[key] = defaults[key];
          }
        }
        return obj;
      }

      function currencyRegex(options) {
        var symbol = '(\\' + options.symbol.replace(/\./g, '\\.') + ')' + (options.require_symbol ? '' : '?')
          , negative = '-?'
          , whole_dollar_amount_without_sep = '[1-9]\\d*'
          , whole_dollar_amount_with_sep = '[1-9]\\d{0,2}(\\' + options.thousands_separator + '\\d{3})*'
          , valid_whole_dollar_amounts = ['0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep]
          , whole_dollar_amount = '(' + valid_whole_dollar_amounts.join('|') + ')?'
          , decimal_amount = '(\\' + options.decimal_separator + '\\d{2})?';
        var pattern = whole_dollar_amount + decimal_amount;
        // default is negative sign before symbol, but there are two other options (besides parens)
        if (options.allow_negatives && !options.parens_for_negatives) {
          if (options.negative_sign_after_digits) {
            pattern += negative;
          }
          else if (options.negative_sign_before_digits) {
            pattern = negative + pattern;
          }
        }
        // South African Rand, for example, uses R 123 (space) and R-123 (no space)
        if (options.allow_negative_sign_placeholder) {
          pattern = '( (?!\\-))?' + pattern;
        }
        else if (options.allow_space_after_symbol) {
          pattern = ' ?' + pattern;
        }
        else if (options.allow_space_after_digits) {
          pattern += '( (?!$))?';
        }
        if (options.symbol_after_digits) {
          pattern += symbol;
        } else {
          pattern = symbol + pattern;
        }
        if (options.allow_negatives) {
          if (options.parens_for_negatives) {
            pattern = '(\\(' + pattern + '\\)|' + pattern + ')';
          }
          else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
            pattern = negative + pattern;
          }
        }
        return new RegExp(
          '^' +
          // ensure there's a dollar and/or decimal amount, and that it doesn't start with a space or a negative sign followed by a space
          '(?!-? )(?=.*\\d)' +
          pattern +
          '$'
        );
      }

      validator.init();

      return validator;

    });

  }, {}], 79: [function (require, module, exports) {
    "use strict";

    module.exports = {

      INVALID_TYPE: "Expected type {0} but found type {1}",
      INVALID_FORMAT: "Object didn't pass validation for format {0}: {1}",
      ENUM_MISMATCH: "No enum match for: {0}",
      ANY_OF_MISSING: "Data does not match any schemas from 'anyOf'",
      ONE_OF_MISSING: "Data does not match any schemas from 'oneOf'",
      ONE_OF_MULTIPLE: "Data is valid against more than one schema from 'oneOf'",
      NOT_PASSED: "Data matches schema from 'not'",

      // Array errors
      ARRAY_LENGTH_SHORT: "Array is too short ({0}), minimum {1}",
      ARRAY_LENGTH_LONG: "Array is too long ({0}), maximum {1}",
      ARRAY_UNIQUE: "Array items are not unique (indexes {0} and {1})",
      ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",

      // Numeric errors
      MULTIPLE_OF: "Value {0} is not a multiple of {1}",
      MINIMUM: "Value {0} is less than minimum {1}",
      MINIMUM_EXCLUSIVE: "Value {0} is equal or less than exclusive minimum {1}",
      MAXIMUM: "Value {0} is greater than maximum {1}",
      MAXIMUM_EXCLUSIVE: "Value {0} is equal or greater than exclusive maximum {1}",

      // Object errors
      OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({0}), minimum {1}",
      OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({0}), maximum {1}",
      OBJECT_MISSING_REQUIRED_PROPERTY: "Missing required property: {0}",
      OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed: {0}",
      OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {0} (due to key: {1})",

      // String errors
      MIN_LENGTH: "String is too short ({0} chars), minimum {1}",
      MAX_LENGTH: "String is too long ({0} chars), maximum {1}",
      PATTERN: "String does not match pattern {0}: {1}",

      // Schema validation errors
      KEYWORD_TYPE_EXPECTED: "Keyword '{0}' is expected to be of type '{1}'",
      KEYWORD_UNDEFINED_STRICT: "Keyword '{0}' must be defined in strict mode",
      KEYWORD_UNEXPECTED: "Keyword '{0}' is not expected to appear in the schema",
      KEYWORD_MUST_BE: "Keyword '{0}' must be {1}",
      KEYWORD_DEPENDENCY: "Keyword '{0}' requires keyword '{1}'",
      KEYWORD_PATTERN: "Keyword '{0}' is not a valid RegExp pattern: {1}",
      KEYWORD_VALUE_TYPE: "Each element of keyword '{0}' array must be a '{1}'",
      UNKNOWN_FORMAT: "There is no validation function for format '{0}'",
      CUSTOM_MODE_FORCE_PROPERTIES: "{0} must define at least one property if present",

      // Remote errors
      REF_UNRESOLVED: "Reference has not been resolved during compilation: {0}",
      UNRESOLVABLE_REFERENCE: "Reference could not be resolved: {0}",
      SCHEMA_NOT_REACHABLE: "Validator was not able to read schema with uri: {0}",
      SCHEMA_TYPE_EXPECTED: "Schema is expected to be of type 'object'",
      SCHEMA_NOT_AN_OBJECT: "Schema is not an object: {0}",
      ASYNC_TIMEOUT: "{0} asynchronous task(s) have timed out after {1} ms",
      PARENT_SCHEMA_VALIDATION_FAILED: "Schema failed to validate against its parent schema, see inner errors for details.",
      REMOTE_NOT_VALID: "Remote reference didn't compile successfully: {0}"

    };

  }, {}], 80: [function (require, module, exports) {
    /*jshint maxlen: false*/

    var validator = require("validator");

    var FormatValidators = {
      "date": function (date) {
        if (typeof date !== "string") {
          return true;
        }
        // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
        var matches = /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/.exec(date);
        if (matches === null) {
          return false;
        }
        // var year = matches[1];
        // var month = matches[2];
        // var day = matches[3];
        if (matches[2] < "01" || matches[2] > "12" || matches[3] < "01" || matches[3] > "31") {
          return false;
        }
        return true;
      },
      "date-time": function (dateTime) {
        if (typeof dateTime !== "string") {
          return true;
        }
        // date-time from http://tools.ietf.org/html/rfc3339#section-5.6
        var s = dateTime.toLowerCase().split("t");
        if (!FormatValidators.date(s[0])) {
          return false;
        }
        var matches = /^([0-9]{2}):([0-9]{2}):([0-9]{2})(.[0-9]+)?(z|([+-][0-9]{2}:[0-9]{2}))$/.exec(s[1]);
        if (matches === null) {
          return false;
        }
        // var hour = matches[1];
        // var minute = matches[2];
        // var second = matches[3];
        // var fraction = matches[4];
        // var timezone = matches[5];
        if (matches[1] > "23" || matches[2] > "59" || matches[3] > "59") {
          return false;
        }
        return true;
      },
      "email": function (email) {
        if (typeof email !== "string") {
          return true;
        }
        return validator.isEmail(email, { "require_tld": true });
      },
      "hostname": function (hostname) {
        if (typeof hostname !== "string") {
          return true;
        }
        /*
            http://json-schema.org/latest/json-schema-validation.html#anchor114
            A string instance is valid against this attribute if it is a valid
            representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034].

            http://tools.ietf.org/html/rfc1034#section-3.5

            <digit> ::= any one of the ten digits 0 through 9
            var digit = /[0-9]/;

            <letter> ::= any one of the 52 alphabetic characters A through Z in upper case and a through z in lower case
            var letter = /[a-zA-Z]/;

            <let-dig> ::= <letter> | <digit>
            var letDig = /[0-9a-zA-Z]/;

            <let-dig-hyp> ::= <let-dig> | "-"
            var letDigHyp = /[-0-9a-zA-Z]/;

            <ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>
            var ldhStr = /[-0-9a-zA-Z]+/;

            <label> ::= <letter> [ [ <ldh-str> ] <let-dig> ]
            var label = /[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?/;

            <subdomain> ::= <label> | <subdomain> "." <label>
            var subdomain = /^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/;

            <domain> ::= <subdomain> | " "
            var domain = null;
        */
        var valid = /^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/.test(hostname);
        if (valid) {
          // the sum of all label octets and label lengths is limited to 255.
          if (hostname.length > 255) { return false; }
          // Each node has a label, which is zero to 63 octets in length
          var labels = hostname.split(".");
          for (var i = 0; i < labels.length; i++) { if (labels[i].length > 63) { return false; } }
        }
        return valid;
      },
      "host-name": function (hostname) {
        return FormatValidators.hostname.call(this, hostname);
      },
      "ipv4": function (ipv4) {
        if (typeof ipv4 !== "string") { return true; }
        return validator.isIP(ipv4, 4);
      },
      "ipv6": function (ipv6) {
        if (typeof ipv6 !== "string") { return true; }
        return validator.isIP(ipv6, 6);
      },
      "regex": function (str) {
        try {
          RegExp(str);
          return true;
        } catch (e) {
          return false;
        }
      },
      "uri": function (uri) {
        if (this.options.strictUris) {
          return FormatValidators["strict-uri"].apply(this, arguments);
        }
        // https://github.com/zaggino/z-schema/issues/18
        // RegExp from http://tools.ietf.org/html/rfc3986#appendix-B
        return typeof uri !== "string" || RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?").test(uri);
      },
      "strict-uri": function (uri) {
        return typeof uri !== "string" || validator.isURL(uri);
      }
    };

    module.exports = FormatValidators;

  }, { "validator": 78 }], 81: [function (require, module, exports) {
    "use strict";

    var FormatValidators = require("./FormatValidators"),
      Report = require("./Report"),
      Utils = require("./Utils");

    var JsonValidators = {
      multipleOf: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.1.2
        if (typeof json !== "number") {
          return;
        }
        if (Utils.whatIs(json / schema.multipleOf) !== "integer") {
          report.addError("MULTIPLE_OF", [json, schema.multipleOf], null, schema.description);
        }
      },
      maximum: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.2
        if (typeof json !== "number") {
          return;
        }
        if (schema.exclusiveMaximum !== true) {
          if (json > schema.maximum) {
            report.addError("MAXIMUM", [json, schema.maximum], null, schema.description);
          }
        } else {
          if (json >= schema.maximum) {
            report.addError("MAXIMUM_EXCLUSIVE", [json, schema.maximum], null, schema.description);
          }
        }
      },
      exclusiveMaximum: function () {
        // covered in maximum
      },
      minimum: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.2
        if (typeof json !== "number") {
          return;
        }
        if (schema.exclusiveMinimum !== true) {
          if (json < schema.minimum) {
            report.addError("MINIMUM", [json, schema.minimum], null, schema.description);
          }
        } else {
          if (json <= schema.minimum) {
            report.addError("MINIMUM_EXCLUSIVE", [json, schema.minimum], null, schema.description);
          }
        }
      },
      exclusiveMinimum: function () {
        // covered in minimum
      },
      maxLength: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.1.2
        if (typeof json !== "string") {
          return;
        }
        if (Utils.ucs2decode(json).length > schema.maxLength) {
          report.addError("MAX_LENGTH", [json.length, schema.maxLength], null, schema.description);
        }
      },
      minLength: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.2.2
        if (typeof json !== "string") {
          return;
        }
        if (Utils.ucs2decode(json).length < schema.minLength) {
          report.addError("MIN_LENGTH", [json.length, schema.minLength], null, schema.description);
        }
      },
      pattern: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.3.2
        if (typeof json !== "string") {
          return;
        }
        if (RegExp(schema.pattern).test(json) === false) {
          report.addError("PATTERN", [schema.pattern, json], null, schema.description);
        }
      },
      additionalItems: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.2
        if (!Array.isArray(json)) {
          return;
        }
        // if the value of "additionalItems" is boolean value false and the value of "items" is an array,
        // the json is valid if its size is less than, or equal to, the size of "items".
        if (schema.additionalItems === false && Array.isArray(schema.items)) {
          if (json.length > schema.items.length) {
            report.addError("ARRAY_ADDITIONAL_ITEMS", null, null, schema.description);
          }
        }
      },
      items: function () { /*report, schema, json*/
        // covered in additionalItems
      },
      maxItems: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.2.2
        if (!Array.isArray(json)) {
          return;
        }
        if (json.length > schema.maxItems) {
          report.addError("ARRAY_LENGTH_LONG", [json.length, schema.maxItems], null, schema.description);
        }
      },
      minItems: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.3.2
        if (!Array.isArray(json)) {
          return;
        }
        if (json.length < schema.minItems) {
          report.addError("ARRAY_LENGTH_SHORT", [json.length, schema.minItems], null, schema.description);
        }
      },
      uniqueItems: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.4.2
        if (!Array.isArray(json)) {
          return;
        }
        if (schema.uniqueItems === true) {
          var matches = [];
          if (Utils.isUniqueArray(json, matches) === false) {
            report.addError("ARRAY_UNIQUE", matches, null, schema.description);
          }
        }
      },
      maxProperties: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.1.2
        if (Utils.whatIs(json) !== "object") {
          return;
        }
        var keysCount = Object.keys(json).length;
        if (keysCount > schema.maxProperties) {
          report.addError("OBJECT_PROPERTIES_MAXIMUM", [keysCount, schema.maxProperties], null, schema.description);
        }
      },
      minProperties: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.2.2
        if (Utils.whatIs(json) !== "object") {
          return;
        }
        var keysCount = Object.keys(json).length;
        if (keysCount < schema.minProperties) {
          report.addError("OBJECT_PROPERTIES_MINIMUM", [keysCount, schema.minProperties], null, schema.description);
        }
      },
      required: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.3.2
        if (Utils.whatIs(json) !== "object") {
          return;
        }
        var idx = schema.required.length;
        while (idx--) {
          var requiredPropertyName = schema.required[idx];
          if (json[requiredPropertyName] === undefined) {
            report.addError("OBJECT_MISSING_REQUIRED_PROPERTY", [requiredPropertyName], null, schema.description);
          }
        }
      },
      additionalProperties: function (report, schema, json) {
        // covered in properties and patternProperties
        if (schema.properties === undefined && schema.patternProperties === undefined) {
          return JsonValidators.properties.call(this, report, schema, json);
        }
      },
      patternProperties: function (report, schema, json) {
        // covered in properties
        if (schema.properties === undefined) {
          return JsonValidators.properties.call(this, report, schema, json);
        }
      },
      properties: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.2
        if (Utils.whatIs(json) !== "object") {
          return;
        }
        var properties = schema.properties !== undefined ? schema.properties : {};
        var patternProperties = schema.patternProperties !== undefined ? schema.patternProperties : {};
        if (schema.additionalProperties === false) {
          // The property set of the json to validate.
          var s = Object.keys(json);
          // The property set from "properties".
          var p = Object.keys(properties);
          // The property set from "patternProperties".
          var pp = Object.keys(patternProperties);
          // remove from "s" all elements of "p", if any;
          s = Utils.difference(s, p);
          // for each regex in "pp", remove all elements of "s" which this regex matches.
          var idx = pp.length;
          while (idx--) {
            var regExp = RegExp(pp[idx]),
              idx2 = s.length;
            while (idx2--) {
              if (regExp.test(s[idx2]) === true) {
                s.splice(idx2, 1);
              }
            }
          }
          // Validation of the json succeeds if, after these two steps, set "s" is empty.
          if (s.length > 0) {
            report.addError("OBJECT_ADDITIONAL_PROPERTIES", [s], null, schema.description);
          }
        }
      },
      dependencies: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.5.2
        if (Utils.whatIs(json) !== "object") {
          return;
        }

        var keys = Object.keys(schema.dependencies),
          idx = keys.length;

        while (idx--) {
          // iterate all dependencies
          var dependencyName = keys[idx];
          if (json[dependencyName]) {
            var dependencyDefinition = schema.dependencies[dependencyName];
            if (Utils.whatIs(dependencyDefinition) === "object") {
              // if dependency is a schema, validate against this schema
              exports.validate.call(this, report, dependencyDefinition, json);
            } else { // Array
              // if dependency is an array, object needs to have all properties in this array
              var idx2 = dependencyDefinition.length;
              while (idx2--) {
                var requiredPropertyName = dependencyDefinition[idx2];
                if (json[requiredPropertyName] === undefined) {
                  report.addError("OBJECT_DEPENDENCY_KEY", [requiredPropertyName, dependencyName], null, schema.description);
                }
              }
            }
          }
        }
      },
      enum: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.1.2
        var match = false,
          idx = schema.enum.length;
        while (idx--) {
          if (Utils.areEqual(json, schema.enum[idx])) {
            match = true;
            break;
          }
        }
        if (match === false) {
          report.addError("ENUM_MISMATCH", [json], null, schema.description);
        }
      },
      /*
      type: function (report, schema, json) {
          // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.2
          // type is handled before this is called so ignore
      },
      */
      allOf: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.3.2
        var idx = schema.allOf.length;
        while (idx--) {
          if (exports.validate.call(this, report, schema.allOf[idx], json) === false) {
            break;
          }
        }
      },
      anyOf: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.4.2
        var subReports = [],
          passed = false,
          idx = schema.anyOf.length;

        while (idx-- && passed === false) {
          var subReport = new Report(report);
          subReports.push(subReport);
          passed = exports.validate.call(this, subReport, schema.anyOf[idx], json);
        }

        if (passed === false) {
          report.addError("ANY_OF_MISSING", undefined, subReports, schema.description);
        }
      },
      oneOf: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.5.2
        var passes = 0,
          subReports = [],
          idx = schema.oneOf.length;

        while (idx--) {
          var subReport = new Report(report, { maxErrors: 1 });
          subReports.push(subReport);
          if (exports.validate.call(this, subReport, schema.oneOf[idx], json) === true) {
            passes++;
          }
        }

        if (passes === 0) {
          report.addError("ONE_OF_MISSING", undefined, subReports, schema.description);
        } else if (passes > 1) {
          report.addError("ONE_OF_MULTIPLE", null, null, schema.description);
        }
      },
      not: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.6.2
        var subReport = new Report(report);
        if (exports.validate.call(this, subReport, schema.not, json) === true) {
          report.addError("NOT_PASSED", null, null, schema.description);
        }
      },
      definitions: function () { /*report, schema, json*/
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.7.2
        // nothing to do here
      },
      format: function (report, schema, json) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.7.2
        var formatValidatorFn = FormatValidators[schema.format];
        if (typeof formatValidatorFn === "function") {
          if (formatValidatorFn.length === 2) {
            // async
            report.addAsyncTask(formatValidatorFn, [json], function (result) {
              if (result !== true) {
                report.addError("INVALID_FORMAT", [schema.format, json], null, schema.description);
              }
            });
          } else {
            // sync
            if (formatValidatorFn.call(this, json) !== true) {
              report.addError("INVALID_FORMAT", [schema.format, json], null, schema.description);
            }
          }
        } else {
          report.addError("UNKNOWN_FORMAT", [schema.format], null, schema.description);
        }
      }
    };

    var recurseArray = function (report, schema, json) {
      // http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.2

      var idx = json.length;

      // If "items" is an array, this situation, the schema depends on the index:
      // if the index is less than, or equal to, the size of "items",
      // the child instance must be valid against the corresponding schema in the "items" array;
      // otherwise, it must be valid against the schema defined by "additionalItems".
      if (Array.isArray(schema.items)) {

        while (idx--) {
          // equal to doesnt make sense here
          if (idx < schema.items.length) {
            report.path.push(idx.toString());
            exports.validate.call(this, report, schema.items[idx], json[idx]);
            report.path.pop();
          } else {
            // might be boolean, so check that it's an object
            if (typeof schema.additionalItems === "object") {
              report.path.push(idx.toString());
              exports.validate.call(this, report, schema.additionalItems, json[idx]);
              report.path.pop();
            }
          }
        }

      } else if (typeof schema.items === "object") {

        // If items is a schema, then the child instance must be valid against this schema,
        // regardless of its index, and regardless of the value of "additionalItems".
        while (idx--) {
          report.path.push(idx.toString());
          exports.validate.call(this, report, schema.items, json[idx]);
          report.path.pop();
        }

      }
    };

    var recurseObject = function (report, schema, json) {
      // http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.3

      // If "additionalProperties" is absent, it is considered present with an empty schema as a value.
      // In addition, boolean value true is considered equivalent to an empty schema.
      var additionalProperties = schema.additionalProperties;
      if (additionalProperties === true || additionalProperties === undefined) {
        additionalProperties = {};
      }

      // p - The property set from "properties".
      var p = schema.properties ? Object.keys(schema.properties) : [];

      // pp - The property set from "patternProperties". Elements of this set will be called regexes for convenience.
      var pp = schema.patternProperties ? Object.keys(schema.patternProperties) : [];

      // m - The property name of the child.
      var keys = Object.keys(json),
        idx = keys.length;

      while (idx--) {
        var m = keys[idx],
          propertyValue = json[m];

        // s - The set of schemas for the child instance.
        var s = [];

        // 1. If set "p" contains value "m", then the corresponding schema in "properties" is added to "s".
        if (p.indexOf(m) !== -1) {
          s.push(schema.properties[m]);
        }

        // 2. For each regex in "pp", if it matches "m" successfully, the corresponding schema in "patternProperties" is added to "s".
        var idx2 = pp.length;
        while (idx2--) {
          var regexString = pp[idx2];
          if (RegExp(regexString).test(m) === true) {
            s.push(schema.patternProperties[regexString]);
          }
        }

        // 3. The schema defined by "additionalProperties" is added to "s" if and only if, at this stage, "s" is empty.
        if (s.length === 0 && additionalProperties !== false) {
          s.push(additionalProperties);
        }

        // we are passing tests even without this assert because this is covered by properties check
        // if s is empty in this stage, no additionalProperties are allowed
        // report.expect(s.length !== 0, 'E001', m);

        // Instance property value must pass all schemas from s
        idx2 = s.length;
        while (idx2--) {
          report.path.push(m);
          exports.validate.call(this, report, s[idx2], propertyValue);
          report.path.pop();
        }
      }
    };

    exports.validate = function (report, schema, json) {

      report.commonErrorMessage = "JSON_OBJECT_VALIDATION_FAILED";

      // check if schema is an object
      var to = Utils.whatIs(schema);
      if (to !== "object") {
        report.addError("SCHEMA_NOT_AN_OBJECT", [to], null, schema.description);
        return false;
      }

      // check if schema is empty, everything is valid against empty schema
      var keys = Object.keys(schema);
      if (keys.length === 0) {
        return true;
      }

      // this method can be called recursively, so we need to remember our root
      var isRoot = false;
      if (!report.rootSchema) {
        report.rootSchema = schema;
        isRoot = true;
      }

      // follow schema.$ref keys
      if (schema.$ref !== undefined) {
        // avoid infinite loop with maxRefs
        var maxRefs = 99;
        while (schema.$ref && maxRefs > 0) {
          if (!schema.__$refResolved) {
            report.addError("REF_UNRESOLVED", [schema.$ref], null, schema.description);
            break;
          } else if (schema.__$refResolved === schema) {
            break;
          } else {
            schema = schema.__$refResolved;
            keys = Object.keys(schema);
          }
          maxRefs--;
        }
        if (maxRefs === 0) {
          throw new Error("Circular dependency by $ref references!");
        }
      }

      // type checking first
      // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.2
      var jsonType = Utils.whatIs(json);
      if (schema.type) {
        if (typeof schema.type === "string") {
          if (jsonType !== schema.type && (jsonType !== "integer" || schema.type !== "number")) {
            report.addError("INVALID_TYPE", [schema.type, jsonType], null, schema.description);
            if (this.options.breakOnFirstError) {
              return false;
            }
          }
        } else {
          if (schema.type.indexOf(jsonType) === -1 && (jsonType !== "integer" || schema.type.indexOf("number") === -1)) {
            report.addError("INVALID_TYPE", [schema.type, jsonType], null, schema.description);
            if (this.options.breakOnFirstError) {
              return false;
            }
          }
        }
      }

      // now iterate all the keys in schema and execute validation methods
      var idx = keys.length;
      while (idx--) {
        if (JsonValidators[keys[idx]]) {
          JsonValidators[keys[idx]].call(this, report, schema, json);
          if (report.errors.length && this.options.breakOnFirstError) { break; }
        }
      }

      if (report.errors.length === 0 || this.options.breakOnFirstError === false) {
        if (jsonType === "array") {
          recurseArray.call(this, report, schema, json);
        } else if (jsonType === "object") {
          recurseObject.call(this, report, schema, json);
        }
      }

      // we don't need the root pointer anymore
      if (isRoot) {
        report.rootSchema = undefined;
      }

      // return valid just to be able to break at some code points
      return report.errors.length === 0;

    };

  }, { "./FormatValidators": 80, "./Report": 83, "./Utils": 87 }], 82: [function (require, module, exports) {
    // Number.isFinite polyfill
    // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite
    if (typeof Number.isFinite !== "function") {
      Number.isFinite = function isFinite(value) {
        // 1. If Type(number) is not Number, return false.
        if (typeof value !== "number") {
          return false;
        }
        // 2. If number is NaN, +∞, or −∞, return false.
        if (value !== value || value === Infinity || value === -Infinity) {
          return false;
        }
        // 3. Otherwise, return true.
        return true;
      };
    }

  }, {}], 83: [function (require, module, exports) {
    (function (process) {
      "use strict";

      var Errors = require("./Errors");
      var Utils = require("./Utils");

      function Report(parentOrOptions, reportOptions) {
        this.parentReport = parentOrOptions instanceof Report ?
          parentOrOptions :
          undefined;

        this.options = parentOrOptions instanceof Report ?
          parentOrOptions.options :
          parentOrOptions || {};

        this.reportOptions = reportOptions || {};

        this.errors = [];
        this.path = [];
        this.asyncTasks = [];
      }

      Report.prototype.isValid = function () {
        if (this.asyncTasks.length > 0) {
          throw new Error("Async tasks pending, can't answer isValid");
        }
        return this.errors.length === 0;
      };

      Report.prototype.addAsyncTask = function (fn, args, asyncTaskResultProcessFn) {
        this.asyncTasks.push([fn, args, asyncTaskResultProcessFn]);
      };

      Report.prototype.processAsyncTasks = function (timeout, callback) {

        var validationTimeout = timeout || 2000,
          tasksCount = this.asyncTasks.length,
          idx = tasksCount,
          timedOut = false,
          self = this;

        function finish() {
          process.nextTick(function () {
            var valid = self.errors.length === 0,
              err = valid ? undefined : self.errors;
            callback(err, valid);
          });
        }

        function respond(asyncTaskResultProcessFn) {
          return function (asyncTaskResult) {
            if (timedOut) { return; }
            asyncTaskResultProcessFn(asyncTaskResult);
            if (--tasksCount === 0) {
              finish();
            }
          };
        }

        if (tasksCount === 0 || this.errors.length > 0) {
          finish();
          return;
        }

        while (idx--) {
          var task = this.asyncTasks[idx];
          task[0].apply(null, task[1].concat(respond(task[2])));
        }

        setTimeout(function () {
          if (tasksCount > 0) {
            timedOut = true;
            self.addError("ASYNC_TIMEOUT", [tasksCount, validationTimeout]);
            callback(self.errors, false);
          }
        }, validationTimeout);

      };

      Report.prototype.getPath = function () {
        var path = [];
        if (this.parentReport) {
          path = path.concat(this.parentReport.path);
        }
        path = path.concat(this.path);

        if (this.options.reportPathAsArray !== true) {
          // Sanitize the path segments (http://tools.ietf.org/html/rfc6901#section-4)
          path = "#/" + path.map(function (segment) {

            if (Utils.isAbsoluteUri(segment)) {
              return "uri(" + segment + ")";
            }

            return segment.replace("~", "~0").replace("/", "~1");
          }).join("/");
        }
        return path;
      };

      Report.prototype.addError = function (errorCode, params, subReports, schemaDescription) {
        if (this.errors.length >= this.reportOptions.maxErrors) {
          return;
        }

        if (!errorCode) { throw new Error("No errorCode passed into addError()"); }
        if (!Errors[errorCode]) { throw new Error("No errorMessage known for code " + errorCode); }

        params = params || [];

        var idx = params.length,
          errorMessage = Errors[errorCode];
        while (idx--) {
          var whatIs = Utils.whatIs(params[idx]);
          var param = (whatIs === "object" || whatIs === "null") ? JSON.stringify(params[idx]) : params[idx];
          errorMessage = errorMessage.replace("{" + idx + "}", param);
        }

        var err = {
          code: errorCode,
          params: params,
          message: errorMessage,
          path: this.getPath()
        };

        if (schemaDescription) {
          err.description = schemaDescription;
        }

        if (subReports != null) {
          if (!Array.isArray(subReports)) {
            subReports = [subReports];
          }
          err.inner = [];
          idx = subReports.length;
          while (idx--) {
            var subReport = subReports[idx],
              idx2 = subReport.errors.length;
            while (idx2--) {
              err.inner.push(subReport.errors[idx2]);
            }
          }
          if (err.inner.length === 0) {
            err.inner = undefined;
          }
        }

        this.errors.push(err);
      };

      module.exports = Report;

    }).call(this, require('_process'))
  }, { "./Errors": 79, "./Utils": 87, "_process": 92 }], 84: [function (require, module, exports) {
    "use strict";

    var Report = require("./Report");
    var SchemaCompilation = require("./SchemaCompilation");
    var SchemaValidation = require("./SchemaValidation");
    var Utils = require("./Utils");

    function decodeJSONPointer(str) {
      // http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-07#section-3
      return decodeURIComponent(str).replace(/~[0-1]/g, function (x) {
        return x === "~1" ? "/" : "~";
      });
    }

    function getRemotePath(uri) {
      var io = uri.indexOf("#");
      return io === -1 ? uri : uri.slice(0, io);
    }

    function getQueryPath(uri) {
      var io = uri.indexOf("#");
      var res = io === -1 ? undefined : uri.slice(io + 1);
      // WARN: do not slice slash, #/ means take root and go down from it
      // if (res && res[0] === "/") { res = res.slice(1); }
      return res;
    }

    function findId(schema, id) {
      // process only arrays and objects
      if (typeof schema !== "object" || schema === null) {
        return;
      }

      // no id means root so return itself
      if (!id) {
        return schema;
      }

      if (schema.id) {
        if (schema.id === id || schema.id[0] === "#" && schema.id.substring(1) === id) {
          return schema;
        }
      }

      var idx, result;
      if (Array.isArray(schema)) {
        idx = schema.length;
        while (idx--) {
          result = findId(schema[idx], id);
          if (result) { return result; }
        }
      } else {
        var keys = Object.keys(schema);
        idx = keys.length;
        while (idx--) {
          var k = keys[idx];
          if (k.indexOf("__$") === 0) {
            continue;
          }
          result = findId(schema[k], id);
          if (result) { return result; }
        }
      }
    }

    exports.cacheSchemaByUri = function (uri, schema) {
      var remotePath = getRemotePath(uri);
      if (remotePath) {
        this.cache[remotePath] = schema;
      }
    };

    exports.removeFromCacheByUri = function (uri) {
      var remotePath = getRemotePath(uri);
      if (remotePath) {
        this.cache[remotePath] = undefined;
      }
    };

    exports.checkCacheForUri = function (uri) {
      var remotePath = getRemotePath(uri);
      return remotePath ? this.cache[remotePath] != null : false;
    };

    exports.getSchema = function (report, schema) {
      if (typeof schema === "object") {
        schema = exports.getSchemaByReference.call(this, report, schema);
      }
      if (typeof schema === "string") {
        schema = exports.getSchemaByUri.call(this, report, schema);
      }
      return schema;
    };

    exports.getSchemaByReference = function (report, key) {
      var i = this.referenceCache.length;
      while (i--) {
        if (this.referenceCache[i][0] === key) {
          return this.referenceCache[i][1];
        }
      }
      // not found
      var schema = Utils.cloneDeep(key);
      this.referenceCache.push([key, schema]);
      return schema;
    };

    exports.getSchemaByUri = function (report, uri, root) {
      var remotePath = getRemotePath(uri),
        queryPath = getQueryPath(uri),
        result = remotePath ? this.cache[remotePath] : root;

      if (result && remotePath) {
        // we need to avoid compiling schemas in a recursive loop
        var compileRemote = result !== root;
        // now we need to compile and validate resolved schema (in case it's not already)
        if (compileRemote) {

          report.path.push(remotePath);

          var remoteReport = new Report(report);
          if (SchemaCompilation.compileSchema.call(this, remoteReport, result)) {
            SchemaValidation.validateSchema.call(this, remoteReport, result);
          }
          var remoteReportIsValid = remoteReport.isValid();
          if (!remoteReportIsValid) {
            report.addError("REMOTE_NOT_VALID", [uri], remoteReport);
          }

          report.path.pop();

          if (!remoteReportIsValid) {
            return undefined;
          }
        }
      }

      if (result && queryPath) {
        var parts = queryPath.split("/");
        for (var idx = 0, lim = parts.length; idx < lim; idx++) {
          var key = decodeJSONPointer(parts[idx]);
          if (idx === 0) { // it's an id
            result = findId(result, key);
          } else { // it's a path behind id
            result = result[key];
          }
        }
      }

      return result;
    };

    exports.getRemotePath = getRemotePath;

  }, { "./Report": 83, "./SchemaCompilation": 85, "./SchemaValidation": 86, "./Utils": 87 }], 85: [function (require, module, exports) {
    "use strict";

    var Report = require("./Report");
    var SchemaCache = require("./SchemaCache");
    var Utils = require("./Utils");

    function mergeReference(scope, ref) {
      if (Utils.isAbsoluteUri(ref)) {
        return ref;
      }

      var joinedScope = scope.join(""),
        isScopeAbsolute = Utils.isAbsoluteUri(joinedScope),
        isScopeRelative = Utils.isRelativeUri(joinedScope),
        isRefRelative = Utils.isRelativeUri(ref),
        toRemove;

      if (isScopeAbsolute && isRefRelative) {
        toRemove = joinedScope.match(/\/[^\/]*$/);
        if (toRemove) {
          joinedScope = joinedScope.slice(0, toRemove.index + 1);
        }
      } else if (isScopeRelative && isRefRelative) {
        joinedScope = "";
      } else {
        toRemove = joinedScope.match(/[^#/]+$/);
        if (toRemove) {
          joinedScope = joinedScope.slice(0, toRemove.index);
        }
      }

      var res = joinedScope + ref;
      res = res.replace(/##/, "#");
      return res;
    }

    function collectReferences(obj, results, scope, path) {
      results = results || [];
      scope = scope || [];
      path = path || [];

      if (typeof obj !== "object" || obj === null) {
        return results;
      }

      if (typeof obj.id === "string") {
        scope.push(obj.id);
      }

      if (typeof obj.$ref === "string" && typeof obj.__$refResolved === "undefined") {
        results.push({
          ref: mergeReference(scope, obj.$ref),
          key: "$ref",
          obj: obj,
          path: path.slice(0)
        });
      }
      if (typeof obj.$schema === "string" && typeof obj.__$schemaResolved === "undefined") {
        results.push({
          ref: mergeReference(scope, obj.$schema),
          key: "$schema",
          obj: obj,
          path: path.slice(0)
        });
      }

      var idx;
      if (Array.isArray(obj)) {
        idx = obj.length;
        while (idx--) {
          path.push(idx.toString());
          collectReferences(obj[idx], results, scope, path);
          path.pop();
        }
      } else {
        var keys = Object.keys(obj);
        idx = keys.length;
        while (idx--) {
          // do not recurse through resolved references and other z-schema props
          if (keys[idx].indexOf("__$") === 0) { continue; }
          path.push(keys[idx]);
          collectReferences(obj[keys[idx]], results, scope, path);
          path.pop();
        }
      }

      if (typeof obj.id === "string") {
        scope.pop();
      }

      return results;
    }

    var compileArrayOfSchemasLoop = function (mainReport, arr) {
      var idx = arr.length,
        compiledCount = 0;

      while (idx--) {

        // try to compile each schema separately
        var report = new Report(mainReport);
        var isValid = exports.compileSchema.call(this, report, arr[idx]);
        if (isValid) { compiledCount++; }

        // copy errors to report
        mainReport.errors = mainReport.errors.concat(report.errors);

      }

      return compiledCount;
    };

    function findId(arr, id) {
      var idx = arr.length;
      while (idx--) {
        if (arr[idx].id === id) {
          return arr[idx];
        }
      }
      return null;
    }

    var compileArrayOfSchemas = function (report, arr) {

      var compiled = 0,
        lastLoopCompiled;

      do {

        // remove all UNRESOLVABLE_REFERENCE errors before compiling array again
        var idx = report.errors.length;
        while (idx--) {
          if (report.errors[idx].code === "UNRESOLVABLE_REFERENCE") {
            report.errors.splice(idx, 1);
          }
        }

        // remember how many were compiled in the last loop
        lastLoopCompiled = compiled;

        // count how many are compiled now
        compiled = compileArrayOfSchemasLoop.call(this, report, arr);

        // fix __$missingReferences if possible
        idx = arr.length;
        while (idx--) {
          var sch = arr[idx];
          if (sch.__$missingReferences) {
            var idx2 = sch.__$missingReferences.length;
            while (idx2--) {
              var refObj = sch.__$missingReferences[idx2];
              var response = findId(arr, refObj.ref);
              if (response) {
                // this might create circular references
                refObj.obj["__" + refObj.key + "Resolved"] = response;
                // it's resolved now so delete it
                sch.__$missingReferences.splice(idx2, 1);
              }
            }
            if (sch.__$missingReferences.length === 0) {
              delete sch.__$missingReferences;
            }
          }
        }

        // keep repeating if not all compiled and at least one more was compiled in the last loop
      } while (compiled !== arr.length && compiled !== lastLoopCompiled);

      return report.isValid();

    };

    exports.compileSchema = function (report, schema) {

      report.commonErrorMessage = "SCHEMA_COMPILATION_FAILED";

      // if schema is a string, assume it's a uri
      if (typeof schema === "string") {
        var loadedSchema = SchemaCache.getSchemaByUri.call(this, report, schema);
        if (!loadedSchema) {
          report.addError("SCHEMA_NOT_REACHABLE", [schema]);
          return false;
        }
        schema = loadedSchema;
      }

      // if schema is an array, assume it's an array of schemas
      if (Array.isArray(schema)) {
        return compileArrayOfSchemas.call(this, report, schema);
      }

      // if we have an id than it should be cached already (if this instance has compiled it)
      if (schema.__$compiled && schema.id && SchemaCache.checkCacheForUri.call(this, schema.id) === false) {
        schema.__$compiled = undefined;
      }

      // do not re-compile schemas
      if (schema.__$compiled) {
        return true;
      }

      if (schema.id) {
        // add this to our schemaCache (before compilation in case we have references including id)
        SchemaCache.cacheSchemaByUri.call(this, schema.id, schema);
      }

      // delete all __$missingReferences from previous compilation attempts
      var isValidExceptReferences = report.isValid();
      delete schema.__$missingReferences;

      // collect all references that need to be resolved - $ref and $schema
      var refs = collectReferences.call(this, schema),
        idx = refs.length;
      while (idx--) {
        // resolve all the collected references into __xxxResolved pointer
        var refObj = refs[idx];
        var response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);

        // we can try to use custom schemaReader if available
        if (!response) {
          var schemaReader = this.getSchemaReader();
          if (schemaReader) {
            // it's supposed to return a valid schema
            var s = schemaReader(refObj.ref);
            if (s) {
              // it needs to have the id
              s.id = refObj.ref;
              // try to compile the schema
              var subreport = new Report(report);
              if (!exports.compileSchema.call(this, subreport, s)) {
                // copy errors to report
                report.errors = report.errors.concat(subreport.errors);
              } else {
                response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);
              }
            }
          }
        }

        if (!response) {

          var isAbsolute = Utils.isAbsoluteUri(refObj.ref);
          var isDownloaded = false;
          var ignoreUnresolvableRemotes = this.options.ignoreUnresolvableReferences === true;

          if (isAbsolute) {
            // we shouldn't add UNRESOLVABLE_REFERENCE for schemas we already have downloaded
            // and set through setRemoteReference method
            isDownloaded = SchemaCache.checkCacheForUri.call(this, refObj.ref);
          }

          if (!isAbsolute || !isDownloaded && !ignoreUnresolvableRemotes) {
            Array.prototype.push.apply(report.path, refObj.path);
            report.addError("UNRESOLVABLE_REFERENCE", [refObj.ref]);
            report.path.slice(0, -refObj.path.length);

            // pusblish unresolved references out
            if (isValidExceptReferences) {
              schema.__$missingReferences = schema.__$missingReferences || [];
              schema.__$missingReferences.push(refObj);
            }
          }
        }
        // this might create circular references
        refObj.obj["__" + refObj.key + "Resolved"] = response;
      }

      var isValid = report.isValid();
      if (isValid) {
        schema.__$compiled = true;
      } else {
        if (schema.id) {
          // remove this schema from schemaCache because it failed to compile
          SchemaCache.removeFromCacheByUri.call(this, schema.id);
        }
      }
      return isValid;

    };

  }, { "./Report": 83, "./SchemaCache": 84, "./Utils": 87 }], 86: [function (require, module, exports) {
    "use strict";

    var FormatValidators = require("./FormatValidators"),
      JsonValidation = require("./JsonValidation"),
      Report = require("./Report"),
      Utils = require("./Utils");

    var SchemaValidators = {
      $ref: function (report, schema) {
        // http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-07
        // http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03
        if (typeof schema.$ref !== "string") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["$ref", "string"]);
        }
      },
      $schema: function (report, schema) {
        // http://json-schema.org/latest/json-schema-core.html#rfc.section.6
        if (typeof schema.$schema !== "string") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["$schema", "string"]);
        }
      },
      multipleOf: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.1.1
        if (typeof schema.multipleOf !== "number") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["multipleOf", "number"]);
        } else if (schema.multipleOf <= 0) {
          report.addError("KEYWORD_MUST_BE", ["multipleOf", "strictly greater than 0"]);
        }
      },
      maximum: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.1
        if (typeof schema.maximum !== "number") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["maximum", "number"]);
        }
      },
      exclusiveMaximum: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.1
        if (typeof schema.exclusiveMaximum !== "boolean") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["exclusiveMaximum", "boolean"]);
        } else if (schema.maximum === undefined) {
          report.addError("KEYWORD_DEPENDENCY", ["exclusiveMaximum", "maximum"]);
        }
      },
      minimum: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.1
        if (typeof schema.minimum !== "number") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["minimum", "number"]);
        }
      },
      exclusiveMinimum: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.1
        if (typeof schema.exclusiveMinimum !== "boolean") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["exclusiveMinimum", "boolean"]);
        } else if (schema.minimum === undefined) {
          report.addError("KEYWORD_DEPENDENCY", ["exclusiveMinimum", "minimum"]);
        }
      },
      maxLength: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.1.1
        if (Utils.whatIs(schema.maxLength) !== "integer") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["maxLength", "integer"]);
        } else if (schema.maxLength < 0) {
          report.addError("KEYWORD_MUST_BE", ["maxLength", "greater than, or equal to 0"]);
        }
      },
      minLength: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.2.1
        if (Utils.whatIs(schema.minLength) !== "integer") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["minLength", "integer"]);
        } else if (schema.minLength < 0) {
          report.addError("KEYWORD_MUST_BE", ["minLength", "greater than, or equal to 0"]);
        }
      },
      pattern: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.3.1
        if (typeof schema.pattern !== "string") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["pattern", "string"]);
        } else {
          try {
            RegExp(schema.pattern);
          } catch (e) {
            report.addError("KEYWORD_PATTERN", ["pattern", schema.pattern]);
          }
        }
      },
      additionalItems: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.1
        var type = Utils.whatIs(schema.additionalItems);
        if (type !== "boolean" && type !== "object") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["additionalItems", ["boolean", "object"]]);
        } else if (type === "object") {
          report.path.push("additionalItems");
          exports.validateSchema.call(this, report, schema.additionalItems);
          report.path.pop();
        }
      },
      items: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.1
        var type = Utils.whatIs(schema.items);

        if (type === "object") {
          report.path.push("items");
          exports.validateSchema.call(this, report, schema.items);
          report.path.pop();
        } else if (type === "array") {
          var idx = schema.items.length;
          while (idx--) {
            report.path.push("items");
            report.path.push(idx.toString());
            exports.validateSchema.call(this, report, schema.items[idx]);
            report.path.pop();
            report.path.pop();
          }
        } else {
          report.addError("KEYWORD_TYPE_EXPECTED", ["items", ["array", "object"]]);
        }

        // custom - strict mode
        if (this.options.forceAdditional === true && schema.additionalItems === undefined && Array.isArray(schema.items)) {
          report.addError("KEYWORD_UNDEFINED_STRICT", ["additionalItems"]);
        }
        // custome - assume defined false mode
        if (this.options.assumeAdditional === true && schema.additionalItems === undefined && Array.isArray(schema.items)) {
          schema.additionalItems = false;
        }
      },
      maxItems: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.2.1
        if (typeof schema.maxItems !== "number") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["maxItems", "integer"]);
        } else if (schema.maxItems < 0) {
          report.addError("KEYWORD_MUST_BE", ["maxItems", "greater than, or equal to 0"]);
        }
      },
      minItems: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.3.1
        if (Utils.whatIs(schema.minItems) !== "integer") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["minItems", "integer"]);
        } else if (schema.minItems < 0) {
          report.addError("KEYWORD_MUST_BE", ["minItems", "greater than, or equal to 0"]);
        }
      },
      uniqueItems: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.4.1
        if (typeof schema.uniqueItems !== "boolean") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["uniqueItems", "boolean"]);
        }
      },
      maxProperties: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.1.1
        if (Utils.whatIs(schema.maxProperties) !== "integer") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["maxProperties", "integer"]);
        } else if (schema.maxProperties < 0) {
          report.addError("KEYWORD_MUST_BE", ["maxProperties", "greater than, or equal to 0"]);
        }
      },
      minProperties: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.2.1
        if (Utils.whatIs(schema.minProperties) !== "integer") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["minProperties", "integer"]);
        } else if (schema.minProperties < 0) {
          report.addError("KEYWORD_MUST_BE", ["minProperties", "greater than, or equal to 0"]);
        }
      },
      required: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.3.1
        if (Utils.whatIs(schema.required) !== "array") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["required", "array"]);
        } else if (schema.required.length === 0) {
          report.addError("KEYWORD_MUST_BE", ["required", "an array with at least one element"]);
        } else {
          var idx = schema.required.length;
          while (idx--) {
            if (typeof schema.required[idx] !== "string") {
              report.addError("KEYWORD_VALUE_TYPE", ["required", "string"]);
            }
          }
          if (Utils.isUniqueArray(schema.required) === false) {
            report.addError("KEYWORD_MUST_BE", ["required", "an array with unique items"]);
          }
        }
      },
      additionalProperties: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1
        var type = Utils.whatIs(schema.additionalProperties);
        if (type !== "boolean" && type !== "object") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["additionalProperties", ["boolean", "object"]]);
        } else if (type === "object") {
          report.path.push("additionalProperties");
          exports.validateSchema.call(this, report, schema.additionalProperties);
          report.path.pop();
        }
      },
      properties: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1
        if (Utils.whatIs(schema.properties) !== "object") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["properties", "object"]);
          return;
        }

        var keys = Object.keys(schema.properties),
          idx = keys.length;
        while (idx--) {
          var key = keys[idx],
            val = schema.properties[key];
          report.path.push("properties");
          report.path.push(key);
          exports.validateSchema.call(this, report, val);
          report.path.pop();
          report.path.pop();
        }

        // custom - strict mode
        if (this.options.forceAdditional === true && schema.additionalProperties === undefined) {
          report.addError("KEYWORD_UNDEFINED_STRICT", ["additionalProperties"]);
        }
        // custome - assume defined false mode
        if (this.options.assumeAdditional === true && schema.additionalProperties === undefined) {
          schema.additionalProperties = false;
        }
        // custom - forceProperties
        if (this.options.forceProperties === true && keys.length === 0) {
          report.addError("CUSTOM_MODE_FORCE_PROPERTIES", ["properties"]);
        }
      },
      patternProperties: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1
        if (Utils.whatIs(schema.patternProperties) !== "object") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["patternProperties", "object"]);
          return;
        }

        var keys = Object.keys(schema.patternProperties),
          idx = keys.length;
        while (idx--) {
          var key = keys[idx],
            val = schema.patternProperties[key];
          try {
            RegExp(key);
          } catch (e) {
            report.addError("KEYWORD_PATTERN", ["patternProperties", key]);
          }
          report.path.push("patternProperties");
          report.path.push(key.toString());
          exports.validateSchema.call(this, report, val);
          report.path.pop();
          report.path.pop();
        }

        // custom - forceProperties
        if (this.options.forceProperties === true && keys.length === 0) {
          report.addError("CUSTOM_MODE_FORCE_PROPERTIES", ["patternProperties"]);
        }
      },
      dependencies: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.5.1
        if (Utils.whatIs(schema.dependencies) !== "object") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["dependencies", "object"]);
        } else {
          var keys = Object.keys(schema.dependencies),
            idx = keys.length;
          while (idx--) {
            var schemaKey = keys[idx],
              schemaDependency = schema.dependencies[schemaKey],
              type = Utils.whatIs(schemaDependency);

            if (type === "object") {
              report.path.push("dependencies");
              report.path.push(schemaKey);
              exports.validateSchema.call(this, report, schemaDependency);
              report.path.pop();
              report.path.pop();
            } else if (type === "array") {
              var idx2 = schemaDependency.length;
              if (idx2 === 0) {
                report.addError("KEYWORD_MUST_BE", ["dependencies", "not empty array"]);
              }
              while (idx2--) {
                if (typeof schemaDependency[idx2] !== "string") {
                  report.addError("KEYWORD_VALUE_TYPE", ["dependensices", "string"]);
                }
              }
              if (Utils.isUniqueArray(schemaDependency) === false) {
                report.addError("KEYWORD_MUST_BE", ["dependencies", "an array with unique items"]);
              }
            } else {
              report.addError("KEYWORD_VALUE_TYPE", ["dependencies", "object or array"]);
            }
          }
        }
      },
      enum: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.1.1
        if (Array.isArray(schema.enum) === false) {
          report.addError("KEYWORD_TYPE_EXPECTED", ["enum", "array"]);
        } else if (schema.enum.length === 0) {
          report.addError("KEYWORD_MUST_BE", ["enum", "an array with at least one element"]);
        } else if (Utils.isUniqueArray(schema.enum) === false) {
          report.addError("KEYWORD_MUST_BE", ["enum", "an array with unique elements"]);
        }
      },
      type: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.1
        var primitiveTypes = ["array", "boolean", "integer", "number", "null", "object", "string"],
          primitiveTypeStr = primitiveTypes.join(","),
          isArray = Array.isArray(schema.type);

        if (isArray) {
          var idx = schema.type.length;
          while (idx--) {
            if (primitiveTypes.indexOf(schema.type[idx]) === -1) {
              report.addError("KEYWORD_TYPE_EXPECTED", ["type", primitiveTypeStr]);
            }
          }
          if (Utils.isUniqueArray(schema.type) === false) {
            report.addError("KEYWORD_MUST_BE", ["type", "an object with unique properties"]);
          }
        } else if (typeof schema.type === "string") {
          if (primitiveTypes.indexOf(schema.type) === -1) {
            report.addError("KEYWORD_TYPE_EXPECTED", ["type", primitiveTypeStr]);
          }
        } else {
          report.addError("KEYWORD_TYPE_EXPECTED", ["type", ["string", "array"]]);
        }

        if (this.options.noEmptyStrings === true) {
          if (schema.type === "string" || isArray && schema.type.indexOf("string") !== -1) {
            if (schema.minLength === undefined &&
              schema.enum === undefined &&
              schema.format === undefined) {

              schema.minLength = 1;
            }
          }
        }
        if (this.options.noEmptyArrays === true) {
          if (schema.type === "array" || isArray && schema.type.indexOf("array") !== -1) {
            if (schema.minItems === undefined) {
              schema.minItems = 1;
            }
          }
        }
        if (this.options.forceProperties === true) {
          if (schema.type === "object" || isArray && schema.type.indexOf("object") !== -1) {
            if (schema.properties === undefined && schema.patternProperties === undefined) {
              report.addError("KEYWORD_UNDEFINED_STRICT", ["properties"]);
            }
          }
        }
        if (this.options.forceItems === true) {
          if (schema.type === "array" || isArray && schema.type.indexOf("array") !== -1) {
            if (schema.items === undefined) {
              report.addError("KEYWORD_UNDEFINED_STRICT", ["items"]);
            }
          }
        }
        if (this.options.forceMinItems === true) {
          if (schema.type === "array" || isArray && schema.type.indexOf("array") !== -1) {
            if (schema.minItems === undefined) {
              report.addError("KEYWORD_UNDEFINED_STRICT", ["minItems"]);
            }
          }
        }
        if (this.options.forceMaxItems === true) {
          if (schema.type === "array" || isArray && schema.type.indexOf("array") !== -1) {
            if (schema.maxItems === undefined) {
              report.addError("KEYWORD_UNDEFINED_STRICT", ["maxItems"]);
            }
          }
        }
        if (this.options.forceMinLength === true) {
          if (schema.type === "string" || isArray && schema.type.indexOf("string") !== -1) {
            if (schema.minLength === undefined &&
              schema.format === undefined &&
              schema.enum === undefined &&
              schema.pattern === undefined) {
              report.addError("KEYWORD_UNDEFINED_STRICT", ["minLength"]);
            }
          }
        }
        if (this.options.forceMaxLength === true) {
          if (schema.type === "string" || isArray && schema.type.indexOf("string") !== -1) {
            if (schema.maxLength === undefined &&
              schema.format === undefined &&
              schema.enum === undefined &&
              schema.pattern === undefined) {
              report.addError("KEYWORD_UNDEFINED_STRICT", ["maxLength"]);
            }
          }
        }
      },
      allOf: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.3.1
        if (Array.isArray(schema.allOf) === false) {
          report.addError("KEYWORD_TYPE_EXPECTED", ["allOf", "array"]);
        } else if (schema.allOf.length === 0) {
          report.addError("KEYWORD_MUST_BE", ["allOf", "an array with at least one element"]);
        } else {
          var idx = schema.allOf.length;
          while (idx--) {
            report.path.push("allOf");
            report.path.push(idx.toString());
            exports.validateSchema.call(this, report, schema.allOf[idx]);
            report.path.pop();
            report.path.pop();
          }
        }
      },
      anyOf: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.4.1
        if (Array.isArray(schema.anyOf) === false) {
          report.addError("KEYWORD_TYPE_EXPECTED", ["anyOf", "array"]);
        } else if (schema.anyOf.length === 0) {
          report.addError("KEYWORD_MUST_BE", ["anyOf", "an array with at least one element"]);
        } else {
          var idx = schema.anyOf.length;
          while (idx--) {
            report.path.push("anyOf");
            report.path.push(idx.toString());
            exports.validateSchema.call(this, report, schema.anyOf[idx]);
            report.path.pop();
            report.path.pop();
          }
        }
      },
      oneOf: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.5.1
        if (Array.isArray(schema.oneOf) === false) {
          report.addError("KEYWORD_TYPE_EXPECTED", ["oneOf", "array"]);
        } else if (schema.oneOf.length === 0) {
          report.addError("KEYWORD_MUST_BE", ["oneOf", "an array with at least one element"]);
        } else {
          var idx = schema.oneOf.length;
          while (idx--) {
            report.path.push("oneOf");
            report.path.push(idx.toString());
            exports.validateSchema.call(this, report, schema.oneOf[idx]);
            report.path.pop();
            report.path.pop();
          }
        }
      },
      not: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.6.1
        if (Utils.whatIs(schema.not) !== "object") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["not", "object"]);
        } else {
          report.path.push("not");
          exports.validateSchema.call(this, report, schema.not);
          report.path.pop();
        }
      },
      definitions: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.7.1
        if (Utils.whatIs(schema.definitions) !== "object") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["definitions", "object"]);
        } else {
          var keys = Object.keys(schema.definitions),
            idx = keys.length;
          while (idx--) {
            var key = keys[idx],
              val = schema.definitions[key];
            report.path.push("definitions");
            report.path.push(key);
            exports.validateSchema.call(this, report, val);
            report.path.pop();
            report.path.pop();
          }
        }
      },
      format: function (report, schema) {
        if (typeof schema.format !== "string") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["format", "string"]);
        } else {
          if (FormatValidators[schema.format] === undefined) {
            report.addError("UNKNOWN_FORMAT", [schema.format]);
          }
        }
      },
      id: function (report, schema) {
        // http://json-schema.org/latest/json-schema-core.html#rfc.section.7.2
        if (typeof schema.id !== "string") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["id", "string"]);
        }
      },
      title: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1
        if (typeof schema.title !== "string") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["title", "string"]);
        }
      },
      description: function (report, schema) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1
        if (typeof schema.description !== "string") {
          report.addError("KEYWORD_TYPE_EXPECTED", ["description", "string"]);
        }
      },
      "default": function (/* report, schema */) {
        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.2
        // There are no restrictions placed on the value of this keyword.
      }
    };

    var validateArrayOfSchemas = function (report, arr) {
      var idx = arr.length;
      while (idx--) {
        exports.validateSchema.call(this, report, arr[idx]);
      }
      return report.isValid();
    };

    exports.validateSchema = function (report, schema) {

      report.commonErrorMessage = "SCHEMA_VALIDATION_FAILED";

      // if schema is an array, assume it's an array of schemas
      if (Array.isArray(schema)) {
        return validateArrayOfSchemas.call(this, report, schema);
      }

      // do not revalidate schema that has already been validated once
      if (schema.__$validated) {
        return true;
      }

      // if $schema is present, this schema should validate against that $schema
      var hasParentSchema = schema.$schema && schema.id !== schema.$schema;
      if (hasParentSchema) {
        if (schema.__$schemaResolved && schema.__$schemaResolved !== schema) {
          var subReport = new Report(report);
          var valid = JsonValidation.validate.call(this, subReport, schema.__$schemaResolved, schema);
          if (valid === false) {
            report.addError("PARENT_SCHEMA_VALIDATION_FAILED", null, subReport);
          }
        } else {
          if (this.options.ignoreUnresolvableReferences !== true) {
            report.addError("REF_UNRESOLVED", [schema.$schema]);
          }
        }
      }

      if (this.options.noTypeless === true) {
        // issue #36 - inherit type to anyOf, oneOf, allOf if noTypeless is defined
        if (schema.type !== undefined) {
          var schemas = [];
          if (Array.isArray(schema.anyOf)) { schemas = schemas.concat(schema.anyOf); }
          if (Array.isArray(schema.oneOf)) { schemas = schemas.concat(schema.oneOf); }
          if (Array.isArray(schema.allOf)) { schemas = schemas.concat(schema.allOf); }
          schemas.forEach(function (sch) {
            if (!sch.type) { sch.type = schema.type; }
          });
        }
        // end issue #36
        if (schema.enum === undefined &&
          schema.type === undefined &&
          schema.anyOf === undefined &&
          schema.oneOf === undefined &&
          schema.not === undefined &&
          schema.$ref === undefined) {
          report.addError("KEYWORD_UNDEFINED_STRICT", ["type"]);
        }
      }

      var keys = Object.keys(schema),
        idx = keys.length;
      while (idx--) {
        var key = keys[idx];
        if (key.indexOf("__") === 0) { continue; }
        if (SchemaValidators[key] !== undefined) {
          SchemaValidators[key].call(this, report, schema);
        } else if (!hasParentSchema) {
          if (this.options.noExtraKeywords === true) {
            report.addError("KEYWORD_UNEXPECTED", [key]);
          }
        }
      }

      if (this.options.pedanticCheck === true) {
        if (schema.enum) {
          // break recursion
          var tmpSchema = Utils.clone(schema);
          delete tmpSchema.enum;
          delete tmpSchema.default;

          report.path.push("enum");
          idx = schema.enum.length;
          while (idx--) {
            report.path.push(idx.toString());
            JsonValidation.validate.call(this, report, tmpSchema, schema.enum[idx]);
            report.path.pop();
          }
          report.path.pop();
        }

        if (schema.default) {
          report.path.push("default");
          JsonValidation.validate.call(this, report, schema, schema.default);
          report.path.pop();
        }
      }

      var isValid = report.isValid();
      if (isValid) {
        schema.__$validated = true;
      }
      return isValid;
    };

  }, { "./FormatValidators": 80, "./JsonValidation": 81, "./Report": 83, "./Utils": 87 }], 87: [function (require, module, exports) {
    "use strict";

    exports.isAbsoluteUri = function (uri) {
      return /^https?:\/\//.test(uri);
    };

    exports.isRelativeUri = function (uri) {
      // relative URIs that end with a hash sign, issue #56
      return /.+#/.test(uri);
    };

    exports.whatIs = function (what) {

      var to = typeof what;

      if (to === "object") {
        if (what === null) {
          return "null";
        }
        if (Array.isArray(what)) {
          return "array";
        }
        return "object"; // typeof what === 'object' && what === Object(what) && !Array.isArray(what);
      }

      if (to === "number") {
        if (Number.isFinite(what)) {
          if (what % 1 === 0) {
            return "integer";
          } else {
            return "number";
          }
        }
        if (Number.isNaN(what)) {
          return "not-a-number";
        }
        return "unknown-number";
      }

      return to; // undefined, boolean, string, function

    };

    exports.areEqual = function areEqual(json1, json2) {
      // http://json-schema.org/latest/json-schema-core.html#rfc.section.3.6

      // Two JSON values are said to be equal if and only if:
      // both are nulls; or
      // both are booleans, and have the same value; or
      // both are strings, and have the same value; or
      // both are numbers, and have the same mathematical value; or
      if (json1 === json2) {
        return true;
      }

      var i, len;

      // both are arrays, and:
      if (Array.isArray(json1) && Array.isArray(json2)) {
        // have the same number of items; and
        if (json1.length !== json2.length) {
          return false;
        }
        // items at the same index are equal according to this definition; or
        len = json1.length;
        for (i = 0; i < len; i++) {
          if (!areEqual(json1[i], json2[i])) {
            return false;
          }
        }
        return true;
      }

      // both are objects, and:
      if (exports.whatIs(json1) === "object" && exports.whatIs(json2) === "object") {
        // have the same set of property names; and
        var keys1 = Object.keys(json1);
        var keys2 = Object.keys(json2);
        if (!areEqual(keys1, keys2)) {
          return false;
        }
        // values for a same property name are equal according to this definition.
        len = keys1.length;
        for (i = 0; i < len; i++) {
          if (!areEqual(json1[keys1[i]], json2[keys1[i]])) {
            return false;
          }
        }
        return true;
      }

      return false;
    };

    exports.isUniqueArray = function (arr, indexes) {
      var i, j, l = arr.length;
      for (i = 0; i < l; i++) {
        for (j = i + 1; j < l; j++) {
          if (exports.areEqual(arr[i], arr[j])) {
            if (indexes) { indexes.push(i, j); }
            return false;
          }
        }
      }
      return true;
    };

    exports.difference = function (bigSet, subSet) {
      var arr = [],
        idx = bigSet.length;
      while (idx--) {
        if (subSet.indexOf(bigSet[idx]) === -1) {
          arr.push(bigSet[idx]);
        }
      }
      return arr;
    };

    // NOT a deep version of clone
    exports.clone = function (src) {
      if (typeof src !== "object" || src === null) { return src; }
      var res, idx;
      if (Array.isArray(src)) {
        res = [];
        idx = src.length;
        while (idx--) {
          res[idx] = src[idx];
        }
      } else {
        res = {};
        var keys = Object.keys(src);
        idx = keys.length;
        while (idx--) {
          var key = keys[idx];
          res[key] = src[key];
        }
      }
      return res;
    };

    exports.cloneDeep = function (src) {
      var visited = [], cloned = [];
      function cloneDeep(src) {
        if (typeof src !== "object" || src === null) { return src; }
        var res, idx, cidx;

        cidx = visited.indexOf(src);
        if (cidx !== -1) { return cloned[cidx]; }

        visited.push(src);
        if (Array.isArray(src)) {
          res = [];
          cloned.push(res);
          idx = src.length;
          while (idx--) {
            res[idx] = cloneDeep(src[idx]);
          }
        } else {
          res = {};
          cloned.push(res);
          var keys = Object.keys(src);
          idx = keys.length;
          while (idx--) {
            var key = keys[idx];
            res[key] = cloneDeep(src[key]);
          }
        }
        return res;
      }
      return cloneDeep(src);
    };

    /*
      following function comes from punycode.js library
      see: https://github.com/bestiejs/punycode.js
    */
    /*jshint -W016*/
    /**
     * Creates an array containing the numeric code points of each Unicode
     * character in the string. While JavaScript uses UCS-2 internally,
     * this function will convert a pair of surrogate halves (each of which
     * UCS-2 exposes as separate characters) into a single code point,
     * matching UTF-16.
     * @see `punycode.ucs2.encode`
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode.ucs2
     * @name decode
     * @param {String} string The Unicode input string (UCS-2).
     * @returns {Array} The new array of code points.
     */
    exports.ucs2decode = function (string) {
      var output = [],
        counter = 0,
        length = string.length,
        value,
        extra;
      while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
          // high surrogate, and there is a next character
          extra = string.charCodeAt(counter++);
          if ((extra & 0xFC00) == 0xDC00) { // low surrogate
            output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
          } else {
            // unmatched surrogate; only append this code unit, in case the next
            // code unit is the high surrogate of a surrogate pair
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    };
    /*jshint +W016*/

  }, {}], 88: [function (require, module, exports) {
    (function (process) {
      "use strict";

      require("./Polyfills");
      var Report = require("./Report");
      var FormatValidators = require("./FormatValidators");
      var JsonValidation = require("./JsonValidation");
      var SchemaCache = require("./SchemaCache");
      var SchemaCompilation = require("./SchemaCompilation");
      var SchemaValidation = require("./SchemaValidation");
      var Utils = require("./Utils");
      var Draft4Schema = require("./schemas/schema.json");
      var Draft4HyperSchema = require("./schemas/hyper-schema.json");

      /*
          default options
      */
      var defaultOptions = {
        // default timeout for all async tasks
        asyncTimeout: 2000,
        // force additionalProperties and additionalItems to be defined on "object" and "array" types
        forceAdditional: false,
        // assume additionalProperties and additionalItems are defined as "false" where appropriate
        assumeAdditional: false,
        // force items to be defined on "array" types
        forceItems: false,
        // force minItems to be defined on "array" types
        forceMinItems: false,
        // force maxItems to be defined on "array" types
        forceMaxItems: false,
        // force minLength to be defined on "string" types
        forceMinLength: false,
        // force maxLength to be defined on "string" types
        forceMaxLength: false,
        // force properties or patternProperties to be defined on "object" types
        forceProperties: false,
        // ignore references that cannot be resolved (remote schemas) // TODO: make sure this is only for remote schemas, not local ones
        ignoreUnresolvableReferences: false,
        // disallow usage of keywords that this validator can't handle
        noExtraKeywords: false,
        // disallow usage of schema's without "type" defined
        noTypeless: false,
        // disallow zero length strings in validated objects
        noEmptyStrings: false,
        // disallow zero length arrays in validated objects
        noEmptyArrays: false,
        // forces "uri" format to be in fully rfc3986 compliant
        strictUris: false,
        // turn on some of the above
        strictMode: false,
        // report error paths as an array of path segments to get to the offending node
        reportPathAsArray: false,
        // stops validation as soon as an error is found, true by default but can be turned off
        breakOnFirstError: true,
        // check if schema follow best practices and common sence
        pedanticCheck: false
      };

      /*
          constructor
      */
      function ZSchema(options) {
        this.cache = {};
        this.referenceCache = [];

        this.setRemoteReference("http://json-schema.org/draft-04/schema", Draft4Schema);
        this.setRemoteReference("http://json-schema.org/draft-04/hyper-schema", Draft4HyperSchema);

        // options
        if (typeof options === "object") {
          var keys = Object.keys(options),
            idx = keys.length;
          while (idx--) {
            var key = keys[idx];
            if (defaultOptions[key] === undefined) {
              throw new Error("Unexpected option passed to constructor: " + key);
            }
          }
          this.options = options;
        } else {
          this.options = Utils.clone(defaultOptions);
        }

        if (this.options.strictMode === true) {
          this.options.forceAdditional = true;
          this.options.forceItems = true;
          this.options.forceMaxLength = true;
          this.options.forceProperties = true;
          this.options.noExtraKeywords = true;
          this.options.noTypeless = true;
          this.options.noEmptyStrings = true;
          this.options.noEmptyArrays = true;
        }

      }

      /*
          instance methods
      */
      ZSchema.prototype.compileSchema = function (schema) {
        var report = new Report(this.options);

        schema = SchemaCache.getSchema.call(this, report, schema);

        SchemaCompilation.compileSchema.call(this, report, schema);

        this.lastReport = report;
        return report.isValid();
      };
      ZSchema.prototype.validateSchema = function (schema) {
        if (Array.isArray(schema) && schema.length === 0) {
          throw new Error(".validateSchema was called with an empty array");
        }

        var report = new Report(this.options);

        schema = SchemaCache.getSchema.call(this, report, schema);

        var compiled = SchemaCompilation.compileSchema.call(this, report, schema);
        if (compiled) { SchemaValidation.validateSchema.call(this, report, schema); }

        this.lastReport = report;
        return report.isValid();
      };
      ZSchema.prototype.validate = function (json, schema, callback) {
        var whatIs = Utils.whatIs(schema);
        if (whatIs !== "string" && whatIs !== "object") {
          var e = new Error("Invalid .validate call - schema must be an string or object but " + whatIs + " was passed!");
          if (callback) {
            process.nextTick(function () {
              callback(e, false);
            });
            return;
          }
          throw e;
        }

        var foundError = false;
        var report = new Report(this.options);

        schema = SchemaCache.getSchema.call(this, report, schema);

        var compiled = false;
        if (!foundError) {
          compiled = SchemaCompilation.compileSchema.call(this, report, schema);
        }
        if (!compiled) {
          this.lastReport = report;
          foundError = true;
        }

        var validated = false;
        if (!foundError) {
          validated = SchemaValidation.validateSchema.call(this, report, schema);
        }
        if (!validated) {
          this.lastReport = report;
          foundError = true;
        }

        if (!foundError) {
          JsonValidation.validate.call(this, report, schema, json);
        }

        if (callback) {
          report.processAsyncTasks(this.options.asyncTimeout, callback);
          return;
        } else if (report.asyncTasks.length > 0) {
          throw new Error("This validation has async tasks and cannot be done in sync mode, please provide callback argument.");
        }

        // assign lastReport so errors are retrievable in sync mode
        this.lastReport = report;
        return report.isValid();
      };
      ZSchema.prototype.getLastError = function () {
        if (this.lastReport.errors.length === 0) {
          return null;
        }
        var e = new Error();
        e.name = "z-schema validation error";
        e.message = this.lastReport.commonErrorMessage;
        e.details = this.lastReport.errors;
        return e;
      };
      ZSchema.prototype.getLastErrors = function () {
        return this.lastReport.errors.length > 0 ? this.lastReport.errors : undefined;
      };
      ZSchema.prototype.getMissingReferences = function () {
        var res = [],
          idx = this.lastReport.errors.length;
        while (idx--) {
          var error = this.lastReport.errors[idx];
          if (error.code === "UNRESOLVABLE_REFERENCE") {
            var reference = error.params[0];
            if (res.indexOf(reference) === -1) {
              res.push(reference);
            }
          }
        }
        return res;
      };
      ZSchema.prototype.getMissingRemoteReferences = function () {
        var missingReferences = this.getMissingReferences(),
          missingRemoteReferences = [],
          idx = missingReferences.length;
        while (idx--) {
          var remoteReference = SchemaCache.getRemotePath(missingReferences[idx]);
          if (remoteReference && missingRemoteReferences.indexOf(remoteReference) === -1) {
            missingRemoteReferences.push(remoteReference);
          }
        }
        return missingRemoteReferences;
      };
      ZSchema.prototype.setRemoteReference = function (uri, schema) {
        if (typeof schema === "string") {
          schema = JSON.parse(schema);
        }
        SchemaCache.cacheSchemaByUri.call(this, uri, schema);
      };
      ZSchema.prototype.getResolvedSchema = function (schema) {
        var report = new Report(this.options);
        schema = SchemaCache.getSchema.call(this, report, schema);

        // clone before making any modifications
        schema = Utils.cloneDeep(schema);

        var visited = [];

        // clean-up the schema and resolve references
        var cleanup = function (schema) {
          var key,
            typeOf = Utils.whatIs(schema);
          if (typeOf !== "object" && typeOf !== "array") {
            return;
          }

          if (schema.___$visited) {
            return;
          }

          schema.___$visited = true;
          visited.push(schema);

          if (schema.$ref && schema.__$refResolved) {
            var from = schema.__$refResolved;
            var to = schema;
            delete schema.$ref;
            delete schema.__$refResolved;
            for (key in from) {
              if (from.hasOwnProperty(key)) {
                to[key] = from[key];
              }
            }
          }
          for (key in schema) {
            if (schema.hasOwnProperty(key)) {
              if (key.indexOf("__$") === 0) {
                delete schema[key];
              } else {
                cleanup(schema[key]);
              }
            }
          }
        };

        cleanup(schema);
        visited.forEach(function (s) {
          delete s.___$visited;
        });

        this.lastReport = report;
        if (report.isValid()) {
          return schema;
        } else {
          throw this.getLastError();
        }
      };
      ZSchema.prototype.setSchemaReader = function (schemaReader) {
        return ZSchema.setSchemaReader(schemaReader);
      };
      ZSchema.prototype.getSchemaReader = function () {
        return ZSchema.schemaReader;
      };

      /*
          static methods
      */
      ZSchema.setSchemaReader = function (schemaReader) {
        ZSchema.schemaReader = schemaReader;
      };
      ZSchema.registerFormat = function (formatName, validatorFunction) {
        FormatValidators[formatName] = validatorFunction;
      };
      ZSchema.getDefaultOptions = function () {
        return Utils.cloneDeep(defaultOptions);
      };

      module.exports = ZSchema;

    }).call(this, require('_process'))
  }, { "./FormatValidators": 80, "./JsonValidation": 81, "./Polyfills": 82, "./Report": 83, "./SchemaCache": 84, "./SchemaCompilation": 85, "./SchemaValidation": 86, "./Utils": 87, "./schemas/hyper-schema.json": 89, "./schemas/schema.json": 90, "_process": 92 }], 89: [function (require, module, exports) {
    module.exports = {
      "$schema": "http://json-schema.org/draft-04/hyper-schema#",
      "id": "http://json-schema.org/draft-04/hyper-schema#",
      "title": "JSON Hyper-Schema",
      "allOf": [
        {
          "$ref": "http://json-schema.org/draft-04/schema#"
        }
      ],
      "properties": {
        "additionalItems": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#"
            }
          ]
        },
        "additionalProperties": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#"
            }
          ]
        },
        "dependencies": {
          "additionalProperties": {
            "anyOf": [
              {
                "$ref": "#"
              },
              {
                "type": "array"
              }
            ]
          }
        },
        "items": {
          "anyOf": [
            {
              "$ref": "#"
            },
            {
              "$ref": "#/definitions/schemaArray"
            }
          ]
        },
        "definitions": {
          "additionalProperties": {
            "$ref": "#"
          }
        },
        "patternProperties": {
          "additionalProperties": {
            "$ref": "#"
          }
        },
        "properties": {
          "additionalProperties": {
            "$ref": "#"
          }
        },
        "allOf": {
          "$ref": "#/definitions/schemaArray"
        },
        "anyOf": {
          "$ref": "#/definitions/schemaArray"
        },
        "oneOf": {
          "$ref": "#/definitions/schemaArray"
        },
        "not": {
          "$ref": "#"
        },

        "links": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/linkDescription"
          }
        },
        "fragmentResolution": {
          "type": "string"
        },
        "media": {
          "type": "object",
          "properties": {
            "type": {
              "description": "A media type, as described in RFC 2046",
              "type": "string"
            },
            "binaryEncoding": {
              "description": "A content encoding scheme, as described in RFC 2045",
              "type": "string"
            }
          }
        },
        "pathStart": {
          "description": "Instances' URIs must start with this value for this schema to apply to them",
          "type": "string",
          "format": "uri"
        }
      },
      "definitions": {
        "schemaArray": {
          "type": "array",
          "items": {
            "$ref": "#"
          }
        },
        "linkDescription": {
          "title": "Link Description Object",
          "type": "object",
          "required": ["href", "rel"],
          "properties": {
            "href": {
              "description": "a URI template, as defined by RFC 6570, with the addition of the $, ( and ) characters for pre-processing",
              "type": "string"
            },
            "rel": {
              "description": "relation to the target resource of the link",
              "type": "string"
            },
            "title": {
              "description": "a title for the link",
              "type": "string"
            },
            "targetSchema": {
              "description": "JSON Schema describing the link target",
              "$ref": "#"
            },
            "mediaType": {
              "description": "media type (as defined by RFC 2046) describing the link target",
              "type": "string"
            },
            "method": {
              "description": "method for requesting the target of the link (e.g. for HTTP this might be \"GET\" or \"DELETE\")",
              "type": "string"
            },
            "encType": {
              "description": "The media type in which to submit data along with the request",
              "type": "string",
              "default": "application/json"
            },
            "schema": {
              "description": "Schema describing the data to submit along with the request",
              "$ref": "#"
            }
          }
        }
      }
    }


  }, {}], 90: [function (require, module, exports) {
    module.exports = {
      "id": "http://json-schema.org/draft-04/schema#",
      "$schema": "http://json-schema.org/draft-04/schema#",
      "description": "Core schema meta-schema",
      "definitions": {
        "schemaArray": {
          "type": "array",
          "minItems": 1,
          "items": { "$ref": "#" }
        },
        "positiveInteger": {
          "type": "integer",
          "minimum": 0
        },
        "positiveIntegerDefault0": {
          "allOf": [{ "$ref": "#/definitions/positiveInteger" }, { "default": 0 }]
        },
        "simpleTypes": {
          "enum": ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        "stringArray": {
          "type": "array",
          "items": { "type": "string" },
          "minItems": 1,
          "uniqueItems": true
        }
      },
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "format": "uri"
        },
        "$schema": {
          "type": "string",
          "format": "uri"
        },
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "default": {},
        "multipleOf": {
          "type": "number",
          "minimum": 0,
          "exclusiveMinimum": true
        },
        "maximum": {
          "type": "number"
        },
        "exclusiveMaximum": {
          "type": "boolean",
          "default": false
        },
        "minimum": {
          "type": "number"
        },
        "exclusiveMinimum": {
          "type": "boolean",
          "default": false
        },
        "maxLength": { "$ref": "#/definitions/positiveInteger" },
        "minLength": { "$ref": "#/definitions/positiveIntegerDefault0" },
        "pattern": {
          "type": "string",
          "format": "regex"
        },
        "additionalItems": {
          "anyOf": [
            { "type": "boolean" },
            { "$ref": "#" }
          ],
          "default": {}
        },
        "items": {
          "anyOf": [
            { "$ref": "#" },
            { "$ref": "#/definitions/schemaArray" }
          ],
          "default": {}
        },
        "maxItems": { "$ref": "#/definitions/positiveInteger" },
        "minItems": { "$ref": "#/definitions/positiveIntegerDefault0" },
        "uniqueItems": {
          "type": "boolean",
          "default": false
        },
        "maxProperties": { "$ref": "#/definitions/positiveInteger" },
        "minProperties": { "$ref": "#/definitions/positiveIntegerDefault0" },
        "required": { "$ref": "#/definitions/stringArray" },
        "additionalProperties": {
          "anyOf": [
            { "type": "boolean" },
            { "$ref": "#" }
          ],
          "default": {}
        },
        "definitions": {
          "type": "object",
          "additionalProperties": { "$ref": "#" },
          "default": {}
        },
        "properties": {
          "type": "object",
          "additionalProperties": { "$ref": "#" },
          "default": {}
        },
        "patternProperties": {
          "type": "object",
          "additionalProperties": { "$ref": "#" },
          "default": {}
        },
        "dependencies": {
          "type": "object",
          "additionalProperties": {
            "anyOf": [
              { "$ref": "#" },
              { "$ref": "#/definitions/stringArray" }
            ]
          }
        },
        "enum": {
          "type": "array",
          "minItems": 1,
          "uniqueItems": true
        },
        "type": {
          "anyOf": [
            { "$ref": "#/definitions/simpleTypes" },
            {
              "type": "array",
              "items": { "$ref": "#/definitions/simpleTypes" },
              "minItems": 1,
              "uniqueItems": true
            }
          ]
        },
        "allOf": { "$ref": "#/definitions/schemaArray" },
        "anyOf": { "$ref": "#/definitions/schemaArray" },
        "oneOf": { "$ref": "#/definitions/schemaArray" },
        "not": { "$ref": "#" }
      },
      "dependencies": {
        "exclusiveMaximum": ["maximum"],
        "exclusiveMinimum": ["minimum"]
      },
      "default": {}
    }

  }, {}], 91: [function (require, module, exports) {
    if (typeof Object.create === 'function') {
      // implementation from standard node.js 'util' module
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      // old school shim for old browsers
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor
        var TempCtor = function () { }
        TempCtor.prototype = superCtor.prototype
        ctor.prototype = new TempCtor()
        ctor.prototype.constructor = ctor
      }
    }

  }, {}], 92: [function (require, module, exports) {
    // shim for using process in browser

    var process = module.exports = {};
    var queue = [];
    var draining = false;

    function drainQueue() {
      if (draining) {
        return;
      }
      draining = true;
      var currentQueue;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
          currentQueue[i]();
        }
        len = queue.length;
      }
      draining = false;
    }
    process.nextTick = function (fun) {
      queue.push(fun);
      if (!draining) {
        setTimeout(drainQueue, 0);
      }
    };

    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() { }

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
      throw new Error('process.binding is not supported');
    };

    // TODO(shtylman)
    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
      throw new Error('process.chdir is not supported');
    };
    process.umask = function () { return 0; };

  }, {}], 93: [function (require, module, exports) {
    module.exports = function isBuffer(arg) {
      return arg && typeof arg === 'object'
        && typeof arg.copy === 'function'
        && typeof arg.fill === 'function'
        && typeof arg.readUInt8 === 'function';
    }
  }, {}], 94: [function (require, module, exports) {
    (function (process, global) {
      // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      var formatRegExp = /%[sdj%]/g;
      exports.format = function (f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(' ');
        }

        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function (x) {
          if (x === '%%') return '%';
          if (i >= len) return x;
          switch (x) {
            case '%s': return String(args[i++]);
            case '%d': return Number(args[i++]);
            case '%j':
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return '[Circular]';
              }
            default:
              return x;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject(x)) {
            str += ' ' + x;
          } else {
            str += ' ' + inspect(x);
          }
        }
        return str;
      };


      // Mark that a method should not be used.
      // Returns a modified function which warns once by default.
      // If --no-deprecation is set, then it is a no-op.
      exports.deprecate = function (fn, msg) {
        // Allow for deprecating things in the process of starting up.
        if (isUndefined(global.process)) {
          return function () {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
        }

        if (process.noDeprecation === true) {
          return fn;
        }

        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process.throwDeprecation) {
              throw new Error(msg);
            } else if (process.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }

        return deprecated;
      };


      var debugs = {};
      var debugEnviron;
      exports.debuglog = function (set) {
        if (isUndefined(debugEnviron))
          debugEnviron = process.env.NODE_DEBUG || '';
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
            var pid = process.pid;
            debugs[set] = function () {
              var msg = exports.format.apply(exports, arguments);
              console.error('%s %d: %s', set, pid, msg);
            };
          } else {
            debugs[set] = function () { };
          }
        }
        return debugs[set];
      };


      /**
       * Echos the value of a value. Trys to print the value out
       * in the best way possible given the different types.
       *
       * @param {Object} obj The object to print out.
       * @param {Object} opts Optional options object that alters the output.
       */
      /* legacy: obj, showHidden, depth, colors*/
      function inspect(obj, opts) {
        // default options
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        // legacy...
        if (arguments.length >= 3) ctx.depth = arguments[2];
        if (arguments.length >= 4) ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          // legacy...
          ctx.showHidden = opts;
        } else if (opts) {
          // got an "options" object
          exports._extend(ctx, opts);
        }
        // set default options
        if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
        if (isUndefined(ctx.depth)) ctx.depth = 2;
        if (isUndefined(ctx.colors)) ctx.colors = false;
        if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
        if (ctx.colors) ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;


      // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
      inspect.colors = {
        'bold': [1, 22],
        'italic': [3, 23],
        'underline': [4, 24],
        'inverse': [7, 27],
        'white': [37, 39],
        'grey': [90, 39],
        'black': [30, 39],
        'blue': [34, 39],
        'cyan': [36, 39],
        'green': [32, 39],
        'magenta': [35, 39],
        'red': [31, 39],
        'yellow': [33, 39]
      };

      // Don't use 'blue' not visible on cmd.exe
      inspect.styles = {
        'special': 'cyan',
        'number': 'yellow',
        'boolean': 'yellow',
        'undefined': 'grey',
        'null': 'bold',
        'string': 'green',
        'date': 'magenta',
        // "name": intentionally not styling
        'regexp': 'red'
      };


      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];

        if (style) {
          return '\u001b[' + inspect.colors[style][0] + 'm' + str +
            '\u001b[' + inspect.colors[style][1] + 'm';
        } else {
          return str;
        }
      }


      function stylizeNoColor(str, styleType) {
        return str;
      }


      function arrayToHash(array) {
        var hash = {};

        array.forEach(function (val, idx) {
          hash[val] = true;
        });

        return hash;
      }


      function formatValue(ctx, value, recurseTimes) {
        // Provide a hook for user-specified inspect functions.
        // Check that value is an object with an inspect function on it
        if (ctx.customInspect &&
          value &&
          isFunction(value.inspect) &&
          // Filter out the util module, it's inspect function is special
          value.inspect !== exports.inspect &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }

        // Primitive types cannot have properties
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }

        // Look up the keys of the object.
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);

        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }

        // IE doesn't make error fields non-enumerable
        // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
        if (isError(value)
          && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
          return formatError(value);
        }

        // Some type of object without properties can be shortcutted.
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ': ' + value.name : '';
            return ctx.stylize('[Function' + name + ']', 'special');
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), 'date');
          }
          if (isError(value)) {
            return formatError(value);
          }
        }

        var base = '', array = false, braces = ['{', '}'];

        // Make Array say that they are Array
        if (isArray(value)) {
          array = true;
          braces = ['[', ']'];
        }

        // Make functions say that they are functions
        if (isFunction(value)) {
          var n = value.name ? ': ' + value.name : '';
          base = ' [Function' + n + ']';
        }

        // Make RegExps say that they are RegExps
        if (isRegExp(value)) {
          base = ' ' + RegExp.prototype.toString.call(value);
        }

        // Make dates with properties first say the date
        if (isDate(value)) {
          base = ' ' + Date.prototype.toUTCString.call(value);
        }

        // Make error with message first say the error
        if (isError(value)) {
          base = ' ' + formatError(value);
        }

        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }

        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
          } else {
            return ctx.stylize('[Object]', 'special');
          }
        }

        ctx.seen.push(value);

        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function (key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }

        ctx.seen.pop();

        return reduceToSingleString(output, base, braces);
      }


      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize('undefined', 'undefined');
        if (isString(value)) {
          var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
            .replace(/'/g, "\\'")
            .replace(/\\"/g, '"') + '\'';
          return ctx.stylize(simple, 'string');
        }
        if (isNumber(value))
          return ctx.stylize('' + value, 'number');
        if (isBoolean(value))
          return ctx.stylize('' + value, 'boolean');
        // For some reason typeof null is "object", so special case here.
        if (isNull(value))
          return ctx.stylize('null', 'null');
      }


      function formatError(value) {
        return '[' + Error.prototype.toString.call(value) + ']';
      }


      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              String(i), true));
          } else {
            output.push('');
          }
        }
        keys.forEach(function (key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              key, true));
          }
        });
        return output;
      }


      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize('[Getter/Setter]', 'special');
          } else {
            str = ctx.stylize('[Getter]', 'special');
          }
        } else {
          if (desc.set) {
            str = ctx.stylize('[Setter]', 'special');
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = '[' + key + ']';
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf('\n') > -1) {
              if (array) {
                str = str.split('\n').map(function (line) {
                  return '  ' + line;
                }).join('\n').substr(2);
              } else {
                str = '\n' + str.split('\n').map(function (line) {
                  return '   ' + line;
                }).join('\n');
              }
            }
          } else {
            str = ctx.stylize('[Circular]', 'special');
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify('' + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, 'name');
          } else {
            name = name.replace(/'/g, "\\'")
              .replace(/\\"/g, '"')
              .replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, 'string');
          }
        }

        return name + ': ' + str;
      }


      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function (prev, cur) {
          numLinesEst++;
          if (cur.indexOf('\n') >= 0) numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
        }, 0);

        if (length > 60) {
          return braces[0] +
            (base === '' ? '' : base + '\n ') +
            ' ' +
            output.join(',\n  ') +
            ' ' +
            braces[1];
        }

        return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
      }


      // NOTE: These type checking functions intentionally don't use `instanceof`
      // because it is fragile and can be easily faked with `Object.create()`.
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray;

      function isBoolean(arg) {
        return typeof arg === 'boolean';
      }
      exports.isBoolean = isBoolean;

      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;

      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;

      function isNumber(arg) {
        return typeof arg === 'number';
      }
      exports.isNumber = isNumber;

      function isString(arg) {
        return typeof arg === 'string';
      }
      exports.isString = isString;

      function isSymbol(arg) {
        return typeof arg === 'symbol';
      }
      exports.isSymbol = isSymbol;

      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;

      function isRegExp(re) {
        return isObject(re) && objectToString(re) === '[object RegExp]';
      }
      exports.isRegExp = isRegExp;

      function isObject(arg) {
        return typeof arg === 'object' && arg !== null;
      }
      exports.isObject = isObject;

      function isDate(d) {
        return isObject(d) && objectToString(d) === '[object Date]';
      }
      exports.isDate = isDate;

      function isError(e) {
        return isObject(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
      }
      exports.isError = isError;

      function isFunction(arg) {
        return typeof arg === 'function';
      }
      exports.isFunction = isFunction;

      function isPrimitive(arg) {
        return arg === null ||
          typeof arg === 'boolean' ||
          typeof arg === 'number' ||
          typeof arg === 'string' ||
          typeof arg === 'symbol' ||  // ES6 symbol
          typeof arg === 'undefined';
      }
      exports.isPrimitive = isPrimitive;

      exports.isBuffer = require('./support/isBuffer');

      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }


      function pad(n) {
        return n < 10 ? '0' + n.toString(10) : n.toString(10);
      }


      var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
        'Oct', 'Nov', 'Dec'];

      // 26 Feb 16:19:34
      function timestamp() {
        var d = new Date();
        var time = [pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())].join(':');
        return [d.getDate(), months[d.getMonth()], time].join(' ');
      }


      // log is just a thin wrapper to console.log that prepends a timestamp
      exports.log = function () {
        console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
      };


      /**
       * Inherit the prototype methods from one constructor into another.
       *
       * The Function.prototype.inherits from lang.js rewritten as a standalone
       * function (not on Function.prototype). NOTE: If this file is to be loaded
       * during bootstrapping this function needs to be rewritten using some native
       * functions as prototype setup using normal JavaScript does not work as
       * expected during bootstrapping (see mirror.js in r114903).
       *
       * @param {function} ctor Constructor function which needs to inherit the
       *     prototype.
       * @param {function} superCtor Constructor function to inherit prototype from.
       */
      exports.inherits = require('inherits');

      exports._extend = function (origin, add) {
        // Don't do anything if add isn't an object
        if (!add || !isObject(add)) return origin;

        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      };

      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }

    }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, { "./support/isBuffer": 93, "_process": 92, "inherits": 91 }], 95: [function (require, module, exports) {
    (function (global) {
      /**
       * @license
       * lodash 3.10.1 (Custom Build) <https://lodash.com/>
       * Build: `lodash modern -d -o ./index.js`
       * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
       * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
       * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
       * Available under MIT license <https://lodash.com/license>
       */
      ; (function () {

        /** Used as a safe reference for `undefined` in pre-ES5 environments. */
        var undefined;

        /** Used as the semantic version number. */
        var VERSION = '3.10.1';

        /** Used to compose bitmasks for wrapper metadata. */
        var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          ARY_FLAG = 128,
          REARG_FLAG = 256;

        /** Used as default options for `_.trunc`. */
        var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';

        /** Used to detect when a function becomes hot. */
        var HOT_COUNT = 150,
          HOT_SPAN = 16;

        /** Used as the size to enable large array optimizations. */
        var LARGE_ARRAY_SIZE = 200;

        /** Used to indicate the type of lazy iteratees. */
        var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2;

        /** Used as the `TypeError` message for "Functions" methods. */
        var FUNC_ERROR_TEXT = 'Expected a function';

        /** Used as the internal argument placeholder. */
        var PLACEHOLDER = '__lodash_placeholder__';

        /** `Object#toString` result references. */
        var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';

        var arrayBufferTag = '[object ArrayBuffer]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';

        /** Used to match empty string literals in compiled template source. */
        var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

        /** Used to match HTML entities and HTML characters. */
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

        /** Used to match template delimiters. */
        var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;

        /** Used to match property names within property paths. */
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

        /**
         * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
         * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
         */
        var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
          reHasRegExpChars = RegExp(reRegExpChars.source);

        /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
        var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

        /** Used to match backslashes in property paths. */
        var reEscapeChar = /\\(\\)?/g;

        /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

        /** Used to match `RegExp` flags from their coerced string values. */
        var reFlags = /\w*$/;

        /** Used to detect hexadecimal string values. */
        var reHasHexPrefix = /^0[xX]/;

        /** Used to detect host constructors (Safari > 5). */
        var reIsHostCtor = /^\[object .+?Constructor\]$/;

        /** Used to detect unsigned integer values. */
        var reIsUint = /^\d+$/;

        /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
        var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

        /** Used to ensure capturing order of template delimiters. */
        var reNoMatch = /($^)/;

        /** Used to match unescaped characters in compiled string literals. */
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

        /** Used to match words to create compound words. */
        var reWords = (function () {
          var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
            lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

          return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
        }());

        /** Used to assign default `context` object properties. */
        var contextProps = [
          'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
          'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
          'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
          'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
          'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
        ];

        /** Used to make template sourceURLs easier to identify. */
        var templateCounter = -1;

        /** Used to identify `toStringTag` values of typed arrays. */
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
          typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
          typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
          typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
          typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
          typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
          typedArrayTags[dateTag] = typedArrayTags[errorTag] =
          typedArrayTags[funcTag] = typedArrayTags[mapTag] =
          typedArrayTags[numberTag] = typedArrayTags[objectTag] =
          typedArrayTags[regexpTag] = typedArrayTags[setTag] =
          typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

        /** Used to identify `toStringTag` values supported by `_.clone`. */
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] =
          cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
          cloneableTags[dateTag] = cloneableTags[float32Tag] =
          cloneableTags[float64Tag] = cloneableTags[int8Tag] =
          cloneableTags[int16Tag] = cloneableTags[int32Tag] =
          cloneableTags[numberTag] = cloneableTags[objectTag] =
          cloneableTags[regexpTag] = cloneableTags[stringTag] =
          cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
          cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] =
          cloneableTags[mapTag] = cloneableTags[setTag] =
          cloneableTags[weakMapTag] = false;

        /** Used to map latin-1 supplementary letters to basic latin letters. */
        var deburredLetters = {
          '\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
          '\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
          '\xc7': 'C', '\xe7': 'c',
          '\xd0': 'D', '\xf0': 'd',
          '\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
          '\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
          '\xcC': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
          '\xeC': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
          '\xd1': 'N', '\xf1': 'n',
          '\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
          '\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
          '\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
          '\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
          '\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
          '\xc6': 'Ae', '\xe6': 'ae',
          '\xde': 'Th', '\xfe': 'th',
          '\xdf': 'ss'
        };

        /** Used to map characters to HTML entities. */
        var htmlEscapes = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;',
          '`': '&#96;'
        };

        /** Used to map HTML entities to characters. */
        var htmlUnescapes = {
          '&amp;': '&',
          '&lt;': '<',
          '&gt;': '>',
          '&quot;': '"',
          '&#39;': "'",
          '&#96;': '`'
        };

        /** Used to determine if values are of the language type `Object`. */
        var objectTypes = {
          'function': true,
          'object': true
        };

        /** Used to escape characters for inclusion in compiled regexes. */
        var regexpEscapes = {
          '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
          '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
          'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
          'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
          'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
        };

        /** Used to escape characters for inclusion in compiled string literals. */
        var stringEscapes = {
          '\\': '\\',
          "'": "'",
          '\n': 'n',
          '\r': 'r',
          '\u2028': 'u2028',
          '\u2029': 'u2029'
        };

        /** Detect free variable `exports`. */
        var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

        /** Detect free variable `module`. */
        var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

        /** Detect free variable `global` from Node.js. */
        var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

        /** Detect free variable `self`. */
        var freeSelf = objectTypes[typeof self] && self && self.Object && self;

        /** Detect free variable `window`. */
        var freeWindow = objectTypes[typeof window] && window && window.Object && window;

        /** Detect the popular CommonJS extension `module.exports`. */
        var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

        /**
         * Used as a reference to the global object.
         *
         * The `this` value is used if it's the global object to avoid Greasemonkey's
         * restricted `window` object, otherwise the `window` object is used.
         */
        var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

        /*--------------------------------------------------------------------------*/

        /**
         * The base implementation of `compareAscending` which compares values and
         * sorts them in ascending order without guaranteeing a stable sort.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {number} Returns the sort order indicator for `value`.
         */
        function baseCompareAscending(value, other) {
          if (value !== other) {
            var valIsNull = value === null,
              valIsUndef = value === undefined,
              valIsReflexive = value === value;

            var othIsNull = other === null,
              othIsUndef = other === undefined,
              othIsReflexive = other === other;

            if ((value > other && !othIsNull) || !valIsReflexive ||
              (valIsNull && !othIsUndef && othIsReflexive) ||
              (valIsUndef && othIsReflexive)) {
              return 1;
            }
            if ((value < other && !valIsNull) || !othIsReflexive ||
              (othIsNull && !valIsUndef && valIsReflexive) ||
              (othIsUndef && valIsReflexive)) {
              return -1;
            }
          }
          return 0;
        }

        /**
         * The base implementation of `_.findIndex` and `_.findLastIndex` without
         * support for callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {Function} predicate The function invoked per iteration.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function baseFindIndex(array, predicate, fromRight) {
          var length = array.length,
            index = fromRight ? length : -1;

          while ((fromRight ? index-- : ++index < length)) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * The base implementation of `_.indexOf` without support for binary searches.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function baseIndexOf(array, value, fromIndex) {
          if (value !== value) {
            return indexOfNaN(array, fromIndex);
          }
          var index = fromIndex - 1,
            length = array.length;

          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }

        /**
         * The base implementation of `_.isFunction` without support for environments
         * with incorrect `typeof` results.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         */
        function baseIsFunction(value) {
          // Avoid a Chakra JIT bug in compatibility modes of IE 11.
          // See https://github.com/jashkenas/underscore/issues/1621 for more details.
          return typeof value == 'function' || false;
        }

        /**
         * Converts `value` to a string if it's not one. An empty string is returned
         * for `null` or `undefined` values.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString(value) {
          return value == null ? '' : (value + '');
        }

        /**
         * Used by `_.trim` and `_.trimLeft` to get the index of the first character
         * of `string` that is not found in `chars`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @param {string} chars The characters to find.
         * @returns {number} Returns the index of the first character not found in `chars`.
         */
        function charsLeftIndex(string, chars) {
          var index = -1,
            length = string.length;

          while (++index < length && chars.indexOf(string.charAt(index)) > -1) { }
          return index;
        }

        /**
         * Used by `_.trim` and `_.trimRight` to get the index of the last character
         * of `string` that is not found in `chars`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @param {string} chars The characters to find.
         * @returns {number} Returns the index of the last character not found in `chars`.
         */
        function charsRightIndex(string, chars) {
          var index = string.length;

          while (index-- && chars.indexOf(string.charAt(index)) > -1) { }
          return index;
        }

        /**
         * Used by `_.sortBy` to compare transformed elements of a collection and stable
         * sort them in ascending order.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @returns {number} Returns the sort order indicator for `object`.
         */
        function compareAscending(object, other) {
          return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
        }

        /**
         * Used by `_.sortByOrder` to compare multiple properties of a value to another
         * and stable sort them.
         *
         * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
         * a value is sorted in ascending order if its corresponding order is "asc", and
         * descending if "desc".
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {boolean[]} orders The order to sort by for each property.
         * @returns {number} Returns the sort order indicator for `object`.
         */
        function compareMultiple(object, other, orders) {
          var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;

          while (++index < length) {
            var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
            if (result) {
              if (index >= ordersLength) {
                return result;
              }
              var order = orders[index];
              return result * ((order === 'asc' || order === true) ? 1 : -1);
            }
          }
          // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
          // that causes it, under certain circumstances, to provide the same value for
          // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
          // for more details.
          //
          // This also ensures a stable sort in V8 and other engines.
          // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
          return object.index - other.index;
        }

        /**
         * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
         *
         * @private
         * @param {string} letter The matched letter to deburr.
         * @returns {string} Returns the deburred letter.
         */
        function deburrLetter(letter) {
          return deburredLetters[letter];
        }

        /**
         * Used by `_.escape` to convert characters to HTML entities.
         *
         * @private
         * @param {string} chr The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
        function escapeHtmlChar(chr) {
          return htmlEscapes[chr];
        }

        /**
         * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
         *
         * @private
         * @param {string} chr The matched character to escape.
         * @param {string} leadingChar The capture group for a leading character.
         * @param {string} whitespaceChar The capture group for a whitespace character.
         * @returns {string} Returns the escaped character.
         */
        function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
          if (leadingChar) {
            chr = regexpEscapes[chr];
          } else if (whitespaceChar) {
            chr = stringEscapes[chr];
          }
          return '\\' + chr;
        }

        /**
         * Used by `_.template` to escape characters for inclusion in compiled string literals.
         *
         * @private
         * @param {string} chr The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
        function escapeStringChar(chr) {
          return '\\' + stringEscapes[chr];
        }

        /**
         * Gets the index at which the first occurrence of `NaN` is found in `array`.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {number} fromIndex The index to search from.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {number} Returns the index of the matched `NaN`, else `-1`.
         */
        function indexOfNaN(array, fromIndex, fromRight) {
          var length = array.length,
            index = fromIndex + (fromRight ? 0 : -1);

          while ((fromRight ? index-- : ++index < length)) {
            var other = array[index];
            if (other !== other) {
              return index;
            }
          }
          return -1;
        }

        /**
         * Checks if `value` is object-like.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         */
        function isObjectLike(value) {
          return !!value && typeof value == 'object';
        }

        /**
         * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
         * character code is whitespace.
         *
         * @private
         * @param {number} charCode The character code to inspect.
         * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
         */
        function isSpace(charCode) {
          return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
            (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
        }

        /**
         * Replaces all `placeholder` elements in `array` with an internal placeholder
         * and returns an array of their indexes.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {*} placeholder The placeholder to replace.
         * @returns {Array} Returns the new array of placeholder indexes.
         */
        function replaceHolders(array, placeholder) {
          var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];

          while (++index < length) {
            if (array[index] === placeholder) {
              array[index] = PLACEHOLDER;
              result[++resIndex] = index;
            }
          }
          return result;
        }

        /**
         * An implementation of `_.uniq` optimized for sorted arrays without support
         * for callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The function invoked per iteration.
         * @returns {Array} Returns the new duplicate-value-free array.
         */
        function sortedUniq(array, iteratee) {
          var seen,
            index = -1,
            length = array.length,
            resIndex = -1,
            result = [];

          while (++index < length) {
            var value = array[index],
              computed = iteratee ? iteratee(value, index, array) : value;

            if (!index || seen !== computed) {
              seen = computed;
              result[++resIndex] = value;
            }
          }
          return result;
        }

        /**
         * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
         * character of `string`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {number} Returns the index of the first non-whitespace character.
         */
        function trimmedLeftIndex(string) {
          var index = -1,
            length = string.length;

          while (++index < length && isSpace(string.charCodeAt(index))) { }
          return index;
        }

        /**
         * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
         * character of `string`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {number} Returns the index of the last non-whitespace character.
         */
        function trimmedRightIndex(string) {
          var index = string.length;

          while (index-- && isSpace(string.charCodeAt(index))) { }
          return index;
        }

        /**
         * Used by `_.unescape` to convert HTML entities to characters.
         *
         * @private
         * @param {string} chr The matched character to unescape.
         * @returns {string} Returns the unescaped character.
         */
        function unescapeHtmlChar(chr) {
          return htmlUnescapes[chr];
        }

        /*--------------------------------------------------------------------------*/

        /**
         * Create a new pristine `lodash` function using the given `context` object.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Object} [context=root] The context object.
         * @returns {Function} Returns a new `lodash` function.
         * @example
         *
         * _.mixin({ 'foo': _.constant('foo') });
         *
         * var lodash = _.runInContext();
         * lodash.mixin({ 'bar': lodash.constant('bar') });
         *
         * _.isFunction(_.foo);
         * // => true
         * _.isFunction(_.bar);
         * // => false
         *
         * lodash.isFunction(lodash.foo);
         * // => false
         * lodash.isFunction(lodash.bar);
         * // => true
         *
         * // using `context` to mock `Date#getTime` use in `_.now`
         * var mock = _.runInContext({
         *   'Date': function() {
         *     return { 'getTime': getTimeMock };
         *   }
         * });
         *
         * // or creating a suped-up `defer` in Node.js
         * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
         */
        function runInContext(context) {
          // Avoid issues with some ES3 environments that attempt to use values, named
          // after built-in constructors like `Object`, for the creation of literals.
          // ES5 clears this up by stating that literals must use built-in constructors.
          // See https://es5.github.io/#x11.1.5 for more details.
          context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

          /** Native constructor references. */
          var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function.toBeInstanceOf(Function),
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;

          /** Used for native method references. */
          var arrayProto = Array.prototype,
            objectProto = Object.prototype,
            stringProto = String.prototype;

          /** Used to resolve the decompiled source of functions. */
          var fnToString = Function.prototype.toString;

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty;

          /** Used to generate unique IDs. */
          var idCounter = 0;

          /**
           * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
           * of values.
           */
          var objToString = objectProto.toString;

          /** Used to restore the original `_` reference in `_.noConflict`. */
          var oldDash = root._;

          /** Used to detect if a method is native. */
          var reIsNative = RegExp('^' +
            fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
              .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
          );

          /** Native method references. */
          var ArrayBuffer = context.ArrayBuffer,
            clearTimeout = context.clearTimeout,
            parseFloat = context.parseFloat,
            pow = Math.pow,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            Set = getNative(context, 'Set'),
            setTimeout = context.setTimeout,
            splice = arrayProto.splice,
            Uint8Array = context.Uint8Array,
            WeakMap = getNative(context, 'WeakMap');

          /* Native method references for those with the same name as other `lodash` methods. */
          var nativeCeil = Math.ceil,
            nativeCreate = getNative(Object, 'create'),
            nativeFloor = Math.floor,
            nativeIsArray = getNative(Array, 'isArray'),
            nativeIsFinite = context.isFinite,
            nativeKeys = getNative(Object, 'keys'),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = getNative(Date, 'now'),
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;

          /** Used as references for `-Infinity` and `Infinity`. */
          var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
            POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

          /** Used as references for the maximum length and index of an array. */
          var MAX_ARRAY_LENGTH = 4294967295,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

          /**
           * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
           * of an array-like value.
           */
          var MAX_SAFE_INTEGER = 9007199254740991;

          /** Used to store function metadata. */
          var metaMap = WeakMap && new WeakMap;

          /** Used to lookup unminified function names. */
          var realNames = {};

          /*------------------------------------------------------------------------*/

          /**
           * Creates a `lodash` object which wraps `value` to enable implicit chaining.
           * Methods that operate on and return arrays, collections, and functions can
           * be chained together. Methods that retrieve a single value or may return a
           * primitive value will automatically end the chain returning the unwrapped
           * value. Explicit chaining may be enabled using `_.chain`. The execution of
           * chained methods is lazy, that is, execution is deferred until `_#value`
           * is implicitly or explicitly called.
           *
           * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
           * fusion is an optimization strategy which merge iteratee calls; this can help
           * to avoid the creation of intermediate data structures and greatly reduce the
           * number of iteratee executions.
           *
           * Chaining is supported in custom builds as long as the `_#value` method is
           * directly or indirectly included in the build.
           *
           * In addition to lodash methods, wrappers have `Array` and `String` methods.
           *
           * The wrapper `Array` methods are:
           * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
           * `splice`, and `unshift`
           *
           * The wrapper `String` methods are:
           * `replace` and `split`
           *
           * The wrapper methods that support shortcut fusion are:
           * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
           * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
           * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
           * and `where`
           *
           * The chainable wrapper methods are:
           * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
           * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
           * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
           * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
           * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
           * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
           * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
           * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
           * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
           * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
           * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
           * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
           * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
           * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
           * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
           * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
           * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
           *
           * The wrapper methods that are **not** chainable by default are:
           * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
           * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
           * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
           * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
           * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
           * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
           * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
           * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
           * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
           * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
           * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
           * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
           * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
           * `unescape`, `uniqueId`, `value`, and `words`
           *
           * The wrapper method `sample` will return a wrapped value when `n` is provided,
           * otherwise an unwrapped value is returned.
           *
           * @name _
           * @constructor
           * @category Chain
           * @param {*} value The value to wrap in a `lodash` instance.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var wrapped = _([1, 2, 3]);
           *
           * // returns an unwrapped value
           * wrapped.reduce(function(total, n) {
           *   return total + n;
           * });
           * // => 6
           *
           * // returns a wrapped value
           * var squares = wrapped.map(function(n) {
           *   return n * n;
           * });
           *
           * _.isArray(squares);
           * // => false
           *
           * _.isArray(squares.value());
           * // => true
           */
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }

          /**
           * The function whose prototype all chaining wrappers inherit from.
           *
           * @private
           */
          function baseLodash() {
            // No operation performed.
          }

          /**
           * The base constructor for creating `lodash` wrapper objects.
           *
           * @private
           * @param {*} value The value to wrap.
           * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
           * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
           */
          function LodashWrapper(value, chainAll, actions) {
            this.__wrapped__ = value;
            this.__actions__ = actions || [];
            this.__chain__ = !!chainAll;
          }

          /**
           * An object environment feature flags.
           *
           * @static
           * @memberOf _
           * @type Object
           */
          var support = lodash.support = {};

          /**
           * By default, the template delimiters used by lodash are like those in
           * embedded Ruby (ERB). Change the following template settings to use
           * alternative delimiters.
           *
           * @static
           * @memberOf _
           * @type Object
           */
          lodash.templateSettings = {

            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type RegExp
             */
            'escape': reEscape,

            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type RegExp
             */
            'evaluate': reEvaluate,

            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type RegExp
             */
            'interpolate': reInterpolate,

            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type string
             */
            'variable': '',

            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type Object
             */
            'imports': {

              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type Function
               */
              '_': lodash
            }
          };

          /*------------------------------------------------------------------------*/

          /**
           * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
           *
           * @private
           * @param {*} value The value to wrap.
           */
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = POSITIVE_INFINITY;
            this.__views__ = [];
          }

          /**
           * Creates a clone of the lazy wrapper object.
           *
           * @private
           * @name clone
           * @memberOf LazyWrapper
           * @returns {Object} Returns the cloned `LazyWrapper` object.
           */
          function lazyClone() {
            var result = new LazyWrapper(this.__wrapped__);
            result.__actions__ = arrayCopy(this.__actions__);
            result.__dir__ = this.__dir__;
            result.__filtered__ = this.__filtered__;
            result.__iteratees__ = arrayCopy(this.__iteratees__);
            result.__takeCount__ = this.__takeCount__;
            result.__views__ = arrayCopy(this.__views__);
            return result;
          }

          /**
           * Reverses the direction of lazy iteration.
           *
           * @private
           * @name reverse
           * @memberOf LazyWrapper
           * @returns {Object} Returns the new reversed `LazyWrapper` object.
           */
          function lazyReverse() {
            if (this.__filtered__) {
              var result = new LazyWrapper(this);
              result.__dir__ = -1;
              result.__filtered__ = true;
            } else {
              result = this.clone();
              result.__dir__ *= -1;
            }
            return result;
          }

          /**
           * Extracts the unwrapped value from its lazy wrapper.
           *
           * @private
           * @name value
           * @memberOf LazyWrapper
           * @returns {*} Returns the unwrapped value.
           */
          function lazyValue() {
            var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);

            if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
              return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
            }
            var result = [];

            outer:
            while (length-- && resIndex < takeCount) {
              index += dir;

              var iterIndex = -1,
                value = array[index];

              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);

                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result[resIndex++] = value;
            }
            return result;
          }

          /*------------------------------------------------------------------------*/

          /**
           * Creates a cache object to store key/value pairs.
           *
           * @private
           * @static
           * @name Cache
           * @memberOf _.memoize
           */
          function MapCache() {
            this.__data__ = {};
          }

          /**
           * Removes `key` and its value from the cache.
           *
           * @private
           * @name delete
           * @memberOf _.memoize.Cache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
           */
          function mapDelete(key) {
            return this.has(key) && delete this.__data__[key];
          }

          /**
           * Gets the cached value for `key`.
           *
           * @private
           * @name get
           * @memberOf _.memoize.Cache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the cached value.
           */
          function mapGet(key) {
            return key == '__proto__' ? undefined : this.__data__[key];
          }

          /**
           * Checks if a cached value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf _.memoize.Cache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function mapHas(key) {
            return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
          }

          /**
           * Sets `value` to `key` of the cache.
           *
           * @private
           * @name set
           * @memberOf _.memoize.Cache
           * @param {string} key The key of the value to cache.
           * @param {*} value The value to cache.
           * @returns {Object} Returns the cache object.
           */
          function mapSet(key, value) {
            if (key != '__proto__') {
              this.__data__[key] = value;
            }
            return this;
          }

          /*------------------------------------------------------------------------*/

          /**
           *
           * Creates a cache object to store unique values.
           *
           * @private
           * @param {Array} [values] The values to cache.
           */
          function SetCache(values) {
            var length = values ? values.length : 0;

            this.data = { 'hash': nativeCreate(null), 'set': new Set };
            while (length--) {
              this.push(values[length]);
            }
          }

          /**
           * Checks if `value` is in `cache` mimicking the return signature of
           * `_.indexOf` by returning `0` if the value is found, else `-1`.
           *
           * @private
           * @param {Object} cache The cache to search.
           * @param {*} value The value to search for.
           * @returns {number} Returns `0` if `value` is found, else `-1`.
           */
          function cacheIndexOf(cache, value) {
            var data = cache.data,
              result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

            return result ? 0 : -1;
          }

          /**
           * Adds `value` to the cache.
           *
           * @private
           * @name push
           * @memberOf SetCache
           * @param {*} value The value to cache.
           */
          function cachePush(value) {
            var data = this.data;
            if (typeof value == 'string' || isObject(value)) {
              data.set.add(value);
            } else {
              data.hash[value] = true;
            }
          }

          /*------------------------------------------------------------------------*/

          /**
           * Creates a new array joining `array` with `other`.
           *
           * @private
           * @param {Array} array The array to join.
           * @param {Array} other The other array to join.
           * @returns {Array} Returns the new concatenated array.
           */
          function arrayConcat(array, other) {
            var index = -1,
              length = array.length,
              othIndex = -1,
              othLength = other.length,
              result = Array(length + othLength);

            while (++index < length) {
              result[index] = array[index];
            }
            while (++othIndex < othLength) {
              result[index++] = other[othIndex];
            }
            return result;
          }

          /**
           * Copies the values of `source` to `array`.
           *
           * @private
           * @param {Array} source The array to copy values from.
           * @param {Array} [array=[]] The array to copy values to.
           * @returns {Array} Returns `array`.
           */
          function arrayCopy(source, array) {
            var index = -1,
              length = source.length;

            array || (array = Array(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }

          /**
           * A specialized version of `_.forEach` for arrays without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns `array`.
           */
          function arrayEach(array, iteratee) {
            var index = -1,
              length = array.length;

            while (++index < length) {
              if (iteratee(array[index], index, array) === false) {
                break;
              }
            }
            return array;
          }

          /**
           * A specialized version of `_.forEachRight` for arrays without support for
           * callback shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns `array`.
           */
          function arrayEachRight(array, iteratee) {
            var length = array.length;

            while (length--) {
              if (iteratee(array[length], length, array) === false) {
                break;
              }
            }
            return array;
          }

          /**
           * A specialized version of `_.every` for arrays without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if all elements pass the predicate check,
           *  else `false`.
           */
          function arrayEvery(array, predicate) {
            var index = -1,
              length = array.length;

            while (++index < length) {
              if (!predicate(array[index], index, array)) {
                return false;
              }
            }
            return true;
          }

          /**
           * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
           * with one argument: (value).
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} comparator The function used to compare values.
           * @param {*} exValue The initial extremum value.
           * @returns {*} Returns the extremum value.
           */
          function arrayExtremum(array, iteratee, comparator, exValue) {
            var index = -1,
              length = array.length,
              computed = exValue,
              result = computed;

            while (++index < length) {
              var value = array[index],
                current = +iteratee(value);

              if (comparator(current, computed)) {
                computed = current;
                result = value;
              }
            }
            return result;
          }

          /**
           * A specialized version of `_.filter` for arrays without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           */
          function arrayFilter(array, predicate) {
            var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];

            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result[++resIndex] = value;
              }
            }
            return result;
          }

          /**
           * A specialized version of `_.map` for arrays without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns the new mapped array.
           */
          function arrayMap(array, iteratee) {
            var index = -1,
              length = array.length,
              result = Array(length);

            while (++index < length) {
              result[index] = iteratee(array[index], index, array);
            }
            return result;
          }

          /**
           * Appends the elements of `values` to `array`.
           *
           * @private
           * @param {Array} array The array to modify.
           * @param {Array} values The values to append.
           * @returns {Array} Returns `array`.
           */
          function arrayPush(array, values) {
            var index = -1,
              length = values.length,
              offset = array.length;

            while (++index < length) {
              array[offset + index] = values[index];
            }
            return array;
          }

          /**
           * A specialized version of `_.reduce` for arrays without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @param {boolean} [initFromArray] Specify using the first element of `array`
           *  as the initial value.
           * @returns {*} Returns the accumulated value.
           */
          function arrayReduce(array, iteratee, accumulator, initFromArray) {
            var index = -1,
              length = array.length;

            if (initFromArray && length) {
              accumulator = array[++index];
            }
            while (++index < length) {
              accumulator = iteratee(accumulator, array[index], index, array);
            }
            return accumulator;
          }

          /**
           * A specialized version of `_.reduceRight` for arrays without support for
           * callback shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @param {boolean} [initFromArray] Specify using the last element of `array`
           *  as the initial value.
           * @returns {*} Returns the accumulated value.
           */
          function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
            var length = array.length;
            if (initFromArray && length) {
              accumulator = array[--length];
            }
            while (length--) {
              accumulator = iteratee(accumulator, array[length], length, array);
            }
            return accumulator;
          }

          /**
           * A specialized version of `_.some` for arrays without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if any element passes the predicate check,
           *  else `false`.
           */
          function arraySome(array, predicate) {
            var index = -1,
              length = array.length;

            while (++index < length) {
              if (predicate(array[index], index, array)) {
                return true;
              }
            }
            return false;
          }

          /**
           * A specialized version of `_.sum` for arrays without support for callback
           * shorthands and `this` binding..
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {number} Returns the sum.
           */
          function arraySum(array, iteratee) {
            var length = array.length,
              result = 0;

            while (length--) {
              result += +iteratee(array[length]) || 0;
            }
            return result;
          }

          /**
           * Used by `_.defaults` to customize its `_.assign` use.
           *
           * @private
           * @param {*} objectValue The destination object property value.
           * @param {*} sourceValue The source object property value.
           * @returns {*} Returns the value to assign to the destination object.
           */
          function assignDefaults(objectValue, sourceValue) {
            return objectValue === undefined ? sourceValue : objectValue;
          }

          /**
           * Used by `_.template` to customize its `_.assign` use.
           *
           * **Note:** This function is like `assignDefaults` except that it ignores
           * inherited property values when checking if a property is `undefined`.
           *
           * @private
           * @param {*} objectValue The destination object property value.
           * @param {*} sourceValue The source object property value.
           * @param {string} key The key associated with the object and source values.
           * @param {Object} object The destination object.
           * @returns {*} Returns the value to assign to the destination object.
           */
          function assignOwnDefaults(objectValue, sourceValue, key, object) {
            return (objectValue === undefined || !hasOwnProperty.call(object, key))
              ? sourceValue
              : objectValue;
          }

          /**
           * A specialized version of `_.assign` for customizing assigned values without
           * support for argument juggling, multiple sources, and `this` binding `customizer`
           * functions.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {Function} customizer The function to customize assigned values.
           * @returns {Object} Returns `object`.
           */
          function assignWith(object, source, customizer) {
            var index = -1,
              props = keys(source),
              length = props.length;

            while (++index < length) {
              var key = props[index],
                value = object[key],
                result = customizer(value, source[key], key, object, source);

              if ((result === result ? (result !== value) : (value === value)) ||
                (value === undefined && !(key in object))) {
                object[key] = result;
              }
            }
            return object;
          }

          /**
           * The base implementation of `_.assign` without support for argument juggling,
           * multiple sources, and `customizer` functions.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @returns {Object} Returns `object`.
           */
          function baseAssign(object, source) {
            return source == null
              ? object
              : baseCopy(source, keys(source), object);
          }

          /**
           * The base implementation of `_.at` without support for string collections
           * and individual key arguments.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {number[]|string[]} props The property names or indexes of elements to pick.
           * @returns {Array} Returns the new array of picked elements.
           */
          function baseAt(collection, props) {
            var index = -1,
              isNil = collection == null,
              isArr = !isNil && isArrayLike(collection),
              length = isArr ? collection.length : 0,
              propsLength = props.length,
              result = Array(propsLength);

            while (++index < propsLength) {
              var key = props[index];
              if (isArr) {
                result[index] = isIndex(key, length) ? collection[key] : undefined;
              } else {
                result[index] = isNil ? undefined : collection[key];
              }
            }
            return result;
          }

          /**
           * Copies properties of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy properties from.
           * @param {Array} props The property names to copy.
           * @param {Object} [object={}] The object to copy properties to.
           * @returns {Object} Returns `object`.
           */
          function baseCopy(source, props, object) {
            object || (object = {});

            var index = -1,
              length = props.length;

            while (++index < length) {
              var key = props[index];
              object[key] = source[key];
            }
            return object;
          }

          /**
           * The base implementation of `_.callback` which supports specifying the
           * number of arguments to provide to `func`.
           *
           * @private
           * @param {*} [func=_.identity] The value to convert to a callback.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {number} [argCount] The number of arguments to provide to `func`.
           * @returns {Function} Returns the callback.
           */
          function baseCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (type == 'function') {
              return thisArg === undefined
                ? func
                : bindCallback(func, thisArg, argCount);
            }
            if (func == null) {
              return identity;
            }
            if (type == 'object') {
              return baseMatches(func);
            }
            return thisArg === undefined
              ? property(func)
              : baseMatchesProperty(func, thisArg);
          }

          /**
           * The base implementation of `_.clone` without support for argument juggling
           * and `this` binding `customizer` functions.
           *
           * @private
           * @param {*} value The value to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @param {Function} [customizer] The function to customize cloning values.
           * @param {string} [key] The key of `value`.
           * @param {Object} [object] The object `value` belongs to.
           * @param {Array} [stackA=[]] Tracks traversed source objects.
           * @param {Array} [stackB=[]] Associates clones with source counterparts.
           * @returns {*} Returns the cloned value.
           */
          function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
            var result;
            if (customizer) {
              result = object ? customizer(value, key, object) : customizer(value);
            }
            if (result !== undefined) {
              return result;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result = initCloneArray(value);
              if (!isDeep) {
                return arrayCopy(value, result);
              }
            } else {
              var tag = objToString.call(value),
                isFunc = tag == funcTag;

              if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
                result = initCloneObject(isFunc ? {} : value);
                if (!isDeep) {
                  return baseAssign(result, value);
                }
              } else {
                return cloneableTags[tag]
                  ? initCloneByTag(value, tag, isDeep)
                  : (object ? value : {});
              }
            }
            // Check for circular references and return its corresponding clone.
            stackA || (stackA = []);
            stackB || (stackB = []);

            var length = stackA.length;
            while (length--) {
              if (stackA[length] == value) {
                return stackB[length];
              }
            }
            // Add the source value to the stack of traversed objects and associate it with its clone.
            stackA.push(value);
            stackB.push(result);

            // Recursively populate clone (susceptible to call stack limits).
            (isArr ? arrayEach : baseForOwn)(value, function (subValue, key) {
              result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
            });
            return result;
          }

          /**
           * The base implementation of `_.create` without support for assigning
           * properties to the created object.
           *
           * @private
           * @param {Object} prototype The object to inherit from.
           * @returns {Object} Returns the new object.
           */
          var baseCreate = (function () {
            function object() { }
            return function (prototype) {
              if (isObject(prototype)) {
                object.prototype = prototype;
                var result = new object;
                object.prototype = undefined;
              }
              return result || {};
            };
          }());

          /**
           * The base implementation of `_.delay` and `_.defer` which accepts an index
           * of where to slice the arguments to provide to `func`.
           *
           * @private
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @param {Object} args The arguments provide to `func`.
           * @returns {number} Returns the timer id.
           */
          function baseDelay(func, wait, args) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            return setTimeout(function () { func.apply(undefined, args); }, wait);
          }

          /**
           * The base implementation of `_.difference` which accepts a single array
           * of values to exclude.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Array} values The values to exclude.
           * @returns {Array} Returns the new array of filtered values.
           */
          function baseDifference(array, values) {
            var length = array ? array.length : 0,
              result = [];

            if (!length) {
              return result;
            }
            var index = -1,
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
              valuesLength = values.length;

            if (cache) {
              indexOf = cacheIndexOf;
              isCommon = false;
              values = cache;
            }
            outer:
            while (++index < length) {
              var value = array[index];

              if (isCommon && value === value) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values[valuesIndex] === value) {
                    continue outer;
                  }
                }
                result.push(value);
              }
              else if (indexOf(values, value, 0) < 0) {
                result.push(value);
              }
            }
            return result;
          }

          /**
           * The base implementation of `_.forEach` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array|Object|string} Returns `collection`.
           */
          var baseEach = createBaseEach(baseForOwn);

          /**
           * The base implementation of `_.forEachRight` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array|Object|string} Returns `collection`.
           */
          var baseEachRight = createBaseEach(baseForOwnRight, true);

          /**
           * The base implementation of `_.every` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if all elements pass the predicate check,
           *  else `false`
           */
          function baseEvery(collection, predicate) {
            var result = true;
            baseEach(collection, function (value, index, collection) {
              result = !!predicate(value, index, collection);
              return result;
            });
            return result;
          }

          /**
           * Gets the extremum value of `collection` invoking `iteratee` for each value
           * in `collection` to generate the criterion by which the value is ranked.
           * The `iteratee` is invoked with three arguments: (value, index|key, collection).
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} comparator The function used to compare values.
           * @param {*} exValue The initial extremum value.
           * @returns {*} Returns the extremum value.
           */
          function baseExtremum(collection, iteratee, comparator, exValue) {
            var computed = exValue,
              result = computed;

            baseEach(collection, function (value, index, collection) {
              var current = +iteratee(value, index, collection);
              if (comparator(current, computed) || (current === exValue && current === result)) {
                computed = current;
                result = value;
              }
            });
            return result;
          }

          /**
           * The base implementation of `_.fill` without an iteratee call guard.
           *
           * @private
           * @param {Array} array The array to fill.
           * @param {*} value The value to fill `array` with.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns `array`.
           */
          function baseFill(array, value, start, end) {
            var length = array.length;

            start = start == null ? 0 : (+start || 0);
            if (start < 0) {
              start = -start > length ? 0 : (length + start);
            }
            end = (end === undefined || end > length) ? length : (+end || 0);
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : (end >>> 0);
            start >>>= 0;

            while (start < length) {
              array[start++] = value;
            }
            return array;
          }

          /**
           * The base implementation of `_.filter` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           */
          function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function (value, index, collection) {
              if (predicate(value, index, collection)) {
                result.push(value);
              }
            });
            return result;
          }

          /**
           * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
           * without support for callback shorthands and `this` binding, which iterates
           * over `collection` using the provided `eachFunc`.
           *
           * @private
           * @param {Array|Object|string} collection The collection to search.
           * @param {Function} predicate The function invoked per iteration.
           * @param {Function} eachFunc The function to iterate over `collection`.
           * @param {boolean} [retKey] Specify returning the key of the found element
           *  instead of the element itself.
           * @returns {*} Returns the found element or its key, else `undefined`.
           */
          function baseFind(collection, predicate, eachFunc, retKey) {
            var result;
            eachFunc(collection, function (value, key, collection) {
              if (predicate(value, key, collection)) {
                result = retKey ? key : value;
                return false;
              }
            });
            return result;
          }

          /**
           * The base implementation of `_.flatten` with added support for restricting
           * flattening and specifying the start index.
           *
           * @private
           * @param {Array} array The array to flatten.
           * @param {boolean} [isDeep] Specify a deep flatten.
           * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
           * @param {Array} [result=[]] The initial result value.
           * @returns {Array} Returns the new flattened array.
           */
          function baseFlatten(array, isDeep, isStrict, result) {
            result || (result = []);

            var index = -1,
              length = array.length;

            while (++index < length) {
              var value = array[index];
              if (isObjectLike(value) && isArrayLike(value) &&
                (isStrict || isArray(value) || isArguments(value))) {
                if (isDeep) {
                  // Recursively flatten arrays (susceptible to call stack limits).
                  baseFlatten(value, isDeep, isStrict, result);
                } else {
                  arrayPush(result, value);
                }
              } else if (!isStrict) {
                result[result.length] = value;
              }
            }
            return result;
          }

          /**
           * The base implementation of `baseForIn` and `baseForOwn` which iterates
           * over `object` properties returned by `keysFunc` invoking `iteratee` for
           * each property. Iteratee functions may exit iteration early by explicitly
           * returning `false`.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @returns {Object} Returns `object`.
           */
          var baseFor = createBaseFor();

          /**
           * This function is like `baseFor` except that it iterates over properties
           * in the opposite order.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @returns {Object} Returns `object`.
           */
          var baseForRight = createBaseFor(true);

          /**
           * The base implementation of `_.forIn` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Object} Returns `object`.
           */
          function baseForIn(object, iteratee) {
            return baseFor(object, iteratee, keysIn);
          }

          /**
           * The base implementation of `_.forOwn` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Object} Returns `object`.
           */
          function baseForOwn(object, iteratee) {
            return baseFor(object, iteratee, keys);
          }

          /**
           * The base implementation of `_.forOwnRight` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Object} Returns `object`.
           */
          function baseForOwnRight(object, iteratee) {
            return baseForRight(object, iteratee, keys);
          }

          /**
           * The base implementation of `_.functions` which creates an array of
           * `object` function property names filtered from those provided.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Array} props The property names to filter.
           * @returns {Array} Returns the new array of filtered property names.
           */
          function baseFunctions(object, props) {
            var index = -1,
              length = props.length,
              resIndex = -1,
              result = [];

            while (++index < length) {
              var key = props[index];
              if (isFunction(object[key])) {
                result[++resIndex] = key;
              }
            }
            return result;
          }

          /**
           * The base implementation of `get` without support for string paths
           * and default values.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array} path The path of the property to get.
           * @param {string} [pathKey] The key representation of path.
           * @returns {*} Returns the resolved value.
           */
          function baseGet(object, path, pathKey) {
            if (object == null) {
              return;
            }
            if (pathKey !== undefined && pathKey in toObject(object)) {
              path = [pathKey];
            }
            var index = 0,
              length = path.length;

            while (object != null && index < length) {
              object = object[path[index++]];
            }
            return (index && index == length) ? object : undefined;
          }

          /**
           * The base implementation of `_.isEqual` without support for `this` binding
           * `customizer` functions.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @param {Function} [customizer] The function to customize comparing values.
           * @param {boolean} [isLoose] Specify performing partial comparisons.
           * @param {Array} [stackA] Tracks traversed `value` objects.
           * @param {Array} [stackB] Tracks traversed `other` objects.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           */
          function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
          }

          /**
           * A specialized version of `baseIsEqual` for arrays and objects which performs
           * deep comparisons and tracks traversed objects enabling objects with circular
           * references to be compared.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Function} [customizer] The function to customize comparing objects.
           * @param {boolean} [isLoose] Specify performing partial comparisons.
           * @param {Array} [stackA=[]] Tracks traversed `value` objects.
           * @param {Array} [stackB=[]] Tracks traversed `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */
          function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;

            if (!objIsArr) {
              objTag = objToString.call(object);
              if (objTag == argsTag) {
                objTag = objectTag;
              } else if (objTag != objectTag) {
                objIsArr = isTypedArray(object);
              }
            }
            if (!othIsArr) {
              othTag = objToString.call(other);
              if (othTag == argsTag) {
                othTag = objectTag;
              } else if (othTag != objectTag) {
                othIsArr = isTypedArray(other);
              }
            }
            var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;

            if (isSameTag && !(objIsArr || objIsObj)) {
              return equalByTag(object, other, objTag);
            }
            if (!isLoose) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

              if (objIsWrapped || othIsWrapped) {
                return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
              }
            }
            if (!isSameTag) {
              return false;
            }
            // Assume cyclic values are equal.
            // For more information on detecting circular references see https://es5.github.io/#JO.
            stackA || (stackA = []);
            stackB || (stackB = []);

            var length = stackA.length;
            while (length--) {
              if (stackA[length] == object) {
                return stackB[length] == other;
              }
            }
            // Add `object` and `other` to the stack of traversed objects.
            stackA.push(object);
            stackB.push(other);

            var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

            stackA.pop();
            stackB.pop();

            return result;
          }

          /**
           * The base implementation of `_.isMatch` without support for callback
           * shorthands and `this` binding.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Array} matchData The propery names, values, and compare flags to match.
           * @param {Function} [customizer] The function to customize comparing objects.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           */
          function baseIsMatch(object, matchData, customizer) {
            var index = matchData.length,
              length = index,
              noCustomizer = !customizer;

            if (object == null) {
              return !length;
            }
            object = toObject(object);
            while (index--) {
              var data = matchData[index];
              if ((noCustomizer && data[2])
                ? data[1] !== object[data[0]]
                : !(data[0] in object)
              ) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0],
                objValue = object[key],
                srcValue = data[1];

              if (noCustomizer && data[2]) {
                if (objValue === undefined && !(key in object)) {
                  return false;
                }
              } else {
                var result = customizer ? customizer(objValue, srcValue, key) : undefined;
                if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                  return false;
                }
              }
            }
            return true;
          }

          /**
           * The base implementation of `_.map` without support for callback shorthands
           * and `this` binding.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns the new mapped array.
           */
          function baseMap(collection, iteratee) {
            var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];

            baseEach(collection, function (value, key, collection) {
              result[++index] = iteratee(value, key, collection);
            });
            return result;
          }

          /**
           * The base implementation of `_.matches` which does not clone `source`.
           *
           * @private
           * @param {Object} source The object of property values to match.
           * @returns {Function} Returns the new function.
           */
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              var key = matchData[0][0],
                value = matchData[0][1];

              return function (object) {
                if (object == null) {
                  return false;
                }
                return object[key] === value && (value !== undefined || (key in toObject(object)));
              };
            }
            return function (object) {
              return baseIsMatch(object, matchData);
            };
          }

          /**
           * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
           *
           * @private
           * @param {string} path The path of the property to get.
           * @param {*} srcValue The value to compare.
           * @returns {Function} Returns the new function.
           */
          function baseMatchesProperty(path, srcValue) {
            var isArr = isArray(path),
              isCommon = isKey(path) && isStrictComparable(srcValue),
              pathKey = (path + '');

            path = toPath(path);
            return function (object) {
              if (object == null) {
                return false;
              }
              var key = pathKey;
              object = toObject(object);
              if ((isArr || !isCommon) && !(key in object)) {
                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                if (object == null) {
                  return false;
                }
                key = last(path);
                object = toObject(object);
              }
              return object[key] === srcValue
                ? (srcValue !== undefined || (key in object))
                : baseIsEqual(srcValue, object[key], undefined, true);
            };
          }

          /**
           * The base implementation of `_.merge` without support for argument juggling,
           * multiple sources, and `this` binding `customizer` functions.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {Function} [customizer] The function to customize merged values.
           * @param {Array} [stackA=[]] Tracks traversed source objects.
           * @param {Array} [stackB=[]] Associates values with source counterparts.
           * @returns {Object} Returns `object`.
           */
          function baseMerge(object, source, customizer, stackA, stackB) {
            if (!isObject(object)) {
              return object;
            }
            var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
              props = isSrcArr ? undefined : keys(source);

            arrayEach(props || source, function (srcValue, key) {
              if (props) {
                key = srcValue;
                srcValue = source[key];
              }
              if (isObjectLike(srcValue)) {
                stackA || (stackA = []);
                stackB || (stackB = []);
                baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
              }
              else {
                var value = object[key],
                  result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                  isCommon = result === undefined;

                if (isCommon) {
                  result = srcValue;
                }
                if ((result !== undefined || (isSrcArr && !(key in object))) &&
                  (isCommon || (result === result ? (result !== value) : (value === value)))) {
                  object[key] = result;
                }
              }
            });
            return object;
          }

          /**
           * A specialized version of `baseMerge` for arrays and objects which performs
           * deep merges and tracks traversed objects enabling objects with circular
           * references to be merged.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {string} key The key of the value to merge.
           * @param {Function} mergeFunc The function to merge values.
           * @param {Function} [customizer] The function to customize merged values.
           * @param {Array} [stackA=[]] Tracks traversed source objects.
           * @param {Array} [stackB=[]] Associates values with source counterparts.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */
          function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
            var length = stackA.length,
              srcValue = source[key];

            while (length--) {
              if (stackA[length] == srcValue) {
                object[key] = stackB[length];
                return;
              }
            }
            var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;

            if (isCommon) {
              result = srcValue;
              if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
                result = isArray(value)
                  ? value
                  : (isArrayLike(value) ? arrayCopy(value) : []);
              }
              else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                result = isArguments(value)
                  ? toPlainObject(value)
                  : (isPlainObject(value) ? value : {});
              }
              else {
                isCommon = false;
              }
            }
            // Add the source value to the stack of traversed objects and associate
            // it with its merged value.
            stackA.push(srcValue);
            stackB.push(result);

            if (isCommon) {
              // Recursively merge objects and arrays (susceptible to call stack limits).
              object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
            } else if (result === result ? (result !== value) : (value === value)) {
              object[key] = result;
            }
          }

          /**
           * The base implementation of `_.property` without support for deep paths.
           *
           * @private
           * @param {string} key The key of the property to get.
           * @returns {Function} Returns the new function.
           */
          function baseProperty(key) {
            return function (object) {
              return object == null ? undefined : object[key];
            };
          }

          /**
           * A specialized version of `baseProperty` which supports deep paths.
           *
           * @private
           * @param {Array|string} path The path of the property to get.
           * @returns {Function} Returns the new function.
           */
          function basePropertyDeep(path) {
            var pathKey = (path + '');
            path = toPath(path);
            return function (object) {
              return baseGet(object, path, pathKey);
            };
          }

          /**
           * The base implementation of `_.pullAt` without support for individual
           * index arguments and capturing the removed elements.
           *
           * @private
           * @param {Array} array The array to modify.
           * @param {number[]} indexes The indexes of elements to remove.
           * @returns {Array} Returns `array`.
           */
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0;
            while (length--) {
              var index = indexes[length];
              if (index != previous && isIndex(index)) {
                var previous = index;
                splice.call(array, index, 1);
              }
            }
            return array;
          }

          /**
           * The base implementation of `_.random` without support for argument juggling
           * and returning floating-point numbers.
           *
           * @private
           * @param {number} min The minimum possible value.
           * @param {number} max The maximum possible value.
           * @returns {number} Returns the random number.
           */
          function baseRandom(min, max) {
            return min + nativeFloor(nativeRandom() * (max - min + 1));
          }

          /**
           * The base implementation of `_.reduce` and `_.reduceRight` without support
           * for callback shorthands and `this` binding, which iterates over `collection`
           * using the provided `eachFunc`.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {*} accumulator The initial value.
           * @param {boolean} initFromCollection Specify using the first or last element
           *  of `collection` as the initial value.
           * @param {Function} eachFunc The function to iterate over `collection`.
           * @returns {*} Returns the accumulated value.
           */
          function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
            eachFunc(collection, function (value, index, collection) {
              accumulator = initFromCollection
                ? (initFromCollection = false, value)
                : iteratee(accumulator, value, index, collection);
            });
            return accumulator;
          }

          /**
           * The base implementation of `setData` without support for hot loop detection.
           *
           * @private
           * @param {Function} func The function to associate metadata with.
           * @param {*} data The metadata.
           * @returns {Function} Returns `func`.
           */
          var baseSetData = !metaMap ? identity : function (func, data) {
            metaMap.set(func, data);
            return func;
          };

          /**
           * The base implementation of `_.slice` without an iteratee call guard.
           *
           * @private
           * @param {Array} array The array to slice.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the slice of `array`.
           */
          function baseSlice(array, start, end) {
            var index = -1,
              length = array.length;

            start = start == null ? 0 : (+start || 0);
            if (start < 0) {
              start = -start > length ? 0 : (length + start);
            }
            end = (end === undefined || end > length) ? length : (+end || 0);
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : ((end - start) >>> 0);
            start >>>= 0;

            var result = Array(length);
            while (++index < length) {
              result[index] = array[index + start];
            }
            return result;
          }

          /**
           * The base implementation of `_.some` without support for callback shorthands
           * and `this` binding.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if any element passes the predicate check,
           *  else `false`.
           */
          function baseSome(collection, predicate) {
            var result;

            baseEach(collection, function (value, index, collection) {
              result = predicate(value, index, collection);
              return !result;
            });
            return !!result;
          }

          /**
           * The base implementation of `_.sortBy` which uses `comparer` to define
           * the sort order of `array` and replaces criteria objects with their
           * corresponding values.
           *
           * @private
           * @param {Array} array The array to sort.
           * @param {Function} comparer The function to define sort order.
           * @returns {Array} Returns `array`.
           */
          function baseSortBy(array, comparer) {
            var length = array.length;

            array.sort(comparer);
            while (length--) {
              array[length] = array[length].value;
            }
            return array;
          }

          /**
           * The base implementation of `_.sortByOrder` without param guards.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
           * @param {boolean[]} orders The sort orders of `iteratees`.
           * @returns {Array} Returns the new sorted array.
           */
          function baseSortByOrder(collection, iteratees, orders) {
            var callback = getCallback(),
              index = -1;

            iteratees = arrayMap(iteratees, function (iteratee) { return callback(iteratee); });

            var result = baseMap(collection, function (value) {
              var criteria = arrayMap(iteratees, function (iteratee) { return iteratee(value); });
              return { 'criteria': criteria, 'index': ++index, 'value': value };
            });

            return baseSortBy(result, function (object, other) {
              return compareMultiple(object, other, orders);
            });
          }

          /**
           * The base implementation of `_.sum` without support for callback shorthands
           * and `this` binding.
           *
           * @private
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {number} Returns the sum.
           */
          function baseSum(collection, iteratee) {
            var result = 0;
            baseEach(collection, function (value, index, collection) {
              result += +iteratee(value, index, collection) || 0;
            });
            return result;
          }

          /**
           * The base implementation of `_.uniq` without support for callback shorthands
           * and `this` binding.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee] The function invoked per iteration.
           * @returns {Array} Returns the new duplicate-value-free array.
           */
          function baseUniq(array, iteratee) {
            var index = -1,
              indexOf = getIndexOf(),
              length = array.length,
              isCommon = indexOf == baseIndexOf,
              isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
              seen = isLarge ? createCache() : null,
              result = [];

            if (seen) {
              indexOf = cacheIndexOf;
              isCommon = false;
            } else {
              isLarge = false;
              seen = iteratee ? [] : result;
            }
            outer:
            while (++index < length) {
              var value = array[index],
                computed = iteratee ? iteratee(value, index, array) : value;

              if (isCommon && value === value) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee) {
                  seen.push(computed);
                }
                result.push(value);
              }
              else if (indexOf(seen, computed, 0) < 0) {
                if (iteratee || isLarge) {
                  seen.push(computed);
                }
                result.push(value);
              }
            }
            return result;
          }

          /**
           * The base implementation of `_.values` and `_.valuesIn` which creates an
           * array of `object` property values corresponding to the property names
           * of `props`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array} props The property names to get values for.
           * @returns {Object} Returns the array of property values.
           */
          function baseValues(object, props) {
            var index = -1,
              length = props.length,
              result = Array(length);

            while (++index < length) {
              result[index] = object[props[index]];
            }
            return result;
          }

          /**
           * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
           * and `_.takeWhile` without support for callback shorthands and `this` binding.
           *
           * @private
           * @param {Array} array The array to query.
           * @param {Function} predicate The function invoked per iteration.
           * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Array} Returns the slice of `array`.
           */
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length,
              index = fromRight ? length : -1;

            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) { }
            return isDrop
              ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
              : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
          }

          /**
           * The base implementation of `wrapperValue` which returns the result of
           * performing a sequence of actions on the unwrapped `value`, where each
           * successive action is supplied the return value of the previous.
           *
           * @private
           * @param {*} value The unwrapped value.
           * @param {Array} actions Actions to peform to resolve the unwrapped value.
           * @returns {*} Returns the resolved value.
           */
          function baseWrapperValue(value, actions) {
            var result = value;
            if (result instanceof LazyWrapper) {
              result = result.value();
            }
            var index = -1,
              length = actions.length;

            while (++index < length) {
              var action = actions[index];
              result = action.func.apply(action.thisArg, arrayPush([result], action.args));
            }
            return result;
          }

          /**
           * Performs a binary search of `array` to determine the index at which `value`
           * should be inserted into `array` in order to maintain its sort order.
           *
           * @private
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {boolean} [retHighest] Specify returning the highest qualified index.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           */
          function binaryIndex(array, value, retHighest) {
            var low = 0,
              high = array ? array.length : low;

            if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = (low + high) >>> 1,
                  computed = array[mid];

                if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return binaryIndexBy(array, value, identity, retHighest);
          }

          /**
           * This function is like `binaryIndex` except that it invokes `iteratee` for
           * `value` and each element of `array` to compute their sort ranking. The
           * iteratee is invoked with one argument; (value).
           *
           * @private
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {boolean} [retHighest] Specify returning the highest qualified index.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           */
          function binaryIndexBy(array, value, iteratee, retHighest) {
            value = iteratee(value);

            var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsNull = value === null,
              valIsUndef = value === undefined;

            while (low < high) {
              var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                isDef = computed !== undefined,
                isReflexive = computed === computed;

              if (valIsNaN) {
                var setLow = isReflexive || retHighest;
              } else if (valIsNull) {
                setLow = isReflexive && isDef && (retHighest || computed != null);
              } else if (valIsUndef) {
                setLow = isReflexive && (retHighest || isDef);
              } else if (computed == null) {
                setLow = false;
              } else {
                setLow = retHighest ? (computed <= value) : (computed < value);
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }

          /**
           * A specialized version of `baseCallback` which only supports `this` binding
           * and specifying the number of arguments to provide to `func`.
           *
           * @private
           * @param {Function} func The function to bind.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {number} [argCount] The number of arguments to provide to `func`.
           * @returns {Function} Returns the callback.
           */
          function bindCallback(func, thisArg, argCount) {
            if (typeof func != 'function') {
              return identity;
            }
            if (thisArg === undefined) {
              return func;
            }
            switch (argCount) {
              case 1: return function (value) {
                return func.call(thisArg, value);
              };
              case 3: return function (value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
              case 4: return function (accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
              case 5: return function (value, other, key, object, source) {
                return func.call(thisArg, value, other, key, object, source);
              };
            }
            return function () {
              return func.apply(thisArg, arguments);
            };
          }

          /**
           * Creates a clone of the given array buffer.
           *
           * @private
           * @param {ArrayBuffer} buffer The array buffer to clone.
           * @returns {ArrayBuffer} Returns the cloned array buffer.
           */
          function bufferClone(buffer) {
            var result = new ArrayBuffer(buffer.byteLength),
              view = new Uint8Array(result);

            view.set(new Uint8Array(buffer));
            return result;
          }

          /**
           * Creates an array that is the composition of partially applied arguments,
           * placeholders, and provided arguments into a single array of arguments.
           *
           * @private
           * @param {Array|Object} args The provided arguments.
           * @param {Array} partials The arguments to prepend to those provided.
           * @param {Array} holders The `partials` placeholder indexes.
           * @returns {Array} Returns the new array of composed arguments.
           */
          function composeArgs(args, partials, holders) {
            var holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              leftIndex = -1,
              leftLength = partials.length,
              result = Array(leftLength + argsLength);

            while (++leftIndex < leftLength) {
              result[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              result[holders[argsIndex]] = args[argsIndex];
            }
            while (argsLength--) {
              result[leftIndex++] = args[argsIndex++];
            }
            return result;
          }

          /**
           * This function is like `composeArgs` except that the arguments composition
           * is tailored for `_.partialRight`.
           *
           * @private
           * @param {Array|Object} args The provided arguments.
           * @param {Array} partials The arguments to append to those provided.
           * @param {Array} holders The `partials` placeholder indexes.
           * @returns {Array} Returns the new array of composed arguments.
           */
          function composeArgsRight(args, partials, holders) {
            var holdersIndex = -1,
              holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              rightIndex = -1,
              rightLength = partials.length,
              result = Array(argsLength + rightLength);

            while (++argsIndex < argsLength) {
              result[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              result[offset + holders[holdersIndex]] = args[argsIndex++];
            }
            return result;
          }

          /**
           * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
           *
           * @private
           * @param {Function} setter The function to set keys and values of the accumulator object.
           * @param {Function} [initializer] The function to initialize the accumulator object.
           * @returns {Function} Returns the new aggregator function.
           */
          function createAggregator(setter, initializer) {
            return function (collection, iteratee, thisArg) {
              var result = initializer ? initializer() : {};
              iteratee = getCallback(iteratee, thisArg, 3);

              if (isArray(collection)) {
                var index = -1,
                  length = collection.length;

                while (++index < length) {
                  var value = collection[index];
                  setter(result, value, iteratee(value, index, collection), collection);
                }
              } else {
                baseEach(collection, function (value, key, collection) {
                  setter(result, value, iteratee(value, key, collection), collection);
                });
              }
              return result;
            };
          }

          /**
           * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
           *
           * @private
           * @param {Function} assigner The function to assign values.
           * @returns {Function} Returns the new assigner function.
           */
          function createAssigner(assigner) {
            return restParam(function (object, sources) {
              var index = -1,
                length = object == null ? 0 : sources.length,
                customizer = length > 2 ? sources[length - 2] : undefined,
                guard = length > 2 ? sources[2] : undefined,
                thisArg = length > 1 ? sources[length - 1] : undefined;

              if (typeof customizer == 'function') {
                customizer = bindCallback(customizer, thisArg, 5);
                length -= 2;
              } else {
                customizer = typeof thisArg == 'function' ? thisArg : undefined;
                length -= (customizer ? 1 : 0);
              }
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined : customizer;
                length = 1;
              }
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, customizer);
                }
              }
              return object;
            });
          }

          /**
           * Creates a `baseEach` or `baseEachRight` function.
           *
           * @private
           * @param {Function} eachFunc The function to iterate over a collection.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new base function.
           */
          function createBaseEach(eachFunc, fromRight) {
            return function (collection, iteratee) {
              var length = collection ? getLength(collection) : 0;
              if (!isLength(length)) {
                return eachFunc(collection, iteratee);
              }
              var index = fromRight ? length : -1,
                iterable = toObject(collection);

              while ((fromRight ? index-- : ++index < length)) {
                if (iteratee(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }

          /**
           * Creates a base function for `_.forIn` or `_.forInRight`.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new base function.
           */
          function createBaseFor(fromRight) {
            return function (object, iteratee, keysFunc) {
              var iterable = toObject(object),
                props = keysFunc(object),
                length = props.length,
                index = fromRight ? length : -1;

              while ((fromRight ? index-- : ++index < length)) {
                var key = props[index];
                if (iteratee(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }

          /**
           * Creates a function that wraps `func` and invokes it with the `this`
           * binding of `thisArg`.
           *
           * @private
           * @param {Function} func The function to bind.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @returns {Function} Returns the new bound function.
           */
          function createBindWrapper(func, thisArg) {
            var Ctor = createCtorWrapper(func);

            function wrapper() {
              var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
              return fn.apply(thisArg, arguments);
            }
            return wrapper;
          }

          /**
           * Creates a `Set` cache object to optimize linear searches of large arrays.
           *
           * @private
           * @param {Array} [values] The values to cache.
           * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
           */
          function createCache(values) {
            return (nativeCreate && Set) ? new SetCache(values) : null;
          }

          /**
           * Creates a function that produces compound words out of the words in a
           * given string.
           *
           * @private
           * @param {Function} callback The function to combine each word.
           * @returns {Function} Returns the new compounder function.
           */
          function createCompounder(callback) {
            return function (string) {
              var index = -1,
                array = words(deburr(string)),
                length = array.length,
                result = '';

              while (++index < length) {
                result = callback(result, array[index], index);
              }
              return result;
            };
          }

          /**
           * Creates a function that produces an instance of `Ctor` regardless of
           * whether it was invoked as part of a `new` expression or by `call` or `apply`.
           *
           * @private
           * @param {Function} Ctor The constructor to wrap.
           * @returns {Function} Returns the new wrapped function.
           */
          function createCtorWrapper(Ctor) {
            return function () {
              // Use a `switch` statement to work with class constructors.
              // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
              // for more details.
              var args = arguments;
              switch (args.length) {
                case 0: return new Ctor;
                case 1: return new Ctor(args[0]);
                case 2: return new Ctor(args[0], args[1]);
                case 3: return new Ctor(args[0], args[1], args[2]);
                case 4: return new Ctor(args[0], args[1], args[2], args[3]);
                case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);

              // Mimic the constructor's `return` behavior.
              // See https://es5.github.io/#x13.2.2 for more details.
              return isObject(result) ? result : thisBinding;
            };
          }

          /**
           * Creates a `_.curry` or `_.curryRight` function.
           *
           * @private
           * @param {boolean} flag The curry bit flag.
           * @returns {Function} Returns the new curry function.
           */
          function createCurry(flag) {
            function curryFunc(func, arity, guard) {
              if (guard && isIterateeCall(func, arity, guard)) {
                arity = undefined;
              }
              var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
              result.placeholder = curryFunc.placeholder;
              return result;
            }
            return curryFunc;
          }

          /**
           * Creates a `_.defaults` or `_.defaultsDeep` function.
           *
           * @private
           * @param {Function} assigner The function to assign values.
           * @param {Function} customizer The function to customize assigned values.
           * @returns {Function} Returns the new defaults function.
           */
          function createDefaults(assigner, customizer) {
            return restParam(function (args) {
              var object = args[0];
              if (object == null) {
                return object;
              }
              args.push(customizer);
              return assigner.apply(undefined, args);
            });
          }

          /**
           * Creates a `_.max` or `_.min` function.
           *
           * @private
           * @param {Function} comparator The function used to compare values.
           * @param {*} exValue The initial extremum value.
           * @returns {Function} Returns the new extremum function.
           */
          function createExtremum(comparator, exValue) {
            return function (collection, iteratee, thisArg) {
              if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                iteratee = undefined;
              }
              iteratee = getCallback(iteratee, thisArg, 3);
              if (iteratee.length == 1) {
                collection = isArray(collection) ? collection : toIterable(collection);
                var result = arrayExtremum(collection, iteratee, comparator, exValue);
                if (!(collection.length && result === exValue)) {
                  return result;
                }
              }
              return baseExtremum(collection, iteratee, comparator, exValue);
            };
          }

          /**
           * Creates a `_.find` or `_.findLast` function.
           *
           * @private
           * @param {Function} eachFunc The function to iterate over a collection.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new find function.
           */
          function createFind(eachFunc, fromRight) {
            return function (collection, predicate, thisArg) {
              predicate = getCallback(predicate, thisArg, 3);
              if (isArray(collection)) {
                var index = baseFindIndex(collection, predicate, fromRight);
                return index > -1 ? collection[index] : undefined;
              }
              return baseFind(collection, predicate, eachFunc);
            };
          }

          /**
           * Creates a `_.findIndex` or `_.findLastIndex` function.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new find function.
           */
          function createFindIndex(fromRight) {
            return function (array, predicate, thisArg) {
              if (!(array && array.length)) {
                return -1;
              }
              predicate = getCallback(predicate, thisArg, 3);
              return baseFindIndex(array, predicate, fromRight);
            };
          }

          /**
           * Creates a `_.findKey` or `_.findLastKey` function.
           *
           * @private
           * @param {Function} objectFunc The function to iterate over an object.
           * @returns {Function} Returns the new find function.
           */
          function createFindKey(objectFunc) {
            return function (object, predicate, thisArg) {
              predicate = getCallback(predicate, thisArg, 3);
              return baseFind(object, predicate, objectFunc, true);
            };
          }

          /**
           * Creates a `_.flow` or `_.flowRight` function.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new flow function.
           */
          function createFlow(fromRight) {
            return function () {
              var wrapper,
                length = arguments.length,
                index = fromRight ? length : -1,
                leftIndex = 0,
                funcs = Array(length);

              while ((fromRight ? index-- : ++index < length)) {
                var func = funcs[leftIndex++] = arguments[index];
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
                  wrapper = new LodashWrapper([], true);
                }
              }
              index = wrapper ? -1 : length;
              while (++index < length) {
                func = funcs[index];

                var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined;

                if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function () {
                var args = arguments,
                  value = args[0];

                if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                  return wrapper.plant(value).value();
                }
                var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;

                while (++index < length) {
                  result = funcs[index].call(this, result);
                }
                return result;
              };
            };
          }

          /**
           * Creates a function for `_.forEach` or `_.forEachRight`.
           *
           * @private
           * @param {Function} arrayFunc The function to iterate over an array.
           * @param {Function} eachFunc The function to iterate over a collection.
           * @returns {Function} Returns the new each function.
           */
          function createForEach(arrayFunc, eachFunc) {
            return function (collection, iteratee, thisArg) {
              return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
                ? arrayFunc(collection, iteratee)
                : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
            };
          }

          /**
           * Creates a function for `_.forIn` or `_.forInRight`.
           *
           * @private
           * @param {Function} objectFunc The function to iterate over an object.
           * @returns {Function} Returns the new each function.
           */
          function createForIn(objectFunc) {
            return function (object, iteratee, thisArg) {
              if (typeof iteratee != 'function' || thisArg !== undefined) {
                iteratee = bindCallback(iteratee, thisArg, 3);
              }
              return objectFunc(object, iteratee, keysIn);
            };
          }

          /**
           * Creates a function for `_.forOwn` or `_.forOwnRight`.
           *
           * @private
           * @param {Function} objectFunc The function to iterate over an object.
           * @returns {Function} Returns the new each function.
           */
          function createForOwn(objectFunc) {
            return function (object, iteratee, thisArg) {
              if (typeof iteratee != 'function' || thisArg !== undefined) {
                iteratee = bindCallback(iteratee, thisArg, 3);
              }
              return objectFunc(object, iteratee);
            };
          }

          /**
           * Creates a function for `_.mapKeys` or `_.mapValues`.
           *
           * @private
           * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
           * @returns {Function} Returns the new map function.
           */
          function createObjectMapper(isMapKeys) {
            return function (object, iteratee, thisArg) {
              var result = {};
              iteratee = getCallback(iteratee, thisArg, 3);

              baseForOwn(object, function (value, key, object) {
                var mapped = iteratee(value, key, object);
                key = isMapKeys ? mapped : key;
                value = isMapKeys ? value : mapped;
                result[key] = value;
              });
              return result;
            };
          }

          /**
           * Creates a function for `_.padLeft` or `_.padRight`.
           *
           * @private
           * @param {boolean} [fromRight] Specify padding from the right.
           * @returns {Function} Returns the new pad function.
           */
          function createPadDir(fromRight) {
            return function (string, length, chars) {
              string = baseToString(string);
              return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
            };
          }

          /**
           * Creates a `_.partial` or `_.partialRight` function.
           *
           * @private
           * @param {boolean} flag The partial bit flag.
           * @returns {Function} Returns the new partial function.
           */
          function createPartial(flag) {
            var partialFunc = restParam(function (func, partials) {
              var holders = replaceHolders(partials, partialFunc.placeholder);
              return createWrapper(func, flag, undefined, partials, holders);
            });
            return partialFunc;
          }

          /**
           * Creates a function for `_.reduce` or `_.reduceRight`.
           *
           * @private
           * @param {Function} arrayFunc The function to iterate over an array.
           * @param {Function} eachFunc The function to iterate over a collection.
           * @returns {Function} Returns the new each function.
           */
          function createReduce(arrayFunc, eachFunc) {
            return function (collection, iteratee, accumulator, thisArg) {
              var initFromArray = arguments.length < 3;
              return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
                ? arrayFunc(collection, iteratee, accumulator, initFromArray)
                : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
            };
          }

          /**
           * Creates a function that wraps `func` and invokes it with optional `this`
           * binding of, partial application, and currying.
           *
           * @private
           * @param {Function|string} func The function or method name to reference.
           * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to prepend to those provided to the new function.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
           * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */
          function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurry = bitmask & CURRY_FLAG,
              isCurryBound = bitmask & CURRY_BOUND_FLAG,
              isCurryRight = bitmask & CURRY_RIGHT_FLAG,
              Ctor = isBindKey ? undefined : createCtorWrapper(func);

            function wrapper() {
              // Avoid `arguments` object use disqualifying optimizations by
              // converting it to an array before providing it to other functions.
              var length = arguments.length,
                index = length,
                args = Array(length);

              while (index--) {
                args[index] = arguments[index];
              }
              if (partials) {
                args = composeArgs(args, partials, holders);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight);
              }
              if (isCurry || isCurryRight) {
                var placeholder = wrapper.placeholder,
                  argsHolders = replaceHolders(args, placeholder);

                length -= argsHolders.length;
                if (length < arity) {
                  var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                    newArity = nativeMax(arity - length, 0),
                    newsHolders = isCurry ? argsHolders : undefined,
                    newHoldersRight = isCurry ? undefined : argsHolders,
                    newPartials = isCurry ? args : undefined,
                    newPartialsRight = isCurry ? undefined : args;

                  bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                  bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

                  if (!isCurryBound) {
                    bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                  }
                  var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                    result = createHybridWrapper.apply(undefined, newData);

                  if (isLaziable(func)) {
                    setData(result, newData);
                  }
                  result.placeholder = placeholder;
                  return result;
                }
              }
              var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;

              if (argPos) {
                args = reorder(args, argPos);
              }
              if (isAry && ary < args.length) {
                args.length = ary;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtorWrapper(func);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }

          /**
           * Creates the padding required for `string` based on the given `length`.
           * The `chars` string is truncated if the number of characters exceeds `length`.
           *
           * @private
           * @param {string} string The string to create padding for.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the pad for `string`.
           */
          function createPadding(string, length, chars) {
            var strLength = string.length;
            length = +length;

            if (strLength >= length || !nativeIsFinite(length)) {
              return '';
            }
            var padLength = length - strLength;
            chars = chars == null ? ' ' : (chars + '');
            return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
          }

          /**
           * Creates a function that wraps `func` and invokes it with the optional `this`
           * binding of `thisArg` and the `partials` prepended to those provided to
           * the wrapper.
           *
           * @private
           * @param {Function} func The function to partially apply arguments to.
           * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {Array} partials The arguments to prepend to those provided to the new function.
           * @returns {Function} Returns the new bound function.
           */
          function createPartialWrapper(func, bitmask, thisArg, partials) {
            var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);

            function wrapper() {
              // Avoid `arguments` object use disqualifying optimizations by
              // converting it to an array before providing it `func`.
              var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength);

              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, args);
            }
            return wrapper;
          }

          /**
           * Creates a `_.ceil`, `_.floor`, or `_.round` function.
           *
           * @private
           * @param {string} methodName The name of the `Math` method to use when rounding.
           * @returns {Function} Returns the new round function.
           */
          function createRound(methodName) {
            var func = Math[methodName];
            return function (number, precision) {
              precision = precision === undefined ? 0 : (+precision || 0);
              if (precision) {
                precision = pow(10, precision);
                return func(number * precision) / precision;
              }
              return func(number);
            };
          }

          /**
           * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
           *
           * @private
           * @param {boolean} [retHighest] Specify returning the highest qualified index.
           * @returns {Function} Returns the new index function.
           */
          function createSortedIndex(retHighest) {
            return function (array, value, iteratee, thisArg) {
              var callback = getCallback(iteratee);
              return (iteratee == null && callback === baseCallback)
                ? binaryIndex(array, value, retHighest)
                : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
            };
          }

          /**
           * Creates a function that either curries or invokes `func` with optional
           * `this` binding and partially applied arguments.
           *
           * @private
           * @param {Function|string} func The function or method name to reference.
           * @param {number} bitmask The bitmask of flags.
           *  The bitmask may be composed of the following flags:
           *     1 - `_.bind`
           *     2 - `_.bindKey`
           *     4 - `_.curry` or `_.curryRight` of a bound function
           *     8 - `_.curry`
           *    16 - `_.curryRight`
           *    32 - `_.partial`
           *    64 - `_.partialRight`
           *   128 - `_.rearg`
           *   256 - `_.ary`
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to be partially applied.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */
          function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & BIND_KEY_FLAG;
            if (!isBindKey && typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
              partials = holders = undefined;
            }
            length -= (holders ? holders.length : 0);
            if (bitmask & PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials,
                holdersRight = holders;

              partials = holders = undefined;
            }
            var data = isBindKey ? undefined : getData(func),
              newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

            if (data) {
              mergeData(newData, data);
              bitmask = newData[1];
              arity = newData[9];
            }
            newData[9] = arity == null
              ? (isBindKey ? 0 : func.length)
              : (nativeMax(arity - length, 0) || 0);

            if (bitmask == BIND_FLAG) {
              var result = createBindWrapper(newData[0], newData[2]);
            } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
              result = createPartialWrapper.apply(undefined, newData);
            } else {
              result = createHybridWrapper.apply(undefined, newData);
            }
            var setter = data ? baseSetData : setData;
            return setter(result, newData);
          }

          /**
           * A specialized version of `baseIsEqualDeep` for arrays with support for
           * partial deep comparisons.
           *
           * @private
           * @param {Array} array The array to compare.
           * @param {Array} other The other array to compare.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Function} [customizer] The function to customize comparing arrays.
           * @param {boolean} [isLoose] Specify performing partial comparisons.
           * @param {Array} [stackA] Tracks traversed `value` objects.
           * @param {Array} [stackB] Tracks traversed `other` objects.
           * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
           */
          function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var index = -1,
              arrLength = array.length,
              othLength = other.length;

            if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
              return false;
            }
            // Ignore non-index properties.
            while (++index < arrLength) {
              var arrValue = array[index],
                othValue = other[index],
                result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

              if (result !== undefined) {
                if (result) {
                  continue;
                }
                return false;
              }
              // Recursively compare arrays (susceptible to call stack limits).
              if (isLoose) {
                if (!arraySome(other, function (othValue) {
                  return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                })) {
                  return false;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
                return false;
              }
            }
            return true;
          }

          /**
           * A specialized version of `baseIsEqualDeep` for comparing objects of
           * the same `toStringTag`.
           *
           * **Note:** This function only supports comparing values with tags of
           * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {string} tag The `toStringTag` of the objects to compare.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */
          function equalByTag(object, other, tag) {
            switch (tag) {
              case boolTag:
              case dateTag:
                // Coerce dates and booleans to numbers, dates to milliseconds and booleans
                // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
                return +object == +other;

              case errorTag:
                return object.name == other.name && object.message == other.message;

              case numberTag:
                // Treat `NaN` vs. `NaN` as equal.
                return (object != +object)
                  ? other != +other
                  : object == +other;

              case regexpTag:
              case stringTag:
                // Coerce regexes to strings and treat strings primitives and string
                // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
                return object == (other + '');
            }
            return false;
          }

          /**
           * A specialized version of `baseIsEqualDeep` for objects with support for
           * partial deep comparisons.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Function} [customizer] The function to customize comparing values.
           * @param {boolean} [isLoose] Specify performing partial comparisons.
           * @param {Array} [stackA] Tracks traversed `value` objects.
           * @param {Array} [stackB] Tracks traversed `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */
          function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;

            if (objLength != othLength && !isLoose) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var skipCtor = isLoose;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key],
                othValue = other[key],
                result = customizer ? customizer(isLoose ? othValue : objValue, isLoose ? objValue : othValue, key) : undefined;

              // Recursively compare objects (susceptible to call stack limits).
              if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
                return false;
              }
              skipCtor || (skipCtor = key == 'constructor');
            }
            if (!skipCtor) {
              var objCtor = object.constructor,
                othCtor = other.constructor;

              // Non `Object` object instances with different constructors are not equal.
              if (objCtor != othCtor &&
                ('constructor' in object && 'constructor' in other) &&
                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                  typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                return false;
              }
            }
            return true;
          }

          /**
           * Gets the appropriate "callback" function. If the `_.callback` method is
           * customized this function returns the custom method, otherwise it returns
           * the `baseCallback` function. If arguments are provided the chosen function
           * is invoked with them and its result is returned.
           *
           * @private
           * @returns {Function} Returns the chosen function or its result.
           */
          function getCallback(func, thisArg, argCount) {
            var result = lodash.callback || callback;
            result = result === callback ? baseCallback : result;
            return argCount ? result(func, thisArg, argCount) : result;
          }

          /**
           * Gets metadata for `func`.
           *
           * @private
           * @param {Function} func The function to query.
           * @returns {*} Returns the metadata for `func`.
           */
          var getData = !metaMap ? noop : function (func) {
            return metaMap.get(func);
          };

          /**
           * Gets the name of `func`.
           *
           * @private
           * @param {Function} func The function to query.
           * @returns {string} Returns the function name.
           */
          function getFuncName(func) {
            var result = func.name,
              array = realNames[result],
              length = array ? array.length : 0;

            while (length--) {
              var data = array[length],
                otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result;
          }

          /**
           * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
           * customized this function returns the custom method, otherwise it returns
           * the `baseIndexOf` function. If arguments are provided the chosen function
           * is invoked with them and its result is returned.
           *
           * @private
           * @returns {Function|number} Returns the chosen function or its result.
           */
          function getIndexOf(collection, target, fromIndex) {
            var result = lodash.indexOf || indexOf;
            result = result === indexOf ? baseIndexOf : result;
            return collection ? result(collection, target, fromIndex) : result;
          }

          /**
           * Gets the "length" property value of `object`.
           *
           * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
           * that affects Safari on at least iOS 8.1-8.3 ARM64.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {*} Returns the "length" value.
           */
          var getLength = baseProperty('length');

          /**
           * Gets the propery names, values, and compare flags of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the match data of `object`.
           */
          function getMatchData(object) {
            var result = pairs(object),
              length = result.length;

            while (length--) {
              result[length][2] = isStrictComparable(result[length][1]);
            }
            return result;
          }

          /**
           * Gets the native function at `key` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the method to get.
           * @returns {*} Returns the function if it's native, else `undefined`.
           */
          function getNative(object, key) {
            var value = object == null ? undefined : object[key];
            return isNative(value) ? value : undefined;
          }

          /**
           * Gets the view, applying any `transforms` to the `start` and `end` positions.
           *
           * @private
           * @param {number} start The start of the view.
           * @param {number} end The end of the view.
           * @param {Array} transforms The transformations to apply to the view.
           * @returns {Object} Returns an object containing the `start` and `end`
           *  positions of the view.
           */
          function getView(start, end, transforms) {
            var index = -1,
              length = transforms.length;

            while (++index < length) {
              var data = transforms[index],
                size = data.size;

              switch (data.type) {
                case 'drop': start += size; break;
                case 'dropRight': end -= size; break;
                case 'take': end = nativeMin(end, start + size); break;
                case 'takeRight': start = nativeMax(start, end - size); break;
              }
            }
            return { 'start': start, 'end': end };
          }

          /**
           * Initializes an array clone.
           *
           * @private
           * @param {Array} array The array to clone.
           * @returns {Array} Returns the initialized clone.
           */
          function initCloneArray(array) {
            var length = array.length,
              result = new array.constructor(length);

            // Add array properties assigned by `RegExp#exec`.
            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
              result.index = array.index;
              result.input = array.input;
            }
            return result;
          }

          /**
           * Initializes an object clone.
           *
           * @private
           * @param {Object} object The object to clone.
           * @returns {Object} Returns the initialized clone.
           */
          function initCloneObject(object) {
            var Ctor = object.constructor;
            if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
              Ctor = Object;
            }
            return new Ctor;
          }

          /**
           * Initializes an object clone based on its `toStringTag`.
           *
           * **Note:** This function only supports cloning values with tags of
           * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
           *
           * @private
           * @param {Object} object The object to clone.
           * @param {string} tag The `toStringTag` of the object to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the initialized clone.
           */
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return bufferClone(object);

              case boolTag:
              case dateTag:
                return new Ctor(+object);

              case float32Tag: case float64Tag:
              case int8Tag: case int16Tag: case int32Tag:
              case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
                var buffer = object.buffer;
                return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

              case numberTag:
              case stringTag:
                return new Ctor(object);

              case regexpTag:
                var result = new Ctor(object.source, reFlags.exec(object));
                result.lastIndex = object.lastIndex;
            }
            return result;
          }

          /**
           * Invokes the method at `path` on `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the method to invoke.
           * @param {Array} args The arguments to invoke the method with.
           * @returns {*} Returns the result of the invoked method.
           */
          function invokePath(object, path, args) {
            if (object != null && !isKey(path, object)) {
              path = toPath(path);
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              path = last(path);
            }
            var func = object == null ? object : object[path];
            return func == null ? undefined : func.apply(object, args);
          }

          /**
           * Checks if `value` is array-like.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
           */
          function isArrayLike(value) {
            return value != null && isLength(getLength(value));
          }

          /**
           * Checks if `value` is a valid array-like index.
           *
           * @private
           * @param {*} value The value to check.
           * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
           * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
           */
          function isIndex(value, length) {
            value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return value > -1 && value % 1 == 0 && value < length;
          }

          /**
           * Checks if the provided arguments are from an iteratee call.
           *
           * @private
           * @param {*} value The potential iteratee value argument.
           * @param {*} index The potential iteratee index or key argument.
           * @param {*} object The potential iteratee object argument.
           * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
           */
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (type == 'number'
              ? (isArrayLike(object) && isIndex(index, object.length))
              : (type == 'string' && index in object)) {
              var other = object[index];
              return value === value ? (value === other) : (other !== other);
            }
            return false;
          }

          /**
           * Checks if `value` is a property name and not a property path.
           *
           * @private
           * @param {*} value The value to check.
           * @param {Object} [object] The object to query keys on.
           * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
           */
          function isKey(value, object) {
            var type = typeof value;
            if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
              return true;
            }
            if (isArray(value)) {
              return false;
            }
            var result = !reIsDeepProp.test(value);
            return result || (object != null && value in toObject(object));
          }

          /**
           * Checks if `func` has a lazy counterpart.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
           */
          function isLaziable(func) {
            var funcName = getFuncName(func);
            if (!(funcName in LazyWrapper.prototype)) {
              return false;
            }
            var other = lodash[funcName];
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }

          /**
           * Checks if `value` is a valid array-like length.
           *
           * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
           */
          function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }

          /**
           * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` if suitable for strict
           *  equality comparisons, else `false`.
           */
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }

          /**
           * Merges the function metadata of `source` into `data`.
           *
           * Merging metadata reduces the number of wrappers required to invoke a function.
           * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
           * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
           * augment function arguments, making the order in which they are executed important,
           * preventing the merging of metadata. However, we make an exception for a safe
           * common case where curried functions have `_.ary` and or `_.rearg` applied.
           *
           * @private
           * @param {Array} data The destination metadata.
           * @param {Array} source The source metadata.
           * @returns {Array} Returns `data`.
           */
          function mergeData(data, source) {
            var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < ARY_FLAG;

            var isCombo =
              (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
              (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
              (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

            // Exit early if metadata can't be merged.
            if (!(isCommon || isCombo)) {
              return data;
            }
            // Use source `thisArg` if available.
            if (srcBitmask & BIND_FLAG) {
              data[2] = source[2];
              // Set when currying a bound function.
              newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
            }
            // Compose partial arguments.
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
            }
            // Compose partial right arguments.
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
            }
            // Use source `argPos` if available.
            value = source[7];
            if (value) {
              data[7] = arrayCopy(value);
            }
            // Use source `ary` if it's smaller.
            if (srcBitmask & ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            // Use source `arity` if one is not provided.
            if (data[9] == null) {
              data[9] = source[9];
            }
            // Use source `func` and merge bitmasks.
            data[0] = source[0];
            data[1] = newBitmask;

            return data;
          }

          /**
           * Used by `_.defaultsDeep` to customize its `_.merge` use.
           *
           * @private
           * @param {*} objectValue The destination object property value.
           * @param {*} sourceValue The source object property value.
           * @returns {*} Returns the value to assign to the destination object.
           */
          function mergeDefaults(objectValue, sourceValue) {
            return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
          }

          /**
           * A specialized version of `_.pick` which picks `object` properties specified
           * by `props`.
           *
           * @private
           * @param {Object} object The source object.
           * @param {string[]} props The property names to pick.
           * @returns {Object} Returns the new object.
           */
          function pickByArray(object, props) {
            object = toObject(object);

            var index = -1,
              length = props.length,
              result = {};

            while (++index < length) {
              var key = props[index];
              if (key in object) {
                result[key] = object[key];
              }
            }
            return result;
          }

          /**
           * A specialized version of `_.pick` which picks `object` properties `predicate`
           * returns truthy for.
           *
           * @private
           * @param {Object} object The source object.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {Object} Returns the new object.
           */
          function pickByCallback(object, predicate) {
            var result = {};
            baseForIn(object, function (value, key, object) {
              if (predicate(value, key, object)) {
                result[key] = value;
              }
            });
            return result;
          }

          /**
           * Reorder `array` according to the specified indexes where the element at
           * the first index is assigned as the first element, the element at
           * the second index is assigned as the second element, and so on.
           *
           * @private
           * @param {Array} array The array to reorder.
           * @param {Array} indexes The arranged array indexes.
           * @returns {Array} Returns `array`.
           */
          function reorder(array, indexes) {
            var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = arrayCopy(array);

            while (length--) {
              var index = indexes[length];
              array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }
            return array;
          }

          /**
           * Sets metadata for `func`.
           *
           * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
           * period of time, it will trip its breaker and transition to an identity function
           * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
           * for more details.
           *
           * @private
           * @param {Function} func The function to associate metadata with.
           * @param {*} data The metadata.
           * @returns {Function} Returns `func`.
           */
          var setData = (function () {
            var count = 0,
              lastCalled = 0;

            return function (key, value) {
              var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);

              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return key;
                }
              } else {
                count = 0;
              }
              return baseSetData(key, value);
            };
          }());

          /**
           * A fallback implementation of `Object.keys` which creates an array of the
           * own enumerable property names of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function shimKeys(object) {
            var props = keysIn(object),
              propsLength = props.length,
              length = propsLength && object.length;

            var allowIndexes = !!length && isLength(length) &&
              (isArray(object) || isArguments(object));

            var index = -1,
              result = [];

            while (++index < propsLength) {
              var key = props[index];
              if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * Converts `value` to an array-like object if it's not one.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {Array|Object} Returns the array-like object.
           */
          function toIterable(value) {
            if (value == null) {
              return [];
            }
            if (!isArrayLike(value)) {
              return values(value);
            }
            return isObject(value) ? value : Object(value);
          }

          /**
           * Converts `value` to an object if it's not one.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {Object} Returns the object.
           */
          function toObject(value) {
            return isObject(value) ? value : Object(value);
          }

          /**
           * Converts `value` to property path array if it's not one.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {Array} Returns the property path array.
           */
          function toPath(value) {
            if (isArray(value)) {
              return value;
            }
            var result = [];
            baseToString(value).replace(rePropName, function (match, number, quote, string) {
              result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
            });
            return result;
          }

          /**
           * Creates a clone of `wrapper`.
           *
           * @private
           * @param {Object} wrapper The wrapper to clone.
           * @returns {Object} Returns the cloned wrapper.
           */
          function wrapperClone(wrapper) {
            return wrapper instanceof LazyWrapper
              ? wrapper.clone()
              : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
          }

          /*------------------------------------------------------------------------*/

          /**
           * Creates an array of elements split into groups the length of `size`.
           * If `collection` can't be split evenly, the final chunk will be the remaining
           * elements.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to process.
           * @param {number} [size=1] The length of each chunk.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Array} Returns the new array containing chunks.
           * @example
           *
           * _.chunk(['a', 'b', 'c', 'd'], 2);
           * // => [['a', 'b'], ['c', 'd']]
           *
           * _.chunk(['a', 'b', 'c', 'd'], 3);
           * // => [['a', 'b', 'c'], ['d']]
           */
          function chunk(array, size, guard) {
            if (guard ? isIterateeCall(array, size, guard) : size == null) {
              size = 1;
            } else {
              size = nativeMax(nativeFloor(size) || 1, 1);
            }
            var index = 0,
              length = array ? array.length : 0,
              resIndex = -1,
              result = Array(nativeCeil(length / size));

            while (index < length) {
              result[++resIndex] = baseSlice(array, index, (index += size));
            }
            return result;
          }

          /**
           * Creates an array with all falsey values removed. The values `false`, `null`,
           * `0`, `""`, `undefined`, and `NaN` are falsey.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to compact.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.compact([0, 1, false, 2, '', 3]);
           * // => [1, 2, 3]
           */
          function compact(array) {
            var index = -1,
              length = array ? array.length : 0,
              resIndex = -1,
              result = [];

            while (++index < length) {
              var value = array[index];
              if (value) {
                result[++resIndex] = value;
              }
            }
            return result;
          }

          /**
           * Creates an array of unique `array` values not included in the other
           * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...Array} [values] The arrays of values to exclude.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.difference([1, 2, 3], [4, 2]);
           * // => [1, 3]
           */
          var difference = restParam(function (array, values) {
            return (isObjectLike(array) && isArrayLike(array))
              ? baseDifference(array, baseFlatten(values, false, true))
              : [];
          });

          /**
           * Creates a slice of `array` with `n` elements dropped from the beginning.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to drop.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.drop([1, 2, 3]);
           * // => [2, 3]
           *
           * _.drop([1, 2, 3], 2);
           * // => [3]
           *
           * _.drop([1, 2, 3], 5);
           * // => []
           *
           * _.drop([1, 2, 3], 0);
           * // => [1, 2, 3]
           */
          function drop(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
              n = 1;
            }
            return baseSlice(array, n < 0 ? 0 : n);
          }

          /**
           * Creates a slice of `array` with `n` elements dropped from the end.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to drop.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.dropRight([1, 2, 3]);
           * // => [1, 2]
           *
           * _.dropRight([1, 2, 3], 2);
           * // => [1]
           *
           * _.dropRight([1, 2, 3], 5);
           * // => []
           *
           * _.dropRight([1, 2, 3], 0);
           * // => [1, 2, 3]
           */
          function dropRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
              n = 1;
            }
            n = length - (+n || 0);
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }

          /**
           * Creates a slice of `array` excluding elements dropped from the end.
           * Elements are dropped until `predicate` returns falsey. The predicate is
           * bound to `thisArg` and invoked with three arguments: (value, index, array).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that match the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.dropRightWhile([1, 2, 3], function(n) {
           *   return n > 1;
           * });
           * // => [1]
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
           * // => ['barney', 'fred']
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
           * // => ['barney']
           *
           * // using the `_.property` callback shorthand
           * _.pluck(_.dropRightWhile(users, 'active'), 'user');
           * // => ['barney', 'fred', 'pebbles']
           */
          function dropRightWhile(array, predicate, thisArg) {
            return (array && array.length)
              ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
              : [];
          }

          /**
           * Creates a slice of `array` excluding elements dropped from the beginning.
           * Elements are dropped until `predicate` returns falsey. The predicate is
           * bound to `thisArg` and invoked with three arguments: (value, index, array).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.dropWhile([1, 2, 3], function(n) {
           *   return n < 3;
           * });
           * // => [3]
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
           * // => ['fred', 'pebbles']
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.pluck(_.dropWhile(users, 'active', false), 'user');
           * // => ['pebbles']
           *
           * // using the `_.property` callback shorthand
           * _.pluck(_.dropWhile(users, 'active'), 'user');
           * // => ['barney', 'fred', 'pebbles']
           */
          function dropWhile(array, predicate, thisArg) {
            return (array && array.length)
              ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
              : [];
          }

          /**
           * Fills elements of `array` with `value` from `start` up to, but not
           * including, `end`.
           *
           * **Note:** This method mutates `array`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to fill.
           * @param {*} value The value to fill `array` with.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _.fill(array, 'a');
           * console.log(array);
           * // => ['a', 'a', 'a']
           *
           * _.fill(Array(3), 2);
           * // => [2, 2, 2]
           *
           * _.fill([4, 6, 8], '*', 1, 2);
           * // => [4, '*', 8]
           */
          function fill(array, value, start, end) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array, value, start, end);
          }

          /**
           * This method is like `_.find` except that it returns the index of the first
           * element `predicate` returns truthy for instead of the element itself.
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to search.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * _.findIndex(users, function(chr) {
           *   return chr.user == 'barney';
           * });
           * // => 0
           *
           * // using the `_.matches` callback shorthand
           * _.findIndex(users, { 'user': 'fred', 'active': false });
           * // => 1
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.findIndex(users, 'active', false);
           * // => 0
           *
           * // using the `_.property` callback shorthand
           * _.findIndex(users, 'active');
           * // => 2
           */
          var findIndex = createFindIndex();

          /**
           * This method is like `_.findIndex` except that it iterates over elements
           * of `collection` from right to left.
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to search.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * _.findLastIndex(users, function(chr) {
           *   return chr.user == 'pebbles';
           * });
           * // => 2
           *
           * // using the `_.matches` callback shorthand
           * _.findLastIndex(users, { 'user': 'barney', 'active': true });
           * // => 0
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.findLastIndex(users, 'active', false);
           * // => 2
           *
           * // using the `_.property` callback shorthand
           * _.findLastIndex(users, 'active');
           * // => 0
           */
          var findLastIndex = createFindIndex(true);

          /**
           * Gets the first element of `array`.
           *
           * @static
           * @memberOf _
           * @alias head
           * @category Array
           * @param {Array} array The array to query.
           * @returns {*} Returns the first element of `array`.
           * @example
           *
           * _.first([1, 2, 3]);
           * // => 1
           *
           * _.first([]);
           * // => undefined
           */
          function first(array) {
            return array ? array[0] : undefined;
          }

          /**
           * Flattens a nested array. If `isDeep` is `true` the array is recursively
           * flattened, otherwise it is only flattened a single level.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to flatten.
           * @param {boolean} [isDeep] Specify a deep flatten.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * _.flatten([1, [2, 3, [4]]]);
           * // => [1, 2, 3, [4]]
           *
           * // using `isDeep`
           * _.flatten([1, [2, 3, [4]]], true);
           * // => [1, 2, 3, 4]
           */
          function flatten(array, isDeep, guard) {
            var length = array ? array.length : 0;
            if (guard && isIterateeCall(array, isDeep, guard)) {
              isDeep = false;
            }
            return length ? baseFlatten(array, isDeep) : [];
          }

          /**
           * Recursively flattens a nested array.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to recursively flatten.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * _.flattenDeep([1, [2, 3, [4]]]);
           * // => [1, 2, 3, 4]
           */
          function flattenDeep(array) {
            var length = array ? array.length : 0;
            return length ? baseFlatten(array, true) : [];
          }

          /**
           * Gets the index at which the first occurrence of `value` is found in `array`
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
           * for equality comparisons. If `fromIndex` is negative, it is used as the offset
           * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
           * performs a faster binary search.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to search.
           * @param {*} value The value to search for.
           * @param {boolean|number} [fromIndex=0] The index to search from or `true`
           *  to perform a binary search on a sorted array.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.indexOf([1, 2, 1, 2], 2);
           * // => 1
           *
           * // using `fromIndex`
           * _.indexOf([1, 2, 1, 2], 2, 2);
           * // => 3
           *
           * // performing a binary search
           * _.indexOf([1, 1, 2, 2], 2, true);
           * // => 2
           */
          function indexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) {
              return -1;
            }
            if (typeof fromIndex == 'number') {
              fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
            } else if (fromIndex) {
              var index = binaryIndex(array, value);
              if (index < length &&
                (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
                return index;
              }
              return -1;
            }
            return baseIndexOf(array, value, fromIndex || 0);
          }

          /**
           * Gets all but the last element of `array`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.initial([1, 2, 3]);
           * // => [1, 2]
           */
          function initial(array) {
            return dropRight(array, 1);
          }

          /**
           * Creates an array of unique values that are included in all of the provided
           * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of shared values.
           * @example
           * _.intersection([1, 2], [4, 2], [2, 1]);
           * // => [2]
           */
          var intersection = restParam(function (arrays) {
            var othLength = arrays.length,
              othIndex = othLength,
              caches = Array(length),
              indexOf = getIndexOf(),
              isCommon = indexOf == baseIndexOf,
              result = [];

            while (othIndex--) {
              var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
              caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
            }
            var array = arrays[0],
              index = -1,
              length = array ? array.length : 0,
              seen = caches[0];

            outer:
            while (++index < length) {
              value = array[index];
              if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
                var othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(value);
                }
                result.push(value);
              }
            }
            return result;
          });

          /**
           * Gets the last element of `array`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @returns {*} Returns the last element of `array`.
           * @example
           *
           * _.last([1, 2, 3]);
           * // => 3
           */
          function last(array) {
            var length = array ? array.length : 0;
            return length ? array[length - 1] : undefined;
          }

          /**
           * This method is like `_.indexOf` except that it iterates over elements of
           * `array` from right to left.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to search.
           * @param {*} value The value to search for.
           * @param {boolean|number} [fromIndex=array.length-1] The index to search from
           *  or `true` to perform a binary search on a sorted array.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.lastIndexOf([1, 2, 1, 2], 2);
           * // => 3
           *
           * // using `fromIndex`
           * _.lastIndexOf([1, 2, 1, 2], 2, 2);
           * // => 1
           *
           * // performing a binary search
           * _.lastIndexOf([1, 1, 2, 2], 2, true);
           * // => 3
           */
          function lastIndexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) {
              return -1;
            }
            var index = length;
            if (typeof fromIndex == 'number') {
              index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
            } else if (fromIndex) {
              index = binaryIndex(array, value, true) - 1;
              var other = array[index];
              if (value === value ? (value === other) : (other !== other)) {
                return index;
              }
              return -1;
            }
            if (value !== value) {
              return indexOfNaN(array, index, true);
            }
            while (index--) {
              if (array[index] === value) {
                return index;
              }
            }
            return -1;
          }

          /**
           * Removes all provided values from `array` using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * **Note:** Unlike `_.without`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to modify.
           * @param {...*} [values] The values to remove.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [1, 2, 3, 1, 2, 3];
           *
           * _.pull(array, 2, 3);
           * console.log(array);
           * // => [1, 1]
           */
          function pull() {
            var args = arguments,
              array = args[0];

            if (!(array && array.length)) {
              return array;
            }
            var index = 0,
              indexOf = getIndexOf(),
              length = args.length;

            while (++index < length) {
              var fromIndex = 0,
                value = args[index];

              while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }

          /**
           * Removes elements from `array` corresponding to the given indexes and returns
           * an array of the removed elements. Indexes may be specified as an array of
           * indexes or as individual arguments.
           *
           * **Note:** Unlike `_.at`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to modify.
           * @param {...(number|number[])} [indexes] The indexes of elements to remove,
           *  specified as individual indexes or arrays of indexes.
           * @returns {Array} Returns the new array of removed elements.
           * @example
           *
           * var array = [5, 10, 15, 20];
           * var evens = _.pullAt(array, 1, 3);
           *
           * console.log(array);
           * // => [5, 15]
           *
           * console.log(evens);
           * // => [10, 20]
           */
          var pullAt = restParam(function (array, indexes) {
            indexes = baseFlatten(indexes);

            var result = baseAt(array, indexes);
            basePullAt(array, indexes.sort(baseCompareAscending));
            return result;
          });

          /**
           * Removes all elements from `array` that `predicate` returns truthy for
           * and returns an array of the removed elements. The predicate is bound to
           * `thisArg` and invoked with three arguments: (value, index, array).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * **Note:** Unlike `_.filter`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the new array of removed elements.
           * @example
           *
           * var array = [1, 2, 3, 4];
           * var evens = _.remove(array, function(n) {
           *   return n % 2 == 0;
           * });
           *
           * console.log(array);
           * // => [1, 3]
           *
           * console.log(evens);
           * // => [2, 4]
           */
          function remove(array, predicate, thisArg) {
            var result = [];
            if (!(array && array.length)) {
              return result;
            }
            var index = -1,
              indexes = [],
              length = array.length;

            predicate = getCallback(predicate, thisArg, 3);
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result;
          }

          /**
           * Gets all but the first element of `array`.
           *
           * @static
           * @memberOf _
           * @alias tail
           * @category Array
           * @param {Array} array The array to query.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.rest([1, 2, 3]);
           * // => [2, 3]
           */
          function rest(array) {
            return drop(array, 1);
          }

          /**
           * Creates a slice of `array` from `start` up to, but not including, `end`.
           *
           * **Note:** This method is used instead of `Array#slice` to support node
           * lists in IE < 9 and to ensure dense arrays are returned.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to slice.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the slice of `array`.
           */
          function slice(array, start, end) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            }
            return baseSlice(array, start, end);
          }

          /**
           * Uses a binary search to determine the lowest index at which `value` should
           * be inserted into `array` in order to maintain its sort order. If an iteratee
           * function is provided it is invoked for `value` and each element of `array`
           * to compute their sort ranking. The iteratee is bound to `thisArg` and
           * invoked with one argument; (value).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * _.sortedIndex([30, 50], 40);
           * // => 1
           *
           * _.sortedIndex([4, 4, 5, 5], 5);
           * // => 2
           *
           * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
           *
           * // using an iteratee function
           * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
           *   return this.data[word];
           * }, dict);
           * // => 1
           *
           * // using the `_.property` callback shorthand
           * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
           * // => 1
           */
          var sortedIndex = createSortedIndex();

          /**
           * This method is like `_.sortedIndex` except that it returns the highest
           * index at which `value` should be inserted into `array` in order to
           * maintain its sort order.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * _.sortedLastIndex([4, 4, 5, 5], 5);
           * // => 4
           */
          var sortedLastIndex = createSortedIndex(true);

          /**
           * Creates a slice of `array` with `n` elements taken from the beginning.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to take.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.take([1, 2, 3]);
           * // => [1]
           *
           * _.take([1, 2, 3], 2);
           * // => [1, 2]
           *
           * _.take([1, 2, 3], 5);
           * // => [1, 2, 3]
           *
           * _.take([1, 2, 3], 0);
           * // => []
           */
          function take(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
              n = 1;
            }
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }

          /**
           * Creates a slice of `array` with `n` elements taken from the end.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to take.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.takeRight([1, 2, 3]);
           * // => [3]
           *
           * _.takeRight([1, 2, 3], 2);
           * // => [2, 3]
           *
           * _.takeRight([1, 2, 3], 5);
           * // => [1, 2, 3]
           *
           * _.takeRight([1, 2, 3], 0);
           * // => []
           */
          function takeRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
              n = 1;
            }
            n = length - (+n || 0);
            return baseSlice(array, n < 0 ? 0 : n);
          }

          /**
           * Creates a slice of `array` with elements taken from the end. Elements are
           * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
           * and invoked with three arguments: (value, index, array).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.takeRightWhile([1, 2, 3], function(n) {
           *   return n > 1;
           * });
           * // => [2, 3]
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
           * // => ['pebbles']
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
           * // => ['fred', 'pebbles']
           *
           * // using the `_.property` callback shorthand
           * _.pluck(_.takeRightWhile(users, 'active'), 'user');
           * // => []
           */
          function takeRightWhile(array, predicate, thisArg) {
            return (array && array.length)
              ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
              : [];
          }

          /**
           * Creates a slice of `array` with elements taken from the beginning. Elements
           * are taken until `predicate` returns falsey. The predicate is bound to
           * `thisArg` and invoked with three arguments: (value, index, array).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.takeWhile([1, 2, 3], function(n) {
           *   return n < 3;
           * });
           * // => [1, 2]
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false},
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
           * // => ['barney']
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.pluck(_.takeWhile(users, 'active', false), 'user');
           * // => ['barney', 'fred']
           *
           * // using the `_.property` callback shorthand
           * _.pluck(_.takeWhile(users, 'active'), 'user');
           * // => []
           */
          function takeWhile(array, predicate, thisArg) {
            return (array && array.length)
              ? baseWhile(array, getCallback(predicate, thisArg, 3))
              : [];
          }

          /**
           * Creates an array of unique values, in order, from all of the provided arrays
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of combined values.
           * @example
           *
           * _.union([1, 2], [4, 2], [2, 1]);
           * // => [1, 2, 4]
           */
          var union = restParam(function (arrays) {
            return baseUniq(baseFlatten(arrays, false, true));
          });

          /**
           * Creates a duplicate-free version of an array, using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
           * for equality comparisons, in which only the first occurence of each element
           * is kept. Providing `true` for `isSorted` performs a faster search algorithm
           * for sorted arrays. If an iteratee function is provided it is invoked for
           * each element in the array to generate the criterion by which uniqueness
           * is computed. The `iteratee` is bound to `thisArg` and invoked with three
           * arguments: (value, index, array).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @alias unique
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {boolean} [isSorted] Specify the array is sorted.
           * @param {Function|Object|string} [iteratee] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array} Returns the new duplicate-value-free array.
           * @example
           *
           * _.uniq([2, 1, 2]);
           * // => [2, 1]
           *
           * // using `isSorted`
           * _.uniq([1, 1, 2], true);
           * // => [1, 2]
           *
           * // using an iteratee function
           * _.uniq([1, 2.5, 1.5, 2], function(n) {
           *   return this.floor(n);
           * }, Math);
           * // => [1, 2.5]
           *
           * // using the `_.property` callback shorthand
           * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }, { 'x': 2 }]
           */
          function uniq(array, isSorted, iteratee, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            if (isSorted != null && typeof isSorted != 'boolean') {
              thisArg = iteratee;
              iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
              isSorted = false;
            }
            var callback = getCallback();
            if (!(iteratee == null && callback === baseCallback)) {
              iteratee = callback(iteratee, thisArg, 3);
            }
            return (isSorted && getIndexOf() == baseIndexOf)
              ? sortedUniq(array, iteratee)
              : baseUniq(array, iteratee);
          }

          /**
           * This method is like `_.zip` except that it accepts an array of grouped
           * elements and creates an array regrouping the elements to their pre-zip
           * configuration.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array of grouped elements to process.
           * @returns {Array} Returns the new array of regrouped elements.
           * @example
           *
           * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
           * // => [['fred', 30, true], ['barney', 40, false]]
           *
           * _.unzip(zipped);
           * // => [['fred', 'barney'], [30, 40], [true, false]]
           */
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var index = -1,
              length = 0;

            array = arrayFilter(array, function (group) {
              if (isArrayLike(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            var result = Array(length);
            while (++index < length) {
              result[index] = arrayMap(array, baseProperty(index));
            }
            return result;
          }

          /**
           * This method is like `_.unzip` except that it accepts an iteratee to specify
           * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
           * and invoked with four arguments: (accumulator, value, index, group).
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array of grouped elements to process.
           * @param {Function} [iteratee] The function to combine regrouped values.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array} Returns the new array of regrouped elements.
           * @example
           *
           * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
           * // => [[1, 10, 100], [2, 20, 200]]
           *
           * _.unzipWith(zipped, _.add);
           * // => [3, 30, 300]
           */
          function unzipWith(array, iteratee, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
              return [];
            }
            var result = unzip(array);
            if (iteratee == null) {
              return result;
            }
            iteratee = bindCallback(iteratee, thisArg, 4);
            return arrayMap(result, function (group) {
              return arrayReduce(group, iteratee, undefined, true);
            });
          }

          /**
           * Creates an array excluding all provided values using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {Array} array The array to filter.
           * @param {...*} [values] The values to exclude.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.without([1, 2, 1, 3], 1, 2);
           * // => [3]
           */
          var without = restParam(function (array, values) {
            return isArrayLike(array)
              ? baseDifference(array, values)
              : [];
          });

          /**
           * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
           * of the provided arrays.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of values.
           * @example
           *
           * _.xor([1, 2], [4, 2]);
           * // => [1, 4]
           */
          function xor() {
            var index = -1,
              length = arguments.length;

            while (++index < length) {
              var array = arguments[index];
              if (isArrayLike(array)) {
                var result = result
                  ? arrayPush(baseDifference(result, array), baseDifference(array, result))
                  : array;
              }
            }
            return result ? baseUniq(result) : [];
          }

          /**
           * Creates an array of grouped elements, the first of which contains the first
           * elements of the given arrays, the second of which contains the second elements
           * of the given arrays, and so on.
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {...Array} [arrays] The arrays to process.
           * @returns {Array} Returns the new array of grouped elements.
           * @example
           *
           * _.zip(['fred', 'barney'], [30, 40], [true, false]);
           * // => [['fred', 30, true], ['barney', 40, false]]
           */
          var zip = restParam(unzip);

          /**
           * The inverse of `_.pairs`; this method returns an object composed from arrays
           * of property names and values. Provide either a single two dimensional array,
           * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
           * and one of corresponding values.
           *
           * @static
           * @memberOf _
           * @alias object
           * @category Array
           * @param {Array} props The property names.
           * @param {Array} [values=[]] The property values.
           * @returns {Object} Returns the new object.
           * @example
           *
           * _.zipObject([['fred', 30], ['barney', 40]]);
           * // => { 'fred': 30, 'barney': 40 }
           *
           * _.zipObject(['fred', 'barney'], [30, 40]);
           * // => { 'fred': 30, 'barney': 40 }
           */
          function zipObject(props, values) {
            var index = -1,
              length = props ? props.length : 0,
              result = {};

            if (length && !values && !isArray(props[0])) {
              values = [];
            }
            while (++index < length) {
              var key = props[index];
              if (values) {
                result[key] = values[index];
              } else if (key) {
                result[key[0]] = key[1];
              }
            }
            return result;
          }

          /**
           * This method is like `_.zip` except that it accepts an iteratee to specify
           * how grouped values should be combined. The `iteratee` is bound to `thisArg`
           * and invoked with four arguments: (accumulator, value, index, group).
           *
           * @static
           * @memberOf _
           * @category Array
           * @param {...Array} [arrays] The arrays to process.
           * @param {Function} [iteratee] The function to combine grouped values.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array} Returns the new array of grouped elements.
           * @example
           *
           * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
           * // => [111, 222]
           */
          var zipWith = restParam(function (arrays) {
            var length = arrays.length,
              iteratee = length > 2 ? arrays[length - 2] : undefined,
              thisArg = length > 1 ? arrays[length - 1] : undefined;

            if (length > 2 && typeof iteratee == 'function') {
              length -= 2;
            } else {
              iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
              thisArg = undefined;
            }
            arrays.length = length;
            return unzipWith(arrays, iteratee, thisArg);
          });

          /*------------------------------------------------------------------------*/

          /**
           * Creates a `lodash` object that wraps `value` with explicit method
           * chaining enabled.
           *
           * @static
           * @memberOf _
           * @category Chain
           * @param {*} value The value to wrap.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36 },
           *   { 'user': 'fred',    'age': 40 },
           *   { 'user': 'pebbles', 'age': 1 }
           * ];
           *
           * var youngest = _.chain(users)
           *   .sortBy('age')
           *   .map(function(chr) {
           *     return chr.user + ' is ' + chr.age;
           *   })
           *   .first()
           *   .value();
           * // => 'pebbles is 1'
           */
          function chain(value) {
            var result = lodash(value);
            result.__chain__ = true;
            return result;
          }

          /**
           * This method invokes `interceptor` and returns `value`. The interceptor is
           * bound to `thisArg` and invoked with one argument; (value). The purpose of
           * this method is to "tap into" a method chain in order to perform operations
           * on intermediate results within the chain.
           *
           * @static
           * @memberOf _
           * @category Chain
           * @param {*} value The value to provide to `interceptor`.
           * @param {Function} interceptor The function to invoke.
           * @param {*} [thisArg] The `this` binding of `interceptor`.
           * @returns {*} Returns `value`.
           * @example
           *
           * _([1, 2, 3])
           *  .tap(function(array) {
           *    array.pop();
           *  })
           *  .reverse()
           *  .value();
           * // => [2, 1]
           */
          function tap(value, interceptor, thisArg) {
            interceptor.call(thisArg, value);
            return value;
          }

          /**
           * This method is like `_.tap` except that it returns the result of `interceptor`.
           *
           * @static
           * @memberOf _
           * @category Chain
           * @param {*} value The value to provide to `interceptor`.
           * @param {Function} interceptor The function to invoke.
           * @param {*} [thisArg] The `this` binding of `interceptor`.
           * @returns {*} Returns the result of `interceptor`.
           * @example
           *
           * _('  abc  ')
           *  .chain()
           *  .trim()
           *  .thru(function(value) {
           *    return [value];
           *  })
           *  .value();
           * // => ['abc']
           */
          function thru(value, interceptor, thisArg) {
            return interceptor.call(thisArg, value);
          }

          /**
           * Enables explicit method chaining on the wrapper object.
           *
           * @name chain
           * @memberOf _
           * @category Chain
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 40 }
           * ];
           *
           * // without explicit chaining
           * _(users).first();
           * // => { 'user': 'barney', 'age': 36 }
           *
           * // with explicit chaining
           * _(users).chain()
           *   .first()
           *   .pick('user')
           *   .value();
           * // => { 'user': 'barney' }
           */
          function wrapperChain() {
            return chain(this);
          }

          /**
           * Executes the chained sequence and returns the wrapped result.
           *
           * @name commit
           * @memberOf _
           * @category Chain
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var array = [1, 2];
           * var wrapped = _(array).push(3);
           *
           * console.log(array);
           * // => [1, 2]
           *
           * wrapped = wrapped.commit();
           * console.log(array);
           * // => [1, 2, 3]
           *
           * wrapped.last();
           * // => 3
           *
           * console.log(array);
           * // => [1, 2, 3]
           */
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }

          /**
           * Creates a new array joining a wrapped array with any additional arrays
           * and/or values.
           *
           * @name concat
           * @memberOf _
           * @category Chain
           * @param {...*} [values] The values to concatenate.
           * @returns {Array} Returns the new concatenated array.
           * @example
           *
           * var array = [1];
           * var wrapped = _(array).concat(2, [3], [[4]]);
           *
           * console.log(wrapped.value());
           * // => [1, 2, 3, [4]]
           *
           * console.log(array);
           * // => [1]
           */
          var wrapperConcat = restParam(function (values) {
            values = baseFlatten(values);
            return this.thru(function (array) {
              return arrayConcat(isArray(array) ? array : [toObject(array)], values);
            });
          });

          /**
           * Creates a clone of the chained sequence planting `value` as the wrapped value.
           *
           * @name plant
           * @memberOf _
           * @category Chain
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var array = [1, 2];
           * var wrapped = _(array).map(function(value) {
           *   return Math.pow(value, 2);
           * });
           *
           * var other = [3, 4];
           * var otherWrapped = wrapped.plant(other);
           *
           * otherWrapped.value();
           * // => [9, 16]
           *
           * wrapped.value();
           * // => [1, 4]
           */
          function wrapperPlant(value) {
            var result,
              parent = this;

            while (parent instanceof baseLodash) {
              var clone = wrapperClone(parent);
              if (result) {
                previous.__wrapped__ = clone;
              } else {
                result = clone;
              }
              var previous = clone;
              parent = parent.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result;
          }

          /**
           * Reverses the wrapped array so the first element becomes the last, the
           * second element becomes the second to last, and so on.
           *
           * **Note:** This method mutates the wrapped array.
           *
           * @name reverse
           * @memberOf _
           * @category Chain
           * @returns {Object} Returns the new reversed `lodash` wrapper instance.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _(array).reverse().value()
           * // => [3, 2, 1]
           *
           * console.log(array);
           * // => [3, 2, 1]
           */
          function wrapperReverse() {
            var value = this.__wrapped__;

            var interceptor = function (value) {
              return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
            };
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(interceptor);
          }

          /**
           * Produces the result of coercing the unwrapped value to a string.
           *
           * @name toString
           * @memberOf _
           * @category Chain
           * @returns {string} Returns the coerced string value.
           * @example
           *
           * _([1, 2, 3]).toString();
           * // => '1,2,3'
           */
          function wrapperToString() {
            return (this.value() + '');
          }

          /**
           * Executes the chained sequence to extract the unwrapped value.
           *
           * @name value
           * @memberOf _
           * @alias run, toJSON, valueOf
           * @category Chain
           * @returns {*} Returns the resolved unwrapped value.
           * @example
           *
           * _([1, 2, 3]).value();
           * // => [1, 2, 3]
           */
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }

          /*------------------------------------------------------------------------*/

          /**
           * Creates an array of elements corresponding to the given keys, or indexes,
           * of `collection`. Keys may be specified as individual arguments or as arrays
           * of keys.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {...(number|number[]|string|string[])} [props] The property names
           *  or indexes of elements to pick, specified individually or in arrays.
           * @returns {Array} Returns the new array of picked elements.
           * @example
           *
           * _.at(['a', 'b', 'c'], [0, 2]);
           * // => ['a', 'c']
           *
           * _.at(['barney', 'fred', 'pebbles'], 0, 2);
           * // => ['barney', 'pebbles']
           */
          var at = restParam(function (collection, props) {
            return baseAt(collection, baseFlatten(props));
          });

          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` through `iteratee`. The corresponding value
           * of each key is the number of times the key was returned by `iteratee`.
           * The `iteratee` is bound to `thisArg` and invoked with three arguments:
           * (value, index|key, collection).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.countBy([4.3, 6.1, 6.4], function(n) {
           *   return Math.floor(n);
           * });
           * // => { '4': 1, '6': 2 }
           *
           * _.countBy([4.3, 6.1, 6.4], function(n) {
           *   return this.floor(n);
           * }, Math);
           * // => { '4': 1, '6': 2 }
           *
           * _.countBy(['one', 'two', 'three'], 'length');
           * // => { '3': 2, '5': 1 }
           */
          var countBy = createAggregator(function (result, value, key) {
            hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
          });

          /**
           * Checks if `predicate` returns truthy for **all** elements of `collection`.
           * The predicate is bound to `thisArg` and invoked with three arguments:
           * (value, index|key, collection).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @alias all
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {boolean} Returns `true` if all elements pass the predicate check,
           *  else `false`.
           * @example
           *
           * _.every([true, 1, null, 'yes'], Boolean);
           * // => false
           *
           * var users = [
           *   { 'user': 'barney', 'active': false },
           *   { 'user': 'fred',   'active': false }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.every(users, { 'user': 'barney', 'active': false });
           * // => false
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.every(users, 'active', false);
           * // => true
           *
           * // using the `_.property` callback shorthand
           * _.every(users, 'active');
           * // => false
           */
          function every(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
              predicate = undefined;
            }
            if (typeof predicate != 'function' || thisArg !== undefined) {
              predicate = getCallback(predicate, thisArg, 3);
            }
            return func(collection, predicate);
          }

          /**
           * Iterates over elements of `collection`, returning an array of all elements
           * `predicate` returns truthy for. The predicate is bound to `thisArg` and
           * invoked with three arguments: (value, index|key, collection).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @alias select
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the new filtered array.
           * @example
           *
           * _.filter([4, 5, 6], function(n) {
           *   return n % 2 == 0;
           * });
           * // => [4, 6]
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': true },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
           * // => ['barney']
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.pluck(_.filter(users, 'active', false), 'user');
           * // => ['fred']
           *
           * // using the `_.property` callback shorthand
           * _.pluck(_.filter(users, 'active'), 'user');
           * // => ['barney']
           */
          function filter(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = getCallback(predicate, thisArg, 3);
            return func(collection, predicate);
          }

          /**
           * Iterates over elements of `collection`, returning the first element
           * `predicate` returns truthy for. The predicate is bound to `thisArg` and
           * invoked with three arguments: (value, index|key, collection).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @alias detect
           * @category Collection
           * @param {Array|Object|string} collection The collection to search.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {*} Returns the matched element, else `undefined`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36, 'active': true },
           *   { 'user': 'fred',    'age': 40, 'active': false },
           *   { 'user': 'pebbles', 'age': 1,  'active': true }
           * ];
           *
           * _.result(_.find(users, function(chr) {
           *   return chr.age < 40;
           * }), 'user');
           * // => 'barney'
           *
           * // using the `_.matches` callback shorthand
           * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
           * // => 'pebbles'
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.result(_.find(users, 'active', false), 'user');
           * // => 'fred'
           *
           * // using the `_.property` callback shorthand
           * _.result(_.find(users, 'active'), 'user');
           * // => 'barney'
           */
          var find = createFind(baseEach);

          /**
           * This method is like `_.find` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to search.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {*} Returns the matched element, else `undefined`.
           * @example
           *
           * _.findLast([1, 2, 3, 4], function(n) {
           *   return n % 2 == 1;
           * });
           * // => 3
           */
          var findLast = createFind(baseEachRight, true);

          /**
           * Performs a deep comparison between each element in `collection` and the
           * source object, returning the first element that has equivalent property
           * values.
           *
           * **Note:** This method supports comparing arrays, booleans, `Date` objects,
           * numbers, `Object` objects, regexes, and strings. Objects are compared by
           * their own, not inherited, enumerable properties. For comparing a single
           * own or inherited property value see `_.matchesProperty`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to search.
           * @param {Object} source The object of property values to match.
           * @returns {*} Returns the matched element, else `undefined`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': true },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
           * // => 'barney'
           *
           * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
           * // => 'fred'
           */
          function findWhere(collection, source) {
            return find(collection, baseMatches(source));
          }

          /**
           * Iterates over elements of `collection` invoking `iteratee` for each element.
           * The `iteratee` is bound to `thisArg` and invoked with three arguments:
           * (value, index|key, collection). Iteratee functions may exit iteration early
           * by explicitly returning `false`.
           *
           * **Note:** As with other "Collections" methods, objects with a "length" property
           * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
           * may be used for object iteration.
           *
           * @static
           * @memberOf _
           * @alias each
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array|Object|string} Returns `collection`.
           * @example
           *
           * _([1, 2]).forEach(function(n) {
           *   console.log(n);
           * }).value();
           * // => logs each value from left to right and returns the array
           *
           * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
           *   console.log(n, key);
           * });
           * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
           */
          var forEach = createForEach(arrayEach, baseEach);

          /**
           * This method is like `_.forEach` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @alias eachRight
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array|Object|string} Returns `collection`.
           * @example
           *
           * _([1, 2]).forEachRight(function(n) {
           *   console.log(n);
           * }).value();
           * // => logs each value from right to left and returns the array
           */
          var forEachRight = createForEach(arrayEachRight, baseEachRight);

          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` through `iteratee`. The corresponding value
           * of each key is an array of the elements responsible for generating the key.
           * The `iteratee` is bound to `thisArg` and invoked with three arguments:
           * (value, index|key, collection).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.groupBy([4.2, 6.1, 6.4], function(n) {
           *   return Math.floor(n);
           * });
           * // => { '4': [4.2], '6': [6.1, 6.4] }
           *
           * _.groupBy([4.2, 6.1, 6.4], function(n) {
           *   return this.floor(n);
           * }, Math);
           * // => { '4': [4.2], '6': [6.1, 6.4] }
           *
           * // using the `_.property` callback shorthand
           * _.groupBy(['one', 'two', 'three'], 'length');
           * // => { '3': ['one', 'two'], '5': ['three'] }
           */
          var groupBy = createAggregator(function (result, value, key) {
            if (hasOwnProperty.call(result, key)) {
              result[key].push(value);
            } else {
              result[key] = [value];
            }
          });

          /**
           * Checks if `value` is in `collection` using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
           * for equality comparisons. If `fromIndex` is negative, it is used as the offset
           * from the end of `collection`.
           *
           * @static
           * @memberOf _
           * @alias contains, include
           * @category Collection
           * @param {Array|Object|string} collection The collection to search.
           * @param {*} target The value to search for.
           * @param {number} [fromIndex=0] The index to search from.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
           * @returns {boolean} Returns `true` if a matching element is found, else `false`.
           * @example
           *
           * _.includes([1, 2, 3], 1);
           * // => true
           *
           * _.includes([1, 2, 3], 1, 2);
           * // => false
           *
           * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
           * // => true
           *
           * _.includes('pebbles', 'eb');
           * // => true
           */
          function includes(collection, target, fromIndex, guard) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) {
              collection = values(collection);
              length = collection.length;
            }
            if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
              fromIndex = 0;
            } else {
              fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
            }
            return (typeof collection == 'string' || !isArray(collection) && isString(collection))
              ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
              : (!!length && getIndexOf(collection, target, fromIndex) > -1);
          }

          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` through `iteratee`. The corresponding value
           * of each key is the last element responsible for generating the key. The
           * iteratee function is bound to `thisArg` and invoked with three arguments:
           * (value, index|key, collection).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * var keyData = [
           *   { 'dir': 'left', 'code': 97 },
           *   { 'dir': 'right', 'code': 100 }
           * ];
           *
           * _.indexBy(keyData, 'dir');
           * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
           *
           * _.indexBy(keyData, function(object) {
           *   return String.fromCharCode(object.code);
           * });
           * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
           *
           * _.indexBy(keyData, function(object) {
           *   return this.fromCharCode(object.code);
           * }, String);
           * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
           */
          var indexBy = createAggregator(function (result, value, key) {
            result[key] = value;
          });

          /**
           * Invokes the method at `path` of each element in `collection`, returning
           * an array of the results of each invoked method. Any additional arguments
           * are provided to each invoked method. If `methodName` is a function it is
           * invoked for, and `this` bound to, each element in `collection`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Array|Function|string} path The path of the method to invoke or
           *  the function invoked per iteration.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {Array} Returns the array of results.
           * @example
           *
           * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
           * // => [[1, 5, 7], [1, 2, 3]]
           *
           * _.invoke([123, 456], String.prototype.split, '');
           * // => [['1', '2', '3'], ['4', '5', '6']]
           */
          var invoke = restParam(function (collection, path, args) {
            var index = -1,
              isFunc = typeof path == 'function',
              isProp = isKey(path),
              result = isArrayLike(collection) ? Array(collection.length) : [];

            baseEach(collection, function (value) {
              var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
              result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
            });
            return result;
          });

          /**
           * Creates an array of values by running each element in `collection` through
           * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
           * arguments: (value, index|key, collection).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * Many lodash methods are guarded to work as iteratees for methods like
           * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
           *
           * The guarded methods are:
           * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
           * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
           * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
           * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
           * `sum`, `uniq`, and `words`
           *
           * @static
           * @memberOf _
           * @alias collect
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array} Returns the new mapped array.
           * @example
           *
           * function timesThree(n) {
           *   return n * 3;
           * }
           *
           * _.map([1, 2], timesThree);
           * // => [3, 6]
           *
           * _.map({ 'a': 1, 'b': 2 }, timesThree);
           * // => [3, 6] (iteration order is not guaranteed)
           *
           * var users = [
           *   { 'user': 'barney' },
           *   { 'user': 'fred' }
           * ];
           *
           * // using the `_.property` callback shorthand
           * _.map(users, 'user');
           * // => ['barney', 'fred']
           */
          function map(collection, iteratee, thisArg) {
            var func = isArray(collection) ? arrayMap : baseMap;
            iteratee = getCallback(iteratee, thisArg, 3);
            return func(collection, iteratee);
          }

          /**
           * Creates an array of elements split into two groups, the first of which
           * contains elements `predicate` returns truthy for, while the second of which
           * contains elements `predicate` returns falsey for. The predicate is bound
           * to `thisArg` and invoked with three arguments: (value, index|key, collection).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the array of grouped elements.
           * @example
           *
           * _.partition([1, 2, 3], function(n) {
           *   return n % 2;
           * });
           * // => [[1, 3], [2]]
           *
           * _.partition([1.2, 2.3, 3.4], function(n) {
           *   return this.floor(n) % 2;
           * }, Math);
           * // => [[1.2, 3.4], [2.3]]
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36, 'active': false },
           *   { 'user': 'fred',    'age': 40, 'active': true },
           *   { 'user': 'pebbles', 'age': 1,  'active': false }
           * ];
           *
           * var mapper = function(array) {
           *   return _.pluck(array, 'user');
           * };
           *
           * // using the `_.matches` callback shorthand
           * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
           * // => [['pebbles'], ['barney', 'fred']]
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.map(_.partition(users, 'active', false), mapper);
           * // => [['barney', 'pebbles'], ['fred']]
           *
           * // using the `_.property` callback shorthand
           * _.map(_.partition(users, 'active'), mapper);
           * // => [['fred'], ['barney', 'pebbles']]
           */
          var partition = createAggregator(function (result, value, key) {
            result[key ? 0 : 1].push(value);
          }, function () { return [[], []]; });

          /**
           * Gets the property value of `path` from all elements in `collection`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Array|string} path The path of the property to pluck.
           * @returns {Array} Returns the property values.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 40 }
           * ];
           *
           * _.pluck(users, 'user');
           * // => ['barney', 'fred']
           *
           * var userIndex = _.indexBy(users, 'user');
           * _.pluck(userIndex, 'age');
           * // => [36, 40] (iteration order is not guaranteed)
           */
          function pluck(collection, path) {
            return map(collection, property(path));
          }

          /**
           * Reduces `collection` to a value which is the accumulated result of running
           * each element in `collection` through `iteratee`, where each successive
           * invocation is supplied the return value of the previous. If `accumulator`
           * is not provided the first element of `collection` is used as the initial
           * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
           * (accumulator, value, index|key, collection).
           *
           * Many lodash methods are guarded to work as iteratees for methods like
           * `_.reduce`, `_.reduceRight`, and `_.transform`.
           *
           * The guarded methods are:
           * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
           * and `sortByOrder`
           *
           * @static
           * @memberOf _
           * @alias foldl, inject
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * _.reduce([1, 2], function(total, n) {
           *   return total + n;
           * });
           * // => 3
           *
           * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
           *   result[key] = n * 3;
           *   return result;
           * }, {});
           * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
           */
          var reduce = createReduce(arrayReduce, baseEach);

          /**
           * This method is like `_.reduce` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @alias foldr
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * var array = [[0, 1], [2, 3], [4, 5]];
           *
           * _.reduceRight(array, function(flattened, other) {
           *   return flattened.concat(other);
           * }, []);
           * // => [4, 5, 2, 3, 0, 1]
           */
          var reduceRight = createReduce(arrayReduceRight, baseEachRight);

          /**
           * The opposite of `_.filter`; this method returns the elements of `collection`
           * that `predicate` does **not** return truthy for.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Array} Returns the new filtered array.
           * @example
           *
           * _.reject([1, 2, 3, 4], function(n) {
           *   return n % 2 == 0;
           * });
           * // => [1, 3]
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': false },
           *   { 'user': 'fred',   'age': 40, 'active': true }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
           * // => ['barney']
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.pluck(_.reject(users, 'active', false), 'user');
           * // => ['fred']
           *
           * // using the `_.property` callback shorthand
           * _.pluck(_.reject(users, 'active'), 'user');
           * // => ['barney']
           */
          function reject(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = getCallback(predicate, thisArg, 3);
            return func(collection, function (value, index, collection) {
              return !predicate(value, index, collection);
            });
          }

          /**
           * Gets a random element or `n` random elements from a collection.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to sample.
           * @param {number} [n] The number of elements to sample.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {*} Returns the random sample(s).
           * @example
           *
           * _.sample([1, 2, 3, 4]);
           * // => 2
           *
           * _.sample([1, 2, 3, 4], 2);
           * // => [3, 1]
           */
          function sample(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n == null) {
              collection = toIterable(collection);
              var length = collection.length;
              return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
            }
            var index = -1,
              result = toArray(collection),
              length = result.length,
              lastIndex = length - 1;

            n = nativeMin(n < 0 ? 0 : (+n || 0), length);
            while (++index < n) {
              var rand = baseRandom(index, lastIndex),
                value = result[rand];

              result[rand] = result[index];
              result[index] = value;
            }
            result.length = n;
            return result;
          }

          /**
           * Creates an array of shuffled values, using a version of the
           * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to shuffle.
           * @returns {Array} Returns the new shuffled array.
           * @example
           *
           * _.shuffle([1, 2, 3, 4]);
           * // => [4, 1, 3, 2]
           */
          function shuffle(collection) {
            return sample(collection, POSITIVE_INFINITY);
          }

          /**
           * Gets the size of `collection` by returning its length for array-like
           * values or the number of own enumerable properties for objects.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to inspect.
           * @returns {number} Returns the size of `collection`.
           * @example
           *
           * _.size([1, 2, 3]);
           * // => 3
           *
           * _.size({ 'a': 1, 'b': 2 });
           * // => 2
           *
           * _.size('pebbles');
           * // => 7
           */
          function size(collection) {
            var length = collection ? getLength(collection) : 0;
            return isLength(length) ? length : keys(collection).length;
          }

          /**
           * Checks if `predicate` returns truthy for **any** element of `collection`.
           * The function returns as soon as it finds a passing value and does not iterate
           * over the entire collection. The predicate is bound to `thisArg` and invoked
           * with three arguments: (value, index|key, collection).
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @alias any
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {boolean} Returns `true` if any element passes the predicate check,
           *  else `false`.
           * @example
           *
           * _.some([null, 0, 'yes', false], Boolean);
           * // => true
           *
           * var users = [
           *   { 'user': 'barney', 'active': true },
           *   { 'user': 'fred',   'active': false }
           * ];
           *
           * // using the `_.matches` callback shorthand
           * _.some(users, { 'user': 'barney', 'active': false });
           * // => false
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.some(users, 'active', false);
           * // => true
           *
           * // using the `_.property` callback shorthand
           * _.some(users, 'active');
           * // => true
           */
          function some(collection, predicate, thisArg) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
              predicate = undefined;
            }
            if (typeof predicate != 'function' || thisArg !== undefined) {
              predicate = getCallback(predicate, thisArg, 3);
            }
            return func(collection, predicate);
          }

          /**
           * Creates an array of elements, sorted in ascending order by the results of
           * running each element in a collection through `iteratee`. This method performs
           * a stable sort, that is, it preserves the original sort order of equal elements.
           * The `iteratee` is bound to `thisArg` and invoked with three arguments:
           * (value, index|key, collection).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array} Returns the new sorted array.
           * @example
           *
           * _.sortBy([1, 2, 3], function(n) {
           *   return Math.sin(n);
           * });
           * // => [3, 1, 2]
           *
           * _.sortBy([1, 2, 3], function(n) {
           *   return this.sin(n);
           * }, Math);
           * // => [3, 1, 2]
           *
           * var users = [
           *   { 'user': 'fred' },
           *   { 'user': 'pebbles' },
           *   { 'user': 'barney' }
           * ];
           *
           * // using the `_.property` callback shorthand
           * _.pluck(_.sortBy(users, 'user'), 'user');
           * // => ['barney', 'fred', 'pebbles']
           */
          function sortBy(collection, iteratee, thisArg) {
            if (collection == null) {
              return [];
            }
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = undefined;
            }
            var index = -1;
            iteratee = getCallback(iteratee, thisArg, 3);

            var result = baseMap(collection, function (value, key, collection) {
              return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
            });
            return baseSortBy(result, compareAscending);
          }

          /**
           * This method is like `_.sortBy` except that it can sort by multiple iteratees
           * or property names.
           *
           * If a property name is provided for an iteratee the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If an object is provided for an iteratee the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
           *  The iteratees to sort by, specified as individual values or arrays of values.
           * @returns {Array} Returns the new sorted array.
           * @example
           *
           * var users = [
           *   { 'user': 'fred',   'age': 48 },
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 42 },
           *   { 'user': 'barney', 'age': 34 }
           * ];
           *
           * _.map(_.sortByAll(users, ['user', 'age']), _.values);
           * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
           *
           * _.map(_.sortByAll(users, 'user', function(chr) {
           *   return Math.floor(chr.age / 10);
           * }), _.values);
           * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
           */
          var sortByAll = restParam(function (collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var guard = iteratees[2];
            if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
              iteratees.length = 1;
            }
            return baseSortByOrder(collection, baseFlatten(iteratees), []);
          });

          /**
           * This method is like `_.sortByAll` except that it allows specifying the
           * sort orders of the iteratees to sort by. If `orders` is unspecified, all
           * values are sorted in ascending order. Otherwise, a value is sorted in
           * ascending order if its corresponding order is "asc", and descending if "desc".
           *
           * If a property name is provided for an iteratee the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If an object is provided for an iteratee the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
           * @param {boolean[]} [orders] The sort orders of `iteratees`.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
           * @returns {Array} Returns the new sorted array.
           * @example
           *
           * var users = [
           *   { 'user': 'fred',   'age': 48 },
           *   { 'user': 'barney', 'age': 34 },
           *   { 'user': 'fred',   'age': 42 },
           *   { 'user': 'barney', 'age': 36 }
           * ];
           *
           * // sort by `user` in ascending order and by `age` in descending order
           * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
           * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
           */
          function sortByOrder(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (guard && isIterateeCall(iteratees, orders, guard)) {
              orders = undefined;
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseSortByOrder(collection, iteratees, orders);
          }

          /**
           * Performs a deep comparison between each element in `collection` and the
           * source object, returning an array of all elements that have equivalent
           * property values.
           *
           * **Note:** This method supports comparing arrays, booleans, `Date` objects,
           * numbers, `Object` objects, regexes, and strings. Objects are compared by
           * their own, not inherited, enumerable properties. For comparing a single
           * own or inherited property value see `_.matchesProperty`.
           *
           * @static
           * @memberOf _
           * @category Collection
           * @param {Array|Object|string} collection The collection to search.
           * @param {Object} source The object of property values to match.
           * @returns {Array} Returns the new filtered array.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
           *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
           * ];
           *
           * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
           * // => ['barney']
           *
           * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
           * // => ['fred']
           */
          function where(collection, source) {
            return filter(collection, baseMatches(source));
          }

          /*------------------------------------------------------------------------*/

          /**
           * Gets the number of milliseconds that have elapsed since the Unix epoch
           * (1 January 1970 00:00:00 UTC).
           *
           * @static
           * @memberOf _
           * @category Date
           * @example
           *
           * _.defer(function(stamp) {
           *   console.log(_.now() - stamp);
           * }, _.now());
           * // => logs the number of milliseconds it took for the deferred function to be invoked
           */
          var now = nativeNow || function () {
            return new Date().getTime();
          };

          /*------------------------------------------------------------------------*/

          /**
           * The opposite of `_.before`; this method creates a function that invokes
           * `func` once it is called `n` or more times.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {number} n The number of calls before `func` is invoked.
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var saves = ['profile', 'settings'];
           *
           * var done = _.after(saves.length, function() {
           *   console.log('done saving!');
           * });
           *
           * _.forEach(saves, function(type) {
           *   asyncSave({ 'type': type, 'complete': done });
           * });
           * // => logs 'done saving!' after the two async saves have completed
           */
          function after(n, func) {
            if (typeof func != 'function') {
              if (typeof n == 'function') {
                var temp = n;
                n = func;
                func = temp;
              } else {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
            }
            n = nativeIsFinite(n = +n) ? n : 0;
            return function () {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }

          /**
           * Creates a function that accepts up to `n` arguments ignoring any
           * additional arguments.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to cap arguments for.
           * @param {number} [n=func.length] The arity cap.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Function} Returns the new function.
           * @example
           *
           * _.map(['6', '8', '10'], _.ary(parseInt, 1));
           * // => [6, 8, 10]
           */
          function ary(func, n, guard) {
            if (guard && isIterateeCall(func, n, guard)) {
              n = undefined;
            }
            n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
            return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
          }

          /**
           * Creates a function that invokes `func`, with the `this` binding and arguments
           * of the created function, while it is called less than `n` times. Subsequent
           * calls to the created function return the result of the last `func` invocation.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {number} n The number of calls at which `func` is no longer invoked.
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * jQuery('#add').on('click', _.before(5, addContactToList));
           * // => allows adding up to 4 contacts to the list
           */
          function before(n, func) {
            var result;
            if (typeof func != 'function') {
              if (typeof n == 'function') {
                var temp = n;
                n = func;
                func = temp;
              } else {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
            }
            return function () {
              if (--n > 0) {
                result = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined;
              }
              return result;
            };
          }

          /**
           * Creates a function that invokes `func` with the `this` binding of `thisArg`
           * and prepends any additional `_.bind` arguments to those provided to the
           * bound function.
           *
           * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
           * may be used as a placeholder for partially applied arguments.
           *
           * **Note:** Unlike native `Function#bind` this method does not set the "length"
           * property of bound functions.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to bind.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * var greet = function(greeting, punctuation) {
           *   return greeting + ' ' + this.user + punctuation;
           * };
           *
           * var object = { 'user': 'fred' };
           *
           * var bound = _.bind(greet, object, 'hi');
           * bound('!');
           * // => 'hi fred!'
           *
           * // using placeholders
           * var bound = _.bind(greet, object, _, '!');
           * bound('hi');
           * // => 'hi fred!'
           */
          var bind = restParam(function (func, thisArg, partials) {
            var bitmask = BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, bind.placeholder);
              bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(func, bitmask, thisArg, partials, holders);
          });

          /**
           * Binds methods of an object to the object itself, overwriting the existing
           * method. Method names may be specified as individual arguments or as arrays
           * of method names. If no method names are provided all enumerable function
           * properties, own and inherited, of `object` are bound.
           *
           * **Note:** This method does not set the "length" property of bound functions.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Object} object The object to bind and assign the bound methods to.
           * @param {...(string|string[])} [methodNames] The object method names to bind,
           *  specified as individual method names or arrays of method names.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var view = {
           *   'label': 'docs',
           *   'onClick': function() {
           *     console.log('clicked ' + this.label);
           *   }
           * };
           *
           * _.bindAll(view);
           * jQuery('#docs').on('click', view.onClick);
           * // => logs 'clicked docs' when the element is clicked
           */
          var bindAll = restParam(function (object, methodNames) {
            methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

            var index = -1,
              length = methodNames.length;

            while (++index < length) {
              var key = methodNames[index];
              object[key] = createWrapper(object[key], BIND_FLAG, object);
            }
            return object;
          });

          /**
           * Creates a function that invokes the method at `object[key]` and prepends
           * any additional `_.bindKey` arguments to those provided to the bound function.
           *
           * This method differs from `_.bind` by allowing bound functions to reference
           * methods that may be redefined or don't yet exist.
           * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
           * for more details.
           *
           * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Object} object The object the method belongs to.
           * @param {string} key The key of the method.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * var object = {
           *   'user': 'fred',
           *   'greet': function(greeting, punctuation) {
           *     return greeting + ' ' + this.user + punctuation;
           *   }
           * };
           *
           * var bound = _.bindKey(object, 'greet', 'hi');
           * bound('!');
           * // => 'hi fred!'
           *
           * object.greet = function(greeting, punctuation) {
           *   return greeting + 'ya ' + this.user + punctuation;
           * };
           *
           * bound('!');
           * // => 'hiya fred!'
           *
           * // using placeholders
           * var bound = _.bindKey(object, 'greet', _, '!');
           * bound('hi');
           * // => 'hiya fred!'
           */
          var bindKey = restParam(function (object, key, partials) {
            var bitmask = BIND_FLAG | BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, bindKey.placeholder);
              bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(key, bitmask, object, partials, holders);
          });

          /**
           * Creates a function that accepts one or more arguments of `func` that when
           * called either invokes `func` returning its result, if all `func` arguments
           * have been provided, or returns a function that accepts one or more of the
           * remaining `func` arguments, and so on. The arity of `func` may be specified
           * if `func.length` is not sufficient.
           *
           * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
           * may be used as a placeholder for provided arguments.
           *
           * **Note:** This method does not set the "length" property of curried functions.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to curry.
           * @param {number} [arity=func.length] The arity of `func`.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Function} Returns the new curried function.
           * @example
           *
           * var abc = function(a, b, c) {
           *   return [a, b, c];
           * };
           *
           * var curried = _.curry(abc);
           *
           * curried(1)(2)(3);
           * // => [1, 2, 3]
           *
           * curried(1, 2)(3);
           * // => [1, 2, 3]
           *
           * curried(1, 2, 3);
           * // => [1, 2, 3]
           *
           * // using placeholders
           * curried(1)(_, 3)(2);
           * // => [1, 2, 3]
           */
          var curry = createCurry(CURRY_FLAG);

          /**
           * This method is like `_.curry` except that arguments are applied to `func`
           * in the manner of `_.partialRight` instead of `_.partial`.
           *
           * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for provided arguments.
           *
           * **Note:** This method does not set the "length" property of curried functions.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to curry.
           * @param {number} [arity=func.length] The arity of `func`.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Function} Returns the new curried function.
           * @example
           *
           * var abc = function(a, b, c) {
           *   return [a, b, c];
           * };
           *
           * var curried = _.curryRight(abc);
           *
           * curried(3)(2)(1);
           * // => [1, 2, 3]
           *
           * curried(2, 3)(1);
           * // => [1, 2, 3]
           *
           * curried(1, 2, 3);
           * // => [1, 2, 3]
           *
           * // using placeholders
           * curried(3)(1, _)(2);
           * // => [1, 2, 3]
           */
          var curryRight = createCurry(CURRY_RIGHT_FLAG);

          /**
           * Creates a debounced function that delays invoking `func` until after `wait`
           * milliseconds have elapsed since the last time the debounced function was
           * invoked. The debounced function comes with a `cancel` method to cancel
           * delayed invocations. Provide an options object to indicate that `func`
           * should be invoked on the leading and/or trailing edge of the `wait` timeout.
           * Subsequent calls to the debounced function return the result of the last
           * `func` invocation.
           *
           * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
           * on the trailing edge of the timeout only if the the debounced function is
           * invoked more than once during the `wait` timeout.
           *
           * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
           * for details over the differences between `_.debounce` and `_.throttle`.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to debounce.
           * @param {number} [wait=0] The number of milliseconds to delay.
           * @param {Object} [options] The options object.
           * @param {boolean} [options.leading=false] Specify invoking on the leading
           *  edge of the timeout.
           * @param {number} [options.maxWait] The maximum time `func` is allowed to be
           *  delayed before it is invoked.
           * @param {boolean} [options.trailing=true] Specify invoking on the trailing
           *  edge of the timeout.
           * @returns {Function} Returns the new debounced function.
           * @example
           *
           * // avoid costly calculations while the window size is in flux
           * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
           *
           * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
           * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
           *   'leading': true,
           *   'trailing': false
           * }));
           *
           * // ensure `batchLog` is invoked once after 1 second of debounced calls
           * var source = new EventSource('/stream');
           * jQuery(source).on('message', _.debounce(batchLog, 250, {
           *   'maxWait': 1000
           * }));
           *
           * // cancel a debounced call
           * var todoChanges = _.debounce(batchLog, 1000);
           * Object.observe(models.todo, todoChanges);
           *
           * Object.observe(models, function(changes) {
           *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
           *     todoChanges.cancel();
           *   }
           * }, ['delete']);
           *
           * // ...at some point `models.todo` is changed
           * models.todo.completed = true;
           *
           * // ...before 1 second has passed `models.todo` is deleted
           * // which cancels the debounced `todoChanges` call
           * delete models.todo;
           */
          function debounce(func, wait, options) {
            var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;

            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            wait = wait < 0 ? 0 : (+wait || 0);
            if (options === true) {
              var leading = true;
              trailing = false;
            } else if (isObject(options)) {
              leading = !!options.leading;
              maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
              trailing = 'trailing' in options ? !!options.trailing : trailing;
            }

            function cancel() {
              if (timeoutId) {
                clearTimeout(timeoutId);
              }
              if (maxTimeoutId) {
                clearTimeout(maxTimeoutId);
              }
              lastCalled = 0;
              maxTimeoutId = timeoutId = trailingCall = undefined;
            }

            function complete(isCalled, id) {
              if (id) {
                clearTimeout(id);
              }
              maxTimeoutId = timeoutId = trailingCall = undefined;
              if (isCalled) {
                lastCalled = now();
                result = func.apply(thisArg, args);
                if (!timeoutId && !maxTimeoutId) {
                  args = thisArg = undefined;
                }
              }
            }

            function delayed() {
              var remaining = wait - (now() - stamp);
              if (remaining <= 0 || remaining > wait) {
                complete(trailingCall, maxTimeoutId);
              } else {
                timeoutId = setTimeout(delayed, remaining);
              }
            }

            function maxDelayed() {
              complete(trailing, timeoutId);
            }

            function debounced() {
              args = arguments;
              stamp = now();
              thisArg = this;
              trailingCall = trailing && (timeoutId || !leading);

              if (maxWait === false) {
                var leadingCall = leading && !timeoutId;
              } else {
                if (!maxTimeoutId && !leading) {
                  lastCalled = stamp;
                }
                var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0 || remaining > maxWait;

                if (isCalled) {
                  if (maxTimeoutId) {
                    maxTimeoutId = clearTimeout(maxTimeoutId);
                  }
                  lastCalled = stamp;
                  result = func.apply(thisArg, args);
                }
                else if (!maxTimeoutId) {
                  maxTimeoutId = setTimeout(maxDelayed, remaining);
                }
              }
              if (isCalled && timeoutId) {
                timeoutId = clearTimeout(timeoutId);
              }
              else if (!timeoutId && wait !== maxWait) {
                timeoutId = setTimeout(delayed, wait);
              }
              if (leadingCall) {
                isCalled = true;
                result = func.apply(thisArg, args);
              }
              if (isCalled && !timeoutId && !maxTimeoutId) {
                args = thisArg = undefined;
              }
              return result;
            }
            debounced.cancel = cancel;
            return debounced;
          }

          /**
           * Defers invoking the `func` until the current call stack has cleared. Any
           * additional arguments are provided to `func` when it is invoked.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to defer.
           * @param {...*} [args] The arguments to invoke the function with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.defer(function(text) {
           *   console.log(text);
           * }, 'deferred');
           * // logs 'deferred' after one or more milliseconds
           */
          var defer = restParam(function (func, args) {
            return baseDelay(func, 1, args);
          });

          /**
           * Invokes `func` after `wait` milliseconds. Any additional arguments are
           * provided to `func` when it is invoked.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @param {...*} [args] The arguments to invoke the function with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.delay(function(text) {
           *   console.log(text);
           * }, 1000, 'later');
           * // => logs 'later' after one second
           */
          var delay = restParam(function (func, wait, args) {
            return baseDelay(func, wait, args);
          });

          /**
           * Creates a function that returns the result of invoking the provided
           * functions with the `this` binding of the created function, where each
           * successive invocation is supplied the return value of the previous.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {...Function} [funcs] Functions to invoke.
           * @returns {Function} Returns the new function.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var addSquare = _.flow(_.add, square);
           * addSquare(1, 2);
           * // => 9
           */
          var flow = createFlow();

          /**
           * This method is like `_.flow` except that it creates a function that
           * invokes the provided functions from right to left.
           *
           * @static
           * @memberOf _
           * @alias backflow, compose
           * @category Function
           * @param {...Function} [funcs] Functions to invoke.
           * @returns {Function} Returns the new function.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var addSquare = _.flowRight(square, _.add);
           * addSquare(1, 2);
           * // => 9
           */
          var flowRight = createFlow(true);

          /**
           * Creates a function that memoizes the result of `func`. If `resolver` is
           * provided it determines the cache key for storing the result based on the
           * arguments provided to the memoized function. By default, the first argument
           * provided to the memoized function is coerced to a string and used as the
           * cache key. The `func` is invoked with the `this` binding of the memoized
           * function.
           *
           * **Note:** The cache is exposed as the `cache` property on the memoized
           * function. Its creation may be customized by replacing the `_.memoize.Cache`
           * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
           * method interface of `get`, `has`, and `set`.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to have its output memoized.
           * @param {Function} [resolver] The function to resolve the cache key.
           * @returns {Function} Returns the new memoizing function.
           * @example
           *
           * var upperCase = _.memoize(function(string) {
           *   return string.toUpperCase();
           * });
           *
           * upperCase('fred');
           * // => 'FRED'
           *
           * // modifying the result cache
           * upperCase.cache.set('fred', 'BARNEY');
           * upperCase('fred');
           * // => 'BARNEY'
           *
           * // replacing `_.memoize.Cache`
           * var object = { 'user': 'fred' };
           * var other = { 'user': 'barney' };
           * var identity = _.memoize(_.identity);
           *
           * identity(object);
           * // => { 'user': 'fred' }
           * identity(other);
           * // => { 'user': 'fred' }
           *
           * _.memoize.Cache = WeakMap;
           * var identity = _.memoize(_.identity);
           *
           * identity(object);
           * // => { 'user': 'fred' }
           * identity(other);
           * // => { 'user': 'barney' }
           */
          function memoize(func, resolver) {
            if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            var memoized = function () {
              var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;

              if (cache.has(key)) {
                return cache.get(key);
              }
              var result = func.apply(this, args);
              memoized.cache = cache.set(key, result);
              return result;
            };
            memoized.cache = new memoize.Cache;
            return memoized;
          }

          /**
           * Creates a function that runs each argument through a corresponding
           * transform function.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to wrap.
           * @param {...(Function|Function[])} [transforms] The functions to transform
           * arguments, specified as individual functions or arrays of functions.
           * @returns {Function} Returns the new function.
           * @example
           *
           * function doubled(n) {
           *   return n * 2;
           * }
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var modded = _.modArgs(function(x, y) {
           *   return [x, y];
           * }, square, doubled);
           *
           * modded(1, 2);
           * // => [1, 4]
           *
           * modded(5, 10);
           * // => [25, 20]
           */
          var modArgs = restParam(function (func, transforms) {
            transforms = baseFlatten(transforms);
            if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            var length = transforms.length;
            return restParam(function (args) {
              var index = nativeMin(args.length, length);
              while (index--) {
                args[index] = transforms[index](args[index]);
              }
              return func.apply(this, args);
            });
          });

          /**
           * Creates a function that negates the result of the predicate `func`. The
           * `func` predicate is invoked with the `this` binding and arguments of the
           * created function.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} predicate The predicate to negate.
           * @returns {Function} Returns the new function.
           * @example
           *
           * function isEven(n) {
           *   return n % 2 == 0;
           * }
           *
           * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
           * // => [1, 3, 5]
           */
          function negate(predicate) {
            if (typeof predicate != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            return function () {
              return !predicate.apply(this, arguments);
            };
          }

          /**
           * Creates a function that is restricted to invoking `func` once. Repeat calls
           * to the function return the value of the first call. The `func` is invoked
           * with the `this` binding and arguments of the created function.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var initialize = _.once(createApplication);
           * initialize();
           * initialize();
           * // `initialize` invokes `createApplication` once
           */
          function once(func) {
            return beforeAll(2, func);
          }

          /**
           * Creates a function that invokes `func` with `partial` arguments prepended
           * to those provided to the new function. This method is like `_.bind` except
           * it does **not** alter the `this` binding.
           *
           * The `_.partial.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * **Note:** This method does not set the "length" property of partially
           * applied functions.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * var greet = function(greeting, name) {
           *   return greeting + ' ' + name;
           * };
           *
           * var sayHelloTo = _.partial(greet, 'hello');
           * sayHelloTo('fred');
           * // => 'hello fred'
           *
           * // using placeholders
           * var greetFred = _.partial(greet, _, 'fred');
           * greetFred('hi');
           * // => 'hi fred'
           */
          var partial = createPartial(PARTIAL_FLAG);

          /**
           * This method is like `_.partial` except that partially applied arguments
           * are appended to those provided to the new function.
           *
           * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * **Note:** This method does not set the "length" property of partially
           * applied functions.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * var greet = function(greeting, name) {
           *   return greeting + ' ' + name;
           * };
           *
           * var greetFred = _.partialRight(greet, 'fred');
           * greetFred('hi');
           * // => 'hi fred'
           *
           * // using placeholders
           * var sayHelloTo = _.partialRight(greet, 'hello', _);
           * sayHelloTo('fred');
           * // => 'hello fred'
           */
          var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

          /**
           * Creates a function that invokes `func` with arguments arranged according
           * to the specified indexes where the argument value at the first index is
           * provided as the first argument, the argument value at the second index is
           * provided as the second argument, and so on.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to rearrange arguments for.
           * @param {...(number|number[])} indexes The arranged argument indexes,
           *  specified as individual indexes or arrays of indexes.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var rearged = _.rearg(function(a, b, c) {
           *   return [a, b, c];
           * }, 2, 0, 1);
           *
           * rearged('b', 'c', 'a')
           * // => ['a', 'b', 'c']
           *
           * var map = _.rearg(_.map, [1, 0]);
           * map(function(n) {
           *   return n * 3;
           * }, [1, 2, 3]);
           * // => [3, 6, 9]
           */
          var rearg = restParam(function (func, indexes) {
            return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
          });

          /**
           * Creates a function that invokes `func` with the `this` binding of the
           * created function and arguments from `start` and beyond provided as an array.
           *
           * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var say = _.restParam(function(what, names) {
           *   return what + ' ' + _.initial(names).join(', ') +
           *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
           * });
           *
           * say('hello', 'fred', 'barney', 'pebbles');
           * // => 'hello fred, barney, & pebbles'
           */
          function restParam(func, start) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
            return function () {
              var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                rest = Array(length);

              while (++index < length) {
                rest[index] = args[start + index];
              }
              switch (start) {
                case 0: return func.call(this, rest);
                case 1: return func.call(this, args[0], rest);
                case 2: return func.call(this, args[0], args[1], rest);
              }
              var otherArgs = Array(start + 1);
              index = -1;
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = rest;
              return func.apply(this, otherArgs);
            };
          }

          /**
           * Creates a function that invokes `func` with the `this` binding of the created
           * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
           *
           * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to spread arguments over.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var say = _.spread(function(who, what) {
           *   return who + ' says ' + what;
           * });
           *
           * say(['fred', 'hello']);
           * // => 'fred says hello'
           *
           * // with a Promise
           * var numbers = Promise.all([
           *   Promise.resolve(40),
           *   Promise.resolve(36)
           * ]);
           *
           * numbers.then(_.spread(function(x, y) {
           *   return x + y;
           * }));
           * // => a Promise of 76
           */
          function spread(func) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            return function (array) {
              return func.apply(this, array);
            };
          }

          /**
           * Creates a throttled function that only invokes `func` at most once per
           * every `wait` milliseconds. The throttled function comes with a `cancel`
           * method to cancel delayed invocations. Provide an options object to indicate
           * that `func` should be invoked on the leading and/or trailing edge of the
           * `wait` timeout. Subsequent calls to the throttled function return the
           * result of the last `func` call.
           *
           * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
           * on the trailing edge of the timeout only if the the throttled function is
           * invoked more than once during the `wait` timeout.
           *
           * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
           * for details over the differences between `_.throttle` and `_.debounce`.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {Function} func The function to throttle.
           * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
           * @param {Object} [options] The options object.
           * @param {boolean} [options.leading=true] Specify invoking on the leading
           *  edge of the timeout.
           * @param {boolean} [options.trailing=true] Specify invoking on the trailing
           *  edge of the timeout.
           * @returns {Function} Returns the new throttled function.
           * @example
           *
           * // avoid excessively updating the position while scrolling
           * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
           *
           * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
           * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
           *   'trailing': false
           * }));
           *
           * // cancel a trailing throttled call
           * jQuery(window).on('popstate', throttled.cancel);
           */
          function throttle(func, wait, options) {
            var leading = true,
              trailing = true;

            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            if (options === false) {
              leading = false;
            } else if (isObject(options)) {
              leading = 'leading' in options ? !!options.leading : leading;
              trailing = 'trailing' in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
          }

          /**
           * Creates a function that provides `value` to the wrapper function as its
           * first argument. Any additional arguments provided to the function are
           * appended to those provided to the wrapper function. The wrapper is invoked
           * with the `this` binding of the created function.
           *
           * @static
           * @memberOf _
           * @category Function
           * @param {*} value The value to wrap.
           * @param {Function} wrapper The wrapper function.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var p = _.wrap(_.escape, function(func, text) {
           *   return '<p>' + func(text) + '</p>';
           * });
           *
           * p('fred, barney, & pebbles');
           * // => '<p>fred, barney, &amp; pebbles</p>'
           */
          function wrap(value, wrapper) {
            wrapper = wrapper == null ? identity : wrapper;
            return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
          }

          /*------------------------------------------------------------------------*/

          /**
           * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
           * otherwise they are assigned by reference. If `customizer` is provided it is
           * invoked to produce the cloned values. If `customizer` returns `undefined`
           * cloning is handled by the method instead. The `customizer` is bound to
           * `thisArg` and invoked with two argument; (value [, index|key, object]).
           *
           * **Note:** This method is loosely based on the
           * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
           * The enumerable properties of `arguments` objects and objects created by
           * constructors other than `Object` are cloned to plain `Object` objects. An
           * empty object is returned for uncloneable values such as functions, DOM nodes,
           * Maps, Sets, and WeakMaps.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @param {Function} [customizer] The function to customize cloning values.
           * @param {*} [thisArg] The `this` binding of `customizer`.
           * @returns {*} Returns the cloned value.
           * @example
           *
           * var users = [
           *   { 'user': 'barney' },
           *   { 'user': 'fred' }
           * ];
           *
           * var shallow = _.clone(users);
           * shallow[0] === users[0];
           * // => true
           *
           * var deep = _.clone(users, true);
           * deep[0] === users[0];
           * // => false
           *
           * // using a customizer callback
           * var el = _.clone(document.body, function(value) {
           *   if (_.isElement(value)) {
           *     return value.cloneNode(false);
           *   }
           * });
           *
           * el === document.body
           * // => false
           * el.nodeName
           * // => BODY
           * el.childNodes.length;
           * // => 0
           */
          function clone(value, isDeep, customizer, thisArg) {
            if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
              isDeep = false;
            }
            else if (typeof isDeep == 'function') {
              thisArg = customizer;
              customizer = isDeep;
              isDeep = false;
            }
            return typeof customizer == 'function'
              ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
              : baseClone(value, isDeep);
          }

          /**
           * Creates a deep clone of `value`. If `customizer` is provided it is invoked
           * to produce the cloned values. If `customizer` returns `undefined` cloning
           * is handled by the method instead. The `customizer` is bound to `thisArg`
           * and invoked with two argument; (value [, index|key, object]).
           *
           * **Note:** This method is loosely based on the
           * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
           * The enumerable properties of `arguments` objects and objects created by
           * constructors other than `Object` are cloned to plain `Object` objects. An
           * empty object is returned for uncloneable values such as functions, DOM nodes,
           * Maps, Sets, and WeakMaps.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to deep clone.
           * @param {Function} [customizer] The function to customize cloning values.
           * @param {*} [thisArg] The `this` binding of `customizer`.
           * @returns {*} Returns the deep cloned value.
           * @example
           *
           * var users = [
           *   { 'user': 'barney' },
           *   { 'user': 'fred' }
           * ];
           *
           * var deep = _.cloneDeep(users);
           * deep[0] === users[0];
           * // => false
           *
           * // using a customizer callback
           * var el = _.cloneDeep(document.body, function(value) {
           *   if (_.isElement(value)) {
           *     return value.cloneNode(true);
           *   }
           * });
           *
           * el === document.body
           * // => false
           * el.nodeName
           * // => BODY
           * el.childNodes.length;
           * // => 20
           */
          function cloneDeep(value, customizer, thisArg) {
            return typeof customizer == 'function'
              ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
              : baseClone(value, true);
          }

          /**
           * Checks if `value` is greater than `other`.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
           * @example
           *
           * _.gt(3, 1);
           * // => true
           *
           * _.gt(3, 3);
           * // => false
           *
           * _.gt(1, 3);
           * // => false
           */
          function gt(value, other) {
            return value > other;
          }

          /**
           * Checks if `value` is greater than or equal to `other`.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
           * @example
           *
           * _.gte(3, 1);
           * // => true
           *
           * _.gte(3, 3);
           * // => true
           *
           * _.gte(1, 3);
           * // => false
           */
          function gte(value, other) {
            return value >= other;
          }

          /**
           * Checks if `value` is classified as an `arguments` object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isArguments(function() { return arguments; }());
           * // => true
           *
           * _.isArguments([1, 2, 3]);
           * // => false
           */
          function isArguments(value) {
            return isObjectLike(value) && isArrayLike(value) &&
              hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
          }

          /**
           * Checks if `value` is classified as an `Array` object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isArray([1, 2, 3]);
           * // => true
           *
           * _.isArray(function() { return arguments; }());
           * // => false
           */
          var isArray = nativeIsArray || function (value) {
            return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
          };

          /**
           * Checks if `value` is classified as a boolean primitive or object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isBoolean(false);
           * // => true
           *
           * _.isBoolean(null);
           * // => false
           */
          function isBoolean(value) {
            return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
          }

          /**
           * Checks if `value` is classified as a `Date` object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isDate(new Date);
           * // => true
           *
           * _.isDate('Mon April 23 2012');
           * // => false
           */
          function isDate(value) {
            return isObjectLike(value) && objToString.call(value) == dateTag;
          }

          /**
           * Checks if `value` is a DOM element.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
           * @example
           *
           * _.isElement(document.body);
           * // => true
           *
           * _.isElement('<body>');
           * // => false
           */
          function isElement(value) {
            return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
          }

          /**
           * Checks if `value` is empty. A value is considered empty unless it is an
           * `arguments` object, array, string, or jQuery-like collection with a length
           * greater than `0` or an object with own enumerable properties.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {Array|Object|string} value The value to inspect.
           * @returns {boolean} Returns `true` if `value` is empty, else `false`.
           * @example
           *
           * _.isEmpty(null);
           * // => true
           *
           * _.isEmpty(true);
           * // => true
           *
           * _.isEmpty(1);
           * // => true
           *
           * _.isEmpty([1, 2, 3]);
           * // => false
           *
           * _.isEmpty({ 'a': 1 });
           * // => false
           */
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
              (isObjectLike(value) && isFunction(value.splice)))) {
              return !value.length;
            }
            return !keys(value).length;
          }

          /**
           * Performs a deep comparison between two values to determine if they are
           * equivalent. If `customizer` is provided it is invoked to compare values.
           * If `customizer` returns `undefined` comparisons are handled by the method
           * instead. The `customizer` is bound to `thisArg` and invoked with three
           * arguments: (value, other [, index|key]).
           *
           * **Note:** This method supports comparing arrays, booleans, `Date` objects,
           * numbers, `Object` objects, regexes, and strings. Objects are compared by
           * their own, not inherited, enumerable properties. Functions and DOM nodes
           * are **not** supported. Provide a customizer function to extend support
           * for comparing other values.
           *
           * @static
           * @memberOf _
           * @alias eq
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @param {Function} [customizer] The function to customize value comparisons.
           * @param {*} [thisArg] The `this` binding of `customizer`.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'user': 'fred' };
           * var other = { 'user': 'fred' };
           *
           * object == other;
           * // => false
           *
           * _.isEqual(object, other);
           * // => true
           *
           * // using a customizer callback
           * var array = ['hello', 'goodbye'];
           * var other = ['hi', 'goodbye'];
           *
           * _.isEqual(array, other, function(value, other) {
           *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
           *     return true;
           *   }
           * });
           * // => true
           */
          function isEqual(value, other, customizer, thisArg) {
            customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
            var result = customizer ? customizer(value, other) : undefined;
            return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
          }

          /**
           * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
           * `SyntaxError`, `TypeError`, or `URIError` object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
           * @example
           *
           * _.isError(new Error);
           * // => true
           *
           * _.isError(Error);
           * // => false
           */
          function isError(value) {
            return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
          }

          /**
           * Checks if `value` is a finite primitive number.
           *
           * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
           * @example
           *
           * _.isFinite(10);
           * // => true
           *
           * _.isFinite('10');
           * // => false
           *
           * _.isFinite(true);
           * // => false
           *
           * _.isFinite(Object(10));
           * // => false
           *
           * _.isFinite(Infinity);
           * // => false
           */
          function isFinite(value) {
            return typeof value == 'number' && nativeIsFinite(value);
          }

          /**
           * Checks if `value` is classified as a `Function` object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isFunction(_);
           * // => true
           *
           * _.isFunction(/abc/);
           * // => false
           */
          function isFunction(value) {
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in older versions of Chrome and Safari which return 'function' for regexes
            // and Safari 8 equivalents which return 'object' for typed array constructors.
            return isObject(value) && objToString.call(value) == funcTag;
          }

          /**
           * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
           * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an object, else `false`.
           * @example
           *
           * _.isObject({});
           * // => true
           *
           * _.isObject([1, 2, 3]);
           * // => true
           *
           * _.isObject(1);
           * // => false
           */
          function isObject(value) {
            // Avoid a V8 JIT bug in Chrome 19-20.
            // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
            var type = typeof value;
            return !!value && (type == 'object' || type == 'function');
          }

          /**
           * Performs a deep comparison between `object` and `source` to determine if
           * `object` contains equivalent property values. If `customizer` is provided
           * it is invoked to compare values. If `customizer` returns `undefined`
           * comparisons are handled by the method instead. The `customizer` is bound
           * to `thisArg` and invoked with three arguments: (value, other, index|key).
           *
           * **Note:** This method supports comparing properties of arrays, booleans,
           * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
           * and DOM nodes are **not** supported. Provide a customizer function to extend
           * support for comparing other values.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property values to match.
           * @param {Function} [customizer] The function to customize value comparisons.
           * @param {*} [thisArg] The `this` binding of `customizer`.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           * @example
           *
           * var object = { 'user': 'fred', 'age': 40 };
           *
           * _.isMatch(object, { 'age': 40 });
           * // => true
           *
           * _.isMatch(object, { 'age': 36 });
           * // => false
           *
           * // using a customizer callback
           * var object = { 'greeting': 'hello' };
           * var source = { 'greeting': 'hi' };
           *
           * _.isMatch(object, source, function(value, other) {
           *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
           * });
           * // => true
           */
          function isMatch(object, source, customizer, thisArg) {
            customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
            return baseIsMatch(object, getMatchData(source), customizer);
          }

          /**
           * Checks if `value` is `NaN`.
           *
           * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
           * which returns `true` for `undefined` and other non-numeric values.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
           * @example
           *
           * _.isNaN(NaN);
           * // => true
           *
           * _.isNaN(new Number(NaN));
           * // => true
           *
           * isNaN(undefined);
           * // => true
           *
           * _.isNaN(undefined);
           * // => false
           */
          function isNaN(value) {
            // An `NaN` primitive is the only value that is not equal to itself.
            // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
            return isNumber(value) && value != +value;
          }

          /**
           * Checks if `value` is a native function.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
           * @example
           *
           * _.isNative(Array.prototype.push);
           * // => true
           *
           * _.isNative(_);
           * // => false
           */
          function isNative(value) {
            if (value == null) {
              return false;
            }
            if (isFunction(value)) {
              return reIsNative.test(fnToString.call(value));
            }
            return isObjectLike(value) && reIsHostCtor.test(value);
          }

          /**
           * Checks if `value` is `null`.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
           * @example
           *
           * _.isNull(null);
           * // => true
           *
           * _.isNull(void 0);
           * // => false
           */
          function isNull(value) {
            return value === null;
          }

          /**
           * Checks if `value` is classified as a `Number` primitive or object.
           *
           * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
           * as numbers, use the `_.isFinite` method.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isNumber(8.4);
           * // => true
           *
           * _.isNumber(NaN);
           * // => true
           *
           * _.isNumber('8.4');
           * // => false
           */
          function isNumber(value) {
            return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
          }

          /**
           * Checks if `value` is a plain object, that is, an object created by the
           * `Object` constructor or one with a `[[Prototype]]` of `null`.
           *
           * **Note:** This method assumes objects created by the `Object` constructor
           * have no inherited enumerable properties.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * _.isPlainObject(new Foo);
           * // => false
           *
           * _.isPlainObject([1, 2, 3]);
           * // => false
           *
           * _.isPlainObject({ 'x': 0, 'y': 0 });
           * // => true
           *
           * _.isPlainObject(Object.create(null));
           * // => true
           */
          function isPlainObject(value) {
            var Ctor;

            // Exit early for non `Object` objects.
            if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
              (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
              return false;
            }
            // IE < 9 iterates inherited properties before own properties. If the first
            // iterated property is an object's own property then there are no inherited
            // enumerable properties.
            var result;
            // In most environments an object's own properties are iterated before
            // its inherited properties. If the last iterated property is an object's
            // own property then there are no inherited enumerable properties.
            baseForIn(value, function (subValue, key) {
              result = key;
            });
            return result === undefined || hasOwnProperty.call(value, result);
          }

          /**
           * Checks if `value` is classified as a `RegExp` object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isRegExp(/abc/);
           * // => true
           *
           * _.isRegExp('/abc/');
           * // => false
           */
          function isRegExp(value) {
            return isObject(value) && objToString.call(value) == regexpTag;
          }

          /**
           * Checks if `value` is classified as a `String` primitive or object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isString('abc');
           * // => true
           *
           * _.isString(1);
           * // => false
           */
          function isString(value) {
            return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
          }

          /**
           * Checks if `value` is classified as a typed array.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
           * @example
           *
           * _.isTypedArray(new Uint8Array);
           * // => true
           *
           * _.isTypedArray([]);
           * // => false
           */
          function isTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
          }

          /**
           * Checks if `value` is `undefined`.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
           * @example
           *
           * _.isUndefined(void 0);
           * // => true
           *
           * _.isUndefined(null);
           * // => false
           */
          function isUndefined(value) {
            return value === undefined;
          }

          /**
           * Checks if `value` is less than `other`.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
           * @example
           *
           * _.lt(1, 3);
           * // => true
           *
           * _.lt(3, 3);
           * // => false
           *
           * _.lt(3, 1);
           * // => false
           */
          function lt(value, other) {
            return value < other;
          }

          /**
           * Checks if `value` is less than or equal to `other`.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
           * @example
           *
           * _.lte(1, 3);
           * // => true
           *
           * _.lte(3, 3);
           * // => true
           *
           * _.lte(3, 1);
           * // => false
           */
          function lte(value, other) {
            return value <= other;
          }

          /**
           * Converts `value` to an array.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {Array} Returns the converted array.
           * @example
           *
           * (function() {
           *   return _.toArray(arguments).slice(1);
           * }(1, 2, 3));
           * // => [2, 3]
           */
          function toArray(value) {
            var length = value ? getLength(value) : 0;
            if (!isLength(length)) {
              return values(value);
            }
            if (!length) {
              return [];
            }
            return arrayCopy(value);
          }

          /**
           * Converts `value` to a plain object flattening inherited enumerable
           * properties of `value` to own properties of the plain object.
           *
           * @static
           * @memberOf _
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {Object} Returns the converted plain object.
           * @example
           *
           * function Foo() {
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.assign({ 'a': 1 }, new Foo);
           * // => { 'a': 1, 'b': 2 }
           *
           * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
           * // => { 'a': 1, 'b': 2, 'c': 3 }
           */
          function toPlainObject(value) {
            return baseCopy(value, keysIn(value));
          }

          /*------------------------------------------------------------------------*/

          /**
           * Recursively merges own enumerable properties of the source object(s), that
           * don't resolve to `undefined` into the destination object. Subsequent sources
           * overwrite property assignments of previous sources. If `customizer` is
           * provided it is invoked to produce the merged values of the destination and
           * source properties. If `customizer` returns `undefined` merging is handled
           * by the method instead. The `customizer` is bound to `thisArg` and invoked
           * with five arguments: (objectValue, sourceValue, key, object, source).
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @param {Function} [customizer] The function to customize assigned values.
           * @param {*} [thisArg] The `this` binding of `customizer`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var users = {
           *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
           * };
           *
           * var ages = {
           *   'data': [{ 'age': 36 }, { 'age': 40 }]
           * };
           *
           * _.merge(users, ages);
           * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
           *
           * // using a customizer callback
           * var object = {
           *   'fruits': ['apple'],
           *   'vegetables': ['beet']
           * };
           *
           * var other = {
           *   'fruits': ['banana'],
           *   'vegetables': ['carrot']
           * };
           *
           * _.merge(object, other, function(a, b) {
           *   if (_.isArray(a)) {
           *     return a.concat(b);
           *   }
           * });
           * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
           */
          var merge = createAssigner(baseMerge);

          /**
           * Assigns own enumerable properties of source object(s) to the destination
           * object. Subsequent sources overwrite property assignments of previous sources.
           * If `customizer` is provided it is invoked to produce the assigned values.
           * The `customizer` is bound to `thisArg` and invoked with five arguments:
           * (objectValue, sourceValue, key, object, source).
           *
           * **Note:** This method mutates `object` and is based on
           * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
           *
           * @static
           * @memberOf _
           * @alias extend
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @param {Function} [customizer] The function to customize assigned values.
           * @param {*} [thisArg] The `this` binding of `customizer`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
           * // => { 'user': 'fred', 'age': 40 }
           *
           * // using a customizer callback
           * var defaults = _.partialRight(_.assign, function(value, other) {
           *   return _.isUndefined(value) ? other : value;
           * });
           *
           * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
           * // => { 'user': 'barney', 'age': 36 }
           */
          var assign = createAssigner(function (object, source, customizer) {
            return customizer
              ? assignWith(object, source, customizer)
              : baseAssign(object, source);
          });

          /**
           * Creates an object that inherits from the given `prototype` object. If a
           * `properties` object is provided its own enumerable properties are assigned
           * to the created object.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} prototype The object to inherit from.
           * @param {Object} [properties] The properties to assign to the object.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Object} Returns the new object.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * function Circle() {
           *   Shape.call(this);
           * }
           *
           * Circle.prototype = _.create(Shape.prototype, {
           *   'constructor': Circle
           * });
           *
           * var circle = new Circle;
           * circle instanceof Circle;
           * // => true
           *
           * circle instanceof Shape;
           * // => true
           */
          function create(prototype, properties, guard) {
            var result = baseCreate(prototype);
            if (guard && isIterateeCall(prototype, properties, guard)) {
              properties = undefined;
            }
            return properties ? baseAssign(result, properties) : result;
          }

          /**
           * Assigns own enumerable properties of source object(s) to the destination
           * object for all destination properties that resolve to `undefined`. Once a
           * property is set, additional values of the same property are ignored.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @example
           *
           * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
           * // => { 'user': 'barney', 'age': 36 }
           */
          var defaults = createDefaults(assign, assignDefaults);

          /**
           * This method is like `_.defaults` except that it recursively assigns
           * default properties.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @example
           *
           * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
           * // => { 'user': { 'name': 'barney', 'age': 36 } }
           *
           */
          var defaultsDeep = createDefaults(merge, mergeDefaults);

          /**
           * This method is like `_.find` except that it returns the key of the first
           * element `predicate` returns truthy for instead of the element itself.
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to search.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
           * @example
           *
           * var users = {
           *   'barney':  { 'age': 36, 'active': true },
           *   'fred':    { 'age': 40, 'active': false },
           *   'pebbles': { 'age': 1,  'active': true }
           * };
           *
           * _.findKey(users, function(chr) {
           *   return chr.age < 40;
           * });
           * // => 'barney' (iteration order is not guaranteed)
           *
           * // using the `_.matches` callback shorthand
           * _.findKey(users, { 'age': 1, 'active': true });
           * // => 'pebbles'
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.findKey(users, 'active', false);
           * // => 'fred'
           *
           * // using the `_.property` callback shorthand
           * _.findKey(users, 'active');
           * // => 'barney'
           */
          var findKey = createFindKey(baseForOwn);

          /**
           * This method is like `_.findKey` except that it iterates over elements of
           * a collection in the opposite order.
           *
           * If a property name is provided for `predicate` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `predicate` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to search.
           * @param {Function|Object|string} [predicate=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
           * @example
           *
           * var users = {
           *   'barney':  { 'age': 36, 'active': true },
           *   'fred':    { 'age': 40, 'active': false },
           *   'pebbles': { 'age': 1,  'active': true }
           * };
           *
           * _.findLastKey(users, function(chr) {
           *   return chr.age < 40;
           * });
           * // => returns `pebbles` assuming `_.findKey` returns `barney`
           *
           * // using the `_.matches` callback shorthand
           * _.findLastKey(users, { 'age': 36, 'active': true });
           * // => 'barney'
           *
           * // using the `_.matchesProperty` callback shorthand
           * _.findLastKey(users, 'active', false);
           * // => 'fred'
           *
           * // using the `_.property` callback shorthand
           * _.findLastKey(users, 'active');
           * // => 'pebbles'
           */
          var findLastKey = createFindKey(baseForOwnRight);

          /**
           * Iterates over own and inherited enumerable properties of an object invoking
           * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
           * with three arguments: (value, key, object). Iteratee functions may exit
           * iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forIn(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
           */
          var forIn = createForIn(baseFor);

          /**
           * This method is like `_.forIn` except that it iterates over properties of
           * `object` in the opposite order.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forInRight(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
           */
          var forInRight = createForIn(baseForRight);

          /**
           * Iterates over own enumerable properties of an object invoking `iteratee`
           * for each property. The `iteratee` is bound to `thisArg` and invoked with
           * three arguments: (value, key, object). Iteratee functions may exit iteration
           * early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forOwn(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => logs 'a' and 'b' (iteration order is not guaranteed)
           */
          var forOwn = createForOwn(baseForOwn);

          /**
           * This method is like `_.forOwn` except that it iterates over properties of
           * `object` in the opposite order.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forOwnRight(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
           */
          var forOwnRight = createForOwn(baseForOwnRight);

          /**
           * Creates an array of function property names from all enumerable properties,
           * own and inherited, of `object`.
           *
           * @static
           * @memberOf _
           * @alias methods
           * @category Object
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns the new array of property names.
           * @example
           *
           * _.functions(_);
           * // => ['after', 'ary', 'assign', ...]
           */
          function functions(object) {
            return baseFunctions(object, keysIn(object));
          }

          /**
           * Gets the property value at `path` of `object`. If the resolved value is
           * `undefined` the `defaultValue` is used in its place.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to get.
           * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.get(object, 'a[0].b.c');
           * // => 3
           *
           * _.get(object, ['a', '0', 'b', 'c']);
           * // => 3
           *
           * _.get(object, 'a.b.c', 'default');
           * // => 'default'
           */
          function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
            return result === undefined ? defaultValue : result;
          }

          /**
           * Checks if `path` is a direct property.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path to check.
           * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
           * @example
           *
           * var object = { 'a': { 'b': { 'c': 3 } } };
           *
           * _.has(object, 'a');
           * // => true
           *
           * _.has(object, 'a.b.c');
           * // => true
           *
           * _.has(object, ['a', 'b', 'c']);
           * // => true
           */
          function has(object, path) {
            if (object == null) {
              return false;
            }
            var result = hasOwnProperty.call(object, path);
            if (!result && !isKey(path)) {
              path = toPath(path);
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              if (object == null) {
                return false;
              }
              path = last(path);
              result = hasOwnProperty.call(object, path);
            }
            return result || (isLength(object.length) && isIndex(path, object.length) &&
              (isArray(object) || isArguments(object)));
          }

          /**
           * Creates an object composed of the inverted keys and values of `object`.
           * If `object` contains duplicate values, subsequent values overwrite property
           * assignments of previous values unless `multiValue` is `true`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to invert.
           * @param {boolean} [multiValue] Allow multiple values per key.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Object} Returns the new inverted object.
           * @example
           *
           * var object = { 'a': 1, 'b': 2, 'c': 1 };
           *
           * _.invert(object);
           * // => { '1': 'c', '2': 'b' }
           *
           * // with `multiValue`
           * _.invert(object, true);
           * // => { '1': ['a', 'c'], '2': ['b'] }
           */
          function invert(object, multiValue, guard) {
            if (guard && isIterateeCall(object, multiValue, guard)) {
              multiValue = undefined;
            }
            var index = -1,
              props = keys(object),
              length = props.length,
              result = {};

            while (++index < length) {
              var key = props[index],
                value = object[key];

              if (multiValue) {
                if (hasOwnProperty.call(result, value)) {
                  result[value].push(key);
                } else {
                  result[value] = [key];
                }
              }
              else {
                result[value] = key;
              }
            }
            return result;
          }

          /**
           * Creates an array of the own enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects. See the
           * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
           * for more details.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keys(new Foo);
           * // => ['a', 'b'] (iteration order is not guaranteed)
           *
           * _.keys('hi');
           * // => ['0', '1']
           */
          var keys = !nativeKeys ? shimKeys : function (object) {
            var Ctor = object == null ? undefined : object.constructor;
            if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
              (typeof object != 'function' && isArrayLike(object))) {
              return shimKeys(object);
            }
            return isObject(object) ? nativeKeys(object) : [];
          };

          /**
           * Creates an array of the own and inherited enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keysIn(new Foo);
           * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
           */
          function keysIn(object) {
            if (object == null) {
              return [];
            }
            if (!isObject(object)) {
              object = Object(object);
            }
            var length = object.length;
            length = (length && isLength(length) &&
              (isArray(object) || isArguments(object)) && length) || 0;

            var Ctor = object.constructor,
              index = -1,
              isProto = typeof Ctor == 'function' && Ctor.prototype === object,
              result = Array(length),
              skipIndexes = length > 0;

            while (++index < length) {
              result[index] = (index + '');
            }
            for (var key in object) {
              if (!(skipIndexes && isIndex(key, length)) &&
                !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * The opposite of `_.mapValues`; this method creates an object with the
           * same values as `object` and keys generated by running each own enumerable
           * property of `object` through `iteratee`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns the new mapped object.
           * @example
           *
           * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
           *   return key + value;
           * });
           * // => { 'a1': 1, 'b2': 2 }
           */
          var mapKeys = createObjectMapper(true);

          /**
           * Creates an object with the same keys as `object` and values generated by
           * running each own enumerable property of `object` through `iteratee`. The
           * iteratee function is bound to `thisArg` and invoked with three arguments:
           * (value, key, object).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function|Object|string} [iteratee=_.identity] The function invoked
           *  per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Object} Returns the new mapped object.
           * @example
           *
           * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
           *   return n * 3;
           * });
           * // => { 'a': 3, 'b': 6 }
           *
           * var users = {
           *   'fred':    { 'user': 'fred',    'age': 40 },
           *   'pebbles': { 'user': 'pebbles', 'age': 1 }
           * };
           *
           * // using the `_.property` callback shorthand
           * _.mapValues(users, 'age');
           * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
           */
          var mapValues = createObjectMapper();

          /**
           * The opposite of `_.pick`; this method creates an object composed of the
           * own and inherited enumerable properties of `object` that are not omitted.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The source object.
           * @param {Function|...(string|string[])} [predicate] The function invoked per
           *  iteration or property names to omit, specified as individual property
           *  names or arrays of property names.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'user': 'fred', 'age': 40 };
           *
           * _.omit(object, 'age');
           * // => { 'user': 'fred' }
           *
           * _.omit(object, _.isNumber);
           * // => { 'user': 'fred' }
           */
          var omit = restParam(function (object, props) {
            if (object == null) {
              return {};
            }
            if (typeof props[0] != 'function') {
              var props = arrayMap(baseFlatten(props), String);
              return pickByArray(object, baseDifference(keysIn(object), props));
            }
            var predicate = bindCallback(props[0], props[1], 3);
            return pickByCallback(object, function (value, key, object) {
              return !predicate(value, key, object);
            });
          });

          /**
           * Creates a two dimensional array of the key-value pairs for `object`,
           * e.g. `[[key1, value1], [key2, value2]]`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the new array of key-value pairs.
           * @example
           *
           * _.pairs({ 'barney': 36, 'fred': 40 });
           * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
           */
          function pairs(object) {
            object = toObject(object);

            var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);

            while (++index < length) {
              var key = props[index];
              result[index] = [key, object[key]];
            }
            return result;
          }

          /**
           * Creates an object composed of the picked `object` properties. Property
           * names may be specified as individual arguments or as arrays of property
           * names. If `predicate` is provided it is invoked for each property of `object`
           * picking the properties `predicate` returns truthy for. The predicate is
           * bound to `thisArg` and invoked with three arguments: (value, key, object).
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The source object.
           * @param {Function|...(string|string[])} [predicate] The function invoked per
           *  iteration or property names to pick, specified as individual property
           *  names or arrays of property names.
           * @param {*} [thisArg] The `this` binding of `predicate`.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'user': 'fred', 'age': 40 };
           *
           * _.pick(object, 'user');
           * // => { 'user': 'fred' }
           *
           * _.pick(object, _.isString);
           * // => { 'user': 'fred' }
           */
          var pick = restParam(function (object, props) {
            if (object == null) {
              return {};
            }
            return typeof props[0] == 'function'
              ? pickByCallback(object, bindCallback(props[0], props[1], 3))
              : pickByArray(object, baseFlatten(props));
          });

          /**
           * This method is like `_.get` except that if the resolved value is a function
           * it is invoked with the `this` binding of its parent object and its result
           * is returned.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to resolve.
           * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
           *
           * _.result(object, 'a[0].b.c1');
           * // => 3
           *
           * _.result(object, 'a[0].b.c2');
           * // => 4
           *
           * _.result(object, 'a.b.c', 'default');
           * // => 'default'
           *
           * _.result(object, 'a.b.c', _.constant('default'));
           * // => 'default'
           */
          function result(object, path, defaultValue) {
            var result = object == null ? undefined : object[path];
            if (result === undefined) {
              if (object != null && !isKey(path, object)) {
                path = toPath(path);
                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                result = object == null ? undefined : object[last(path)];
              }
              result = result === undefined ? defaultValue : result;
            }
            return isFunction(result) ? result.call(object) : result;
          }

          /**
           * Sets the property value of `path` on `object`. If a portion of `path`
           * does not exist it is created.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to augment.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.set(object, 'a[0].b.c', 4);
           * console.log(object.a[0].b.c);
           * // => 4
           *
           * _.set(object, 'x[0].y.z', 5);
           * console.log(object.x[0].y.z);
           * // => 5
           */
          function set(object, path, value) {
            if (object == null) {
              return object;
            }
            var pathKey = (path + '');
            path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

            var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;

            while (nested != null && ++index < length) {
              var key = path[index];
              if (isObject(nested)) {
                if (index == lastIndex) {
                  nested[key] = value;
                } else if (nested[key] == null) {
                  nested[key] = isIndex(path[index + 1]) ? [] : {};
                }
              }
              nested = nested[key];
            }
            return object;
          }

          /**
           * An alternative to `_.reduce`; this method transforms `object` to a new
           * `accumulator` object which is the result of running each of its own enumerable
           * properties through `iteratee`, with each invocation potentially mutating
           * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
           * with four arguments: (accumulator, value, key, object). Iteratee functions
           * may exit iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Array|Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The custom accumulator value.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * _.transform([2, 3, 4], function(result, n) {
           *   result.push(n *= n);
           *   return n % 2 == 0;
           * });
           * // => [4, 9]
           *
           * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
           *   result[key] = n * 3;
           * });
           * // => { 'a': 3, 'b': 6 }
           */
          function transform(object, iteratee, accumulator, thisArg) {
            var isArr = isArray(object) || isTypedArray(object);
            iteratee = getCallback(iteratee, thisArg, 4);

            if (accumulator == null) {
              if (isArr || isObject(object)) {
                var Ctor = object.constructor;
                if (isArr) {
                  accumulator = isArray(object) ? new Ctor : [];
                } else {
                  accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
                }
              } else {
                accumulator = {};
              }
            }
            (isArr ? arrayEach : baseForOwn)(object, function (value, index, object) {
              return iteratee(accumulator, value, index, object);
            });
            return accumulator;
          }

          /**
           * Creates an array of the own enumerable property values of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property values.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.values(new Foo);
           * // => [1, 2] (iteration order is not guaranteed)
           *
           * _.values('hi');
           * // => ['h', 'i']
           */
          function values(object) {
            return baseValues(object, keys(object));
          }

          /**
           * Creates an array of the own and inherited enumerable property values
           * of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property values.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.valuesIn(new Foo);
           * // => [1, 2, 3] (iteration order is not guaranteed)
           */
          function valuesIn(object) {
            return baseValues(object, keysIn(object));
          }

          /*------------------------------------------------------------------------*/

          /**
           * Checks if `n` is between `start` and up to but not including, `end`. If
           * `end` is not specified it is set to `start` with `start` then set to `0`.
           *
           * @static
           * @memberOf _
           * @category Number
           * @param {number} n The number to check.
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
           * @example
           *
           * _.inRange(3, 2, 4);
           * // => true
           *
           * _.inRange(4, 8);
           * // => true
           *
           * _.inRange(4, 2);
           * // => false
           *
           * _.inRange(2, 2);
           * // => false
           *
           * _.inRange(1.2, 2);
           * // => true
           *
           * _.inRange(5.2, 4);
           * // => false
           */
          function inRange(value, start, end) {
            start = +start || 0;
            if (end === undefined) {
              end = start;
              start = 0;
            } else {
              end = +end || 0;
            }
            return value >= nativeMin(start, end) && value < nativeMax(start, end);
          }

          /**
           * Produces a random number between `min` and `max` (inclusive). If only one
           * argument is provided a number between `0` and the given number is returned.
           * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
           * number is returned instead of an integer.
           *
           * @static
           * @memberOf _
           * @category Number
           * @param {number} [min=0] The minimum possible value.
           * @param {number} [max=1] The maximum possible value.
           * @param {boolean} [floating] Specify returning a floating-point number.
           * @returns {number} Returns the random number.
           * @example
           *
           * _.random(0, 5);
           * // => an integer between 0 and 5
           *
           * _.random(5);
           * // => also an integer between 0 and 5
           *
           * _.random(5, true);
           * // => a floating-point number between 0 and 5
           *
           * _.random(1.2, 5.2);
           * // => a floating-point number between 1.2 and 5.2
           */
          function random(min, max, floating) {
            if (floating && isIterateeCall(min, max, floating)) {
              max = floating = undefined;
            }
            var noMin = min == null,
              noMax = max == null;

            if (floating == null) {
              if (noMax && typeof min == 'boolean') {
                floating = min;
                min = 1;
              }
              else if (typeof max == 'boolean') {
                floating = max;
                noMax = true;
              }
            }
            if (noMin && noMax) {
              max = 1;
              noMax = false;
            }
            min = +min || 0;
            if (noMax) {
              max = min;
              min = 0;
            } else {
              max = +max || 0;
            }
            if (floating || min % 1 || max % 1) {
              var rand = nativeRandom();
              return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
            }
            return baseRandom(min, max);
          }

          /*------------------------------------------------------------------------*/

          /**
           * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the camel cased string.
           * @example
           *
           * _.camelCase('Foo Bar');
           * // => 'fooBar'
           *
           * _.camelCase('--foo-bar');
           * // => 'fooBar'
           *
           * _.camelCase('__foo_bar__');
           * // => 'fooBar'
           */
          var camelCase = createCompounder(function (result, word, index) {
            word = word.toLowerCase();
            return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
          });

          /**
           * Capitalizes the first character of `string`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to capitalize.
           * @returns {string} Returns the capitalized string.
           * @example
           *
           * _.capitalize('fred');
           * // => 'Fred'
           */
          function capitalize(string) {
            string = baseToString(string);
            return string && (string.charAt(0).toUpperCase() + string.slice(1));
          }

          /**
           * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
           * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to deburr.
           * @returns {string} Returns the deburred string.
           * @example
           *
           * _.deburr('déjà vu');
           * // => 'deja vu'
           */
          function deburr(string) {
            string = baseToString(string);
            return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
          }

          /**
           * Checks if `string` ends with the given target string.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to search.
           * @param {string} [target] The string to search for.
           * @param {number} [position=string.length] The position to search from.
           * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
           * @example
           *
           * _.endsWith('abc', 'c');
           * // => true
           *
           * _.endsWith('abc', 'b');
           * // => false
           *
           * _.endsWith('abc', 'b', 2);
           * // => true
           */
          function endsWith(string, target, position) {
            string = baseToString(string);
            target = (target + '');

            var length = string.length;
            position = position === undefined
              ? length
              : nativeMin(position < 0 ? 0 : (+position || 0), length);

            position -= target.length;
            return position >= 0 && string.indexOf(target, position) == position;
          }

          /**
           * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
           * their corresponding HTML entities.
           *
           * **Note:** No other characters are escaped. To escape additional characters
           * use a third-party library like [_he_](https://mths.be/he).
           *
           * Though the ">" character is escaped for symmetry, characters like
           * ">" and "/" don't need escaping in HTML and have no special meaning
           * unless they're part of a tag or unquoted attribute value.
           * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
           * (under "semi-related fun fact") for more details.
           *
           * Backticks are escaped because in Internet Explorer < 9, they can break out
           * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
           * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
           * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
           * for more details.
           *
           * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
           * to reduce XSS vectors.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to escape.
           * @returns {string} Returns the escaped string.
           * @example
           *
           * _.escape('fred, barney, & pebbles');
           * // => 'fred, barney, &amp; pebbles'
           */
          function escape(string) {
            // Reset `lastIndex` because in IE < 9 `String#replace` does not.
            string = baseToString(string);
            return (string && reHasUnescapedHtml.test(string))
              ? string.replace(reUnescapedHtml, escapeHtmlChar)
              : string;
          }

          /**
           * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
           * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to escape.
           * @returns {string} Returns the escaped string.
           * @example
           *
           * _.escapeRegExp('[lodash](https://lodash.com/)');
           * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
           */
          function escapeRegExp(string) {
            string = baseToString(string);
            return (string && reHasRegExpChars.test(string))
              ? string.replace(reRegExpChars, escapeRegExpChar)
              : (string || '(?:)');
          }

          /**
           * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the kebab cased string.
           * @example
           *
           * _.kebabCase('Foo Bar');
           * // => 'foo-bar'
           *
           * _.kebabCase('fooBar');
           * // => 'foo-bar'
           *
           * _.kebabCase('__foo_bar__');
           * // => 'foo-bar'
           */
          var kebabCase = createCompounder(function (result, word, index) {
            return result + (index ? '-' : '') + word.toLowerCase();
          });

          /**
           * Pads `string` on the left and right sides if it's shorter than `length`.
           * Padding characters are truncated if they can't be evenly divided by `length`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.pad('abc', 8);
           * // => '  abc   '
           *
           * _.pad('abc', 8, '_-');
           * // => '_-abc_-_'
           *
           * _.pad('abc', 3);
           * // => 'abc'
           */
          function pad(string, length, chars) {
            string = baseToString(string);
            length = +length;

            var strLength = string.length;
            if (strLength >= length || !nativeIsFinite(length)) {
              return string;
            }
            var mid = (length - strLength) / 2,
              leftLength = nativeFloor(mid),
              rightLength = nativeCeil(mid);

            chars = createPadding('', rightLength, chars);
            return chars.slice(0, leftLength) + string + chars;
          }

          /**
           * Pads `string` on the left side if it's shorter than `length`. Padding
           * characters are truncated if they exceed `length`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.padLeft('abc', 6);
           * // => '   abc'
           *
           * _.padLeft('abc', 6, '_-');
           * // => '_-_abc'
           *
           * _.padLeft('abc', 3);
           * // => 'abc'
           */
          var padLeft = createPadDir();

          /**
           * Pads `string` on the right side if it's shorter than `length`. Padding
           * characters are truncated if they exceed `length`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.padRight('abc', 6);
           * // => 'abc   '
           *
           * _.padRight('abc', 6, '_-');
           * // => 'abc_-_'
           *
           * _.padRight('abc', 3);
           * // => 'abc'
           */
          var padRight = createPadDir(true);

          /**
           * Converts `string` to an integer of the specified radix. If `radix` is
           * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
           * in which case a `radix` of `16` is used.
           *
           * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
           * of `parseInt`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} string The string to convert.
           * @param {number} [radix] The radix to interpret `value` by.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.parseInt('08');
           * // => 8
           *
           * _.map(['6', '08', '10'], _.parseInt);
           * // => [6, 8, 10]
           */
          function parseInt(string, radix, guard) {
            // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
            // Chrome fails to trim leading <BOM> whitespace characters.
            // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
            if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            string = trim(string);
            return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
          }

          /**
           * Repeats the given string `n` times.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to repeat.
           * @param {number} [n=0] The number of times to repeat the string.
           * @returns {string} Returns the repeated string.
           * @example
           *
           * _.repeat('*', 3);
           * // => '***'
           *
           * _.repeat('abc', 2);
           * // => 'abcabc'
           *
           * _.repeat('abc', 0);
           * // => ''
           */
          function repeat(string, n) {
            var result = '';
            string = baseToString(string);
            n = +n;
            if (n < 1 || !string || !nativeIsFinite(n)) {
              return result;
            }
            // Leverage the exponentiation by squaring algorithm for a faster repeat.
            // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
            do {
              if (n % 2) {
                result += string;
              }
              n = nativeFloor(n / 2);
              string += string;
            } while (n);

            return result;
          }

          /**
           * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the snake cased string.
           * @example
           *
           * _.snakeCase('Foo Bar');
           * // => 'foo_bar'
           *
           * _.snakeCase('fooBar');
           * // => 'foo_bar'
           *
           * _.snakeCase('--foo-bar');
           * // => 'foo_bar'
           */
          var snakeCase = createCompounder(function (result, word, index) {
            return result + (index ? '_' : '') + word.toLowerCase();
          });

          /**
           * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the start cased string.
           * @example
           *
           * _.startCase('--foo-bar');
           * // => 'Foo Bar'
           *
           * _.startCase('fooBar');
           * // => 'Foo Bar'
           *
           * _.startCase('__foo_bar__');
           * // => 'Foo Bar'
           */
          var startCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
          });

          /**
           * Checks if `string` starts with the given target string.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to search.
           * @param {string} [target] The string to search for.
           * @param {number} [position=0] The position to search from.
           * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
           * @example
           *
           * _.startsWith('abc', 'a');
           * // => true
           *
           * _.startsWith('abc', 'b');
           * // => false
           *
           * _.startsWith('abc', 'b', 1);
           * // => true
           */
          function startsWith(string, target, position) {
            string = baseToString(string);
            position = position == null
              ? 0
              : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

            return string.lastIndexOf(target, position) == position;
          }

          /**
           * Creates a compiled template function that can interpolate data properties
           * in "interpolate" delimiters, HTML-escape interpolated data properties in
           * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
           * properties may be accessed as free variables in the template. If a setting
           * object is provided it takes precedence over `_.templateSettings` values.
           *
           * **Note:** In the development build `_.template` utilizes
           * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
           * for easier debugging.
           *
           * For more information on precompiling templates see
           * [lodash's custom builds documentation](https://lodash.com/custom-builds).
           *
           * For more information on Chrome extension sandboxes see
           * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The template string.
           * @param {Object} [options] The options object.
           * @param {RegExp} [options.escape] The HTML "escape" delimiter.
           * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
           * @param {Object} [options.imports] An object to import into the template as free variables.
           * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
           * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
           * @param {string} [options.variable] The data object variable name.
           * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
           * @returns {Function} Returns the compiled template function.
           * @example
           *
           * // using the "interpolate" delimiter to create a compiled template
           * var compiled = _.template('hello <%= user %>!');
           * compiled({ 'user': 'fred' });
           * // => 'hello fred!'
           *
           * // using the HTML "escape" delimiter to escape data property values
           * var compiled = _.template('<b><%- value %></b>');
           * compiled({ 'value': '<script>' });
           * // => '<b>&lt;script&gt;</b>'
           *
           * // using the "evaluate" delimiter to execute JavaScript and generate HTML
           * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
           * compiled({ 'users': ['fred', 'barney'] });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // using the internal `print` function in "evaluate" delimiters
           * var compiled = _.template('<% print("hello " + user); %>!');
           * compiled({ 'user': 'barney' });
           * // => 'hello barney!'
           *
           * // using the ES delimiter as an alternative to the default "interpolate" delimiter
           * var compiled = _.template('hello ${ user }!');
           * compiled({ 'user': 'pebbles' });
           * // => 'hello pebbles!'
           *
           * // using custom template delimiters
           * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
           * var compiled = _.template('hello {{ user }}!');
           * compiled({ 'user': 'mustache' });
           * // => 'hello mustache!'
           *
           * // using backslashes to treat delimiters as plain text
           * var compiled = _.template('<%= "\\<%- value %\\>" %>');
           * compiled({ 'value': 'ignored' });
           * // => '<%- value %>'
           *
           * // using the `imports` option to import `jQuery` as `jq`
           * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
           * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
           * compiled({ 'users': ['fred', 'barney'] });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // using the `sourceURL` option to specify a custom sourceURL for the template
           * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
           * compiled(data);
           * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
           *
           * // using the `variable` option to ensure a with-statement isn't used in the compiled template
           * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
           * compiled.source;
           * // => function(data) {
           * //   var __t, __p = '';
           * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
           * //   return __p;
           * // }
           *
           * // using the `source` property to inline compiled templates for meaningful
           * // line numbers in error messages and a stack trace
           * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
           *   var JST = {\
           *     "main": ' + _.template(mainText).source + '\
           *   };\
           * ');
           */
          function template(string, options, otherOptions) {
            // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
            // and Laura Doktorova's doT.js (https://github.com/olado/doT).
            var settings = lodash.templateSettings;

            if (otherOptions && isIterateeCall(string, options, otherOptions)) {
              options = otherOptions = undefined;
            }
            string = baseToString(string);
            options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

            var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);

            var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";

            // Compile the regexp to match each delimiter.
            var reDelimiters = RegExp(
              (options.escape || reNoMatch).source + '|' +
              interpolate.source + '|' +
              (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
              (options.evaluate || reNoMatch).source + '|$'
              , 'g');

            // Use a sourceURL for easier debugging.
            var sourceURL = '//# sourceURL=' +
              ('sourceURL' in options
                ? options.sourceURL
                : ('lodash.templateSources[' + (++templateCounter) + ']')
              ) + '\n';

            string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);

              // Escape characters that can't be included in string literals.
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

              // Replace delimiters with snippets.
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;

              // The JS engine embedded in Adobe products requires returning the `match`
              // string in order to produce the correct `offset` value.
              return match;
            });

            source += "';\n";

            // If `variable` is not specified wrap a with-statement around the generated
            // code to add the data object to the top of the scope chain.
            var variable = options.variable;
            if (!variable) {
              source = 'with (obj) {\n' + source + '\n}\n';
            }
            // Cleanup code by stripping empty strings.
            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
              .replace(reEmptyStringMiddle, '$1')
              .replace(reEmptyStringTrailing, '$1;');

            // Frame code as the function body.
            source = 'function(' + (variable || 'obj') + ') {\n' +
              (variable
                ? ''
                : 'obj || (obj = {});\n'
              ) +
              "var __t, __p = ''" +
              (isEscaping
                ? ', __e = _.escape'
                : ''
              ) +
              (isEvaluating
                ? ', __j = Array.prototype.join;\n' +
                "function print() { __p += __j.call(arguments, '') }\n"
                : ';\n'
              ) +
              source +
              'return __p\n}';

            var result = attempt(function () {
              return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
            });

            // Provide the compiled function's source by its `toString` method or
            // the `source` property as a convenience for inlining compiled templates.
            result.source = source;
            if (isError(result)) {
              throw result;
            }
            return result;
          }

          /**
           * Removes leading and trailing whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trim('  abc  ');
           * // => 'abc'
           *
           * _.trim('-_-abc-_-', '_-');
           * // => 'abc'
           *
           * _.map(['  foo  ', '  bar  '], _.trim);
           * // => ['foo', 'bar']
           */
          function trim(string, chars, guard) {
            var value = string;
            string = baseToString(string);
            if (!string) {
              return string;
            }
            if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
              return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
            }
            chars = (chars + '');
            return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
          }

          /**
           * Removes leading whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trimLeft('  abc  ');
           * // => 'abc  '
           *
           * _.trimLeft('-_-abc-_-', '_-');
           * // => 'abc-_-'
           */
          function trimLeft(string, chars, guard) {
            var value = string;
            string = baseToString(string);
            if (!string) {
              return string;
            }
            if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
              return string.slice(trimmedLeftIndex(string));
            }
            return string.slice(charsLeftIndex(string, (chars + '')));
          }

          /**
           * Removes trailing whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trimRight('  abc  ');
           * // => '  abc'
           *
           * _.trimRight('-_-abc-_-', '_-');
           * // => '-_-abc'
           */
          function trimRight(string, chars, guard) {
            var value = string;
            string = baseToString(string);
            if (!string) {
              return string;
            }
            if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
              return string.slice(0, trimmedRightIndex(string) + 1);
            }
            return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
          }

          /**
           * Truncates `string` if it's longer than the given maximum string length.
           * The last characters of the truncated string are replaced with the omission
           * string which defaults to "...".
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to truncate.
           * @param {Object|number} [options] The options object or maximum string length.
           * @param {number} [options.length=30] The maximum string length.
           * @param {string} [options.omission='...'] The string to indicate text is omitted.
           * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {string} Returns the truncated string.
           * @example
           *
           * _.trunc('hi-diddly-ho there, neighborino');
           * // => 'hi-diddly-ho there, neighbo...'
           *
           * _.trunc('hi-diddly-ho there, neighborino', 24);
           * // => 'hi-diddly-ho there, n...'
           *
           * _.trunc('hi-diddly-ho there, neighborino', {
           *   'length': 24,
           *   'separator': ' '
           * });
           * // => 'hi-diddly-ho there,...'
           *
           * _.trunc('hi-diddly-ho there, neighborino', {
           *   'length': 24,
           *   'separator': /,? +/
           * });
           * // => 'hi-diddly-ho there...'
           *
           * _.trunc('hi-diddly-ho there, neighborino', {
           *   'omission': ' [...]'
           * });
           * // => 'hi-diddly-ho there, neig [...]'
           */
          function trunc(string, options, guard) {
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined;
            }
            var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;

            if (options != null) {
              if (isObject(options)) {
                var separator = 'separator' in options ? options.separator : separator;
                length = 'length' in options ? (+options.length || 0) : length;
                omission = 'omission' in options ? baseToString(options.omission) : omission;
              } else {
                length = +options || 0;
              }
            }
            string = baseToString(string);
            if (length >= string.length) {
              return string;
            }
            var end = length - omission.length;
            if (end < 1) {
              return omission;
            }
            var result = string.slice(0, end);
            if (separator == null) {
              return result + omission;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match,
                  newEnd,
                  substring = string.slice(0, end);

                if (!separator.global) {
                  separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
                }
                separator.lastIndex = 0;
                while ((match = separator.exec(substring))) {
                  newEnd = match.index;
                }
                result = result.slice(0, newEnd == null ? end : newEnd);
              }
            } else if (string.indexOf(separator, end) != end) {
              var index = result.lastIndexOf(separator);
              if (index > -1) {
                result = result.slice(0, index);
              }
            }
            return result + omission;
          }

          /**
           * The inverse of `_.escape`; this method converts the HTML entities
           * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
           * corresponding characters.
           *
           * **Note:** No other HTML entities are unescaped. To unescape additional HTML
           * entities use a third-party library like [_he_](https://mths.be/he).
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to unescape.
           * @returns {string} Returns the unescaped string.
           * @example
           *
           * _.unescape('fred, barney, &amp; pebbles');
           * // => 'fred, barney, & pebbles'
           */
          function unescape(string) {
            string = baseToString(string);
            return (string && reHasEscapedHtml.test(string))
              ? string.replace(reEscapedHtml, unescapeHtmlChar)
              : string;
          }

          /**
           * Splits `string` into an array of its words.
           *
           * @static
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to inspect.
           * @param {RegExp|string} [pattern] The pattern to match words.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Array} Returns the words of `string`.
           * @example
           *
           * _.words('fred, barney, & pebbles');
           * // => ['fred', 'barney', 'pebbles']
           *
           * _.words('fred, barney, & pebbles', /[^, ]+/g);
           * // => ['fred', 'barney', '&', 'pebbles']
           */
          function words(string, pattern, guard) {
            if (guard && isIterateeCall(string, pattern, guard)) {
              pattern = undefined;
            }
            string = baseToString(string);
            return string.match(pattern || reWords) || [];
          }

          /*------------------------------------------------------------------------*/

          /**
           * Attempts to invoke `func`, returning either the result or the caught error
           * object. Any additional arguments are provided to `func` when it is invoked.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Function} func The function to attempt.
           * @returns {*} Returns the `func` result or error object.
           * @example
           *
           * // avoid throwing errors for invalid selectors
           * var elements = _.attempt(function(selector) {
           *   return document.querySelectorAll(selector);
           * }, '>_>');
           *
           * if (_.isError(elements)) {
           *   elements = [];
           * }
           */
          var attempt = restParam(function (func, args) {
            try {
              return func.apply(undefined, args);
            } catch (e) {
              return isError(e) ? e : new Error(e);
            }
          });

          /**
           * Creates a function that invokes `func` with the `this` binding of `thisArg`
           * and arguments of the created function. If `func` is a property name the
           * created callback returns the property value for a given element. If `func`
           * is an object the created callback returns `true` for elements that contain
           * the equivalent object properties, otherwise it returns `false`.
           *
           * @static
           * @memberOf _
           * @alias iteratee
           * @category Utility
           * @param {*} [func=_.identity] The value to convert to a callback.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
           * @returns {Function} Returns the callback.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 40 }
           * ];
           *
           * // wrap to create custom callback shorthands
           * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
           *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
           *   if (!match) {
           *     return callback(func, thisArg);
           *   }
           *   return function(object) {
           *     return match[2] == 'gt'
           *       ? object[match[1]] > match[3]
           *       : object[match[1]] < match[3];
           *   };
           * });
           *
           * _.filter(users, 'age__gt36');
           * // => [{ 'user': 'fred', 'age': 40 }]
           */
          function callback(func, thisArg, guard) {
            if (guard && isIterateeCall(func, thisArg, guard)) {
              thisArg = undefined;
            }
            return isObjectLike(func)
              ? matches(func)
              : baseCallback(func, thisArg);
          }

          /**
           * Creates a function that returns `value`.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {*} value The value to return from the new function.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var object = { 'user': 'fred' };
           * var getter = _.constant(object);
           *
           * getter() === object;
           * // => true
           */
          function constant(value) {
            return function () {
              return value;
            };
          }

          /**
           * This method returns the first argument provided to it.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {*} value Any value.
           * @returns {*} Returns `value`.
           * @example
           *
           * var object = { 'user': 'fred' };
           *
           * _.identity(object) === object;
           * // => true
           */
          function identity(value) {
            return value;
          }

          /**
           * Creates a function that performs a deep comparison between a given object
           * and `source`, returning `true` if the given object has equivalent property
           * values, else `false`.
           *
           * **Note:** This method supports comparing arrays, booleans, `Date` objects,
           * numbers, `Object` objects, regexes, and strings. Objects are compared by
           * their own, not inherited, enumerable properties. For comparing a single
           * own or inherited property value see `_.matchesProperty`.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Object} source The object of property values to match.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': true },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * _.filter(users, _.matches({ 'age': 40, 'active': false }));
           * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
           */
          function matches(source) {
            return baseMatches(baseClone(source, true));
          }

          /**
           * Creates a function that compares the property value of `path` on a given
           * object to `value`.
           *
           * **Note:** This method supports comparing arrays, booleans, `Date` objects,
           * numbers, `Object` objects, regexes, and strings. Objects are compared by
           * their own, not inherited, enumerable properties.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Array|string} path The path of the property to get.
           * @param {*} srcValue The value to match.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var users = [
           *   { 'user': 'barney' },
           *   { 'user': 'fred' }
           * ];
           *
           * _.find(users, _.matchesProperty('user', 'fred'));
           * // => { 'user': 'fred' }
           */
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, true));
          }

          /**
           * Creates a function that invokes the method at `path` on a given object.
           * Any additional arguments are provided to the invoked method.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Array|string} path The path of the method to invoke.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var objects = [
           *   { 'a': { 'b': { 'c': _.constant(2) } } },
           *   { 'a': { 'b': { 'c': _.constant(1) } } }
           * ];
           *
           * _.map(objects, _.method('a.b.c'));
           * // => [2, 1]
           *
           * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
           * // => [1, 2]
           */
          var method = restParam(function (path, args) {
            return function (object) {
              return invokePath(object, path, args);
            };
          });

          /**
           * The opposite of `_.method`; this method creates a function that invokes
           * the method at a given path on `object`. Any additional arguments are
           * provided to the invoked method.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Object} object The object to query.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var array = _.times(3, _.constant),
           *     object = { 'a': array, 'b': array, 'c': array };
           *
           * _.map(['a[2]', 'c[0]'], _.methodOf(object));
           * // => [2, 0]
           *
           * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
           * // => [2, 0]
           */
          var methodOf = restParam(function (object, args) {
            return function (path) {
              return invokePath(object, path, args);
            };
          });

          /**
           * Adds all own enumerable function properties of a source object to the
           * destination object. If `object` is a function then methods are added to
           * its prototype as well.
           *
           * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
           * avoid conflicts caused by modifying the original.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Function|Object} [object=lodash] The destination object.
           * @param {Object} source The object of functions to add.
           * @param {Object} [options] The options object.
           * @param {boolean} [options.chain=true] Specify whether the functions added
           *  are chainable.
           * @returns {Function|Object} Returns `object`.
           * @example
           *
           * function vowels(string) {
           *   return _.filter(string, function(v) {
           *     return /[aeiou]/i.test(v);
           *   });
           * }
           *
           * _.mixin({ 'vowels': vowels });
           * _.vowels('fred');
           * // => ['e']
           *
           * _('fred').vowels().value();
           * // => ['e']
           *
           * _.mixin({ 'vowels': vowels }, { 'chain': false });
           * _('fred').vowels();
           * // => ['e']
           */
          function mixin(object, source, options) {
            if (options == null) {
              var isObj = isObject(source),
                props = isObj ? keys(source) : undefined,
                methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

              if (!(methodNames ? methodNames.length : isObj)) {
                methodNames = false;
                options = source;
                source = object;
                object = this;
              }
            }
            if (!methodNames) {
              methodNames = baseFunctions(source, keys(source));
            }
            var chain = true,
              index = -1,
              isFunc = isFunction(object),
              length = methodNames.length;

            if (options === false) {
              chain = false;
            } else if (isObject(options) && 'chain' in options) {
              chain = options.chain;
            }
            while (++index < length) {
              var methodName = methodNames[index],
                func = source[methodName];

              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = (function (func) {
                  return function () {
                    var chainAll = this.__chain__;
                    if (chain || chainAll) {
                      var result = object(this.__wrapped__),
                        actions = result.__actions__ = arrayCopy(this.__actions__);

                      actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                      result.__chain__ = chainAll;
                      return result;
                    }
                    return func.apply(object, arrayPush([this.value()], arguments));
                  };
                }(func));
              }
            }
            return object;
          }

          /**
           * Reverts the `_` variable to its previous value and returns a reference to
           * the `lodash` function.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @returns {Function} Returns the `lodash` function.
           * @example
           *
           * var lodash = _.noConflict();
           */
          function noConflict() {
            root._ = oldDash;
            return this;
          }

          /**
           * A no-operation function that returns `undefined` regardless of the
           * arguments it receives.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @example
           *
           * var object = { 'user': 'fred' };
           *
           * _.noop(object) === undefined;
           * // => true
           */
          function noop() {
            // No operation performed.
          }

          /**
           * Creates a function that returns the property value at `path` on a
           * given object.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Array|string} path The path of the property to get.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var objects = [
           *   { 'a': { 'b': { 'c': 2 } } },
           *   { 'a': { 'b': { 'c': 1 } } }
           * ];
           *
           * _.map(objects, _.property('a.b.c'));
           * // => [2, 1]
           *
           * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
           * // => [1, 2]
           */
          function property(path) {
            return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
          }

          /**
           * The opposite of `_.property`; this method creates a function that returns
           * the property value at a given path on `object`.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {Object} object The object to query.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var array = [0, 1, 2],
           *     object = { 'a': array, 'b': array, 'c': array };
           *
           * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
           * // => [2, 0]
           *
           * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
           * // => [2, 0]
           */
          function propertyOf(object) {
            return function (path) {
              return baseGet(object, toPath(path), path + '');
            };
          }

          /**
           * Creates an array of numbers (positive and/or negative) progressing from
           * `start` up to, but not including, `end`. If `end` is not specified it is
           * set to `start` with `start` then set to `0`. If `end` is less than `start`
           * a zero-length range is created unless a negative `step` is specified.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @param {number} [step=1] The value to increment or decrement by.
           * @returns {Array} Returns the new array of numbers.
           * @example
           *
           * _.range(4);
           * // => [0, 1, 2, 3]
           *
           * _.range(1, 5);
           * // => [1, 2, 3, 4]
           *
           * _.range(0, 20, 5);
           * // => [0, 5, 10, 15]
           *
           * _.range(0, -4, -1);
           * // => [0, -1, -2, -3]
           *
           * _.range(1, 4, 0);
           * // => [1, 1, 1]
           *
           * _.range(0);
           * // => []
           */
          function range(start, end, step) {
            if (step && isIterateeCall(start, end, step)) {
              end = step = undefined;
            }
            start = +start || 0;
            step = step == null ? 1 : (+step || 0);

            if (end == null) {
              end = start;
              start = 0;
            } else {
              end = +end || 0;
            }
            // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
            // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
            var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);

            while (++index < length) {
              result[index] = start;
              start += step;
            }
            return result;
          }

          /**
           * Invokes the iteratee function `n` times, returning an array of the results
           * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
           * one argument; (index).
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {number} n The number of times to invoke `iteratee`.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {Array} Returns the array of results.
           * @example
           *
           * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
           * // => [3, 6, 4]
           *
           * _.times(3, function(n) {
           *   mage.castSpell(n);
           * });
           * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
           *
           * _.times(3, function(n) {
           *   this.cast(n);
           * }, mage);
           * // => also invokes `mage.castSpell(n)` three times
           */
          function times(n, iteratee, thisArg) {
            n = nativeFloor(n);

            // Exit early to avoid a JSC JIT bug in Safari 8
            // where `Array(0)` is treated as `Array(1)`.
            if (n < 1 || !nativeIsFinite(n)) {
              return [];
            }
            var index = -1,
              result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

            iteratee = bindCallback(iteratee, thisArg, 1);
            while (++index < n) {
              if (index < MAX_ARRAY_LENGTH) {
                result[index] = iteratee(index);
              } else {
                iteratee(index);
              }
            }
            return result;
          }

          /**
           * Generates a unique ID. If `prefix` is provided the ID is appended to it.
           *
           * @static
           * @memberOf _
           * @category Utility
           * @param {string} [prefix] The value to prefix the ID with.
           * @returns {string} Returns the unique ID.
           * @example
           *
           * _.uniqueId('contact_');
           * // => 'contact_104'
           *
           * _.uniqueId();
           * // => '105'
           */
          function uniqueId(prefix) {
            var id = ++idCounter;
            return baseToString(prefix) + id;
          }

          /*------------------------------------------------------------------------*/

          /**
           * Adds two numbers.
           *
           * @static
           * @memberOf _
           * @category Math
           * @param {number} augend The first number to add.
           * @param {number} addend The second number to add.
           * @returns {number} Returns the sum.
           * @example
           *
           * _.add(6, 4);
           * // => 10
           */
          function add(augend, addend) {
            return (+augend || 0) + (+addend || 0);
          }

          /**
           * Calculates `n` rounded up to `precision`.
           *
           * @static
           * @memberOf _
           * @category Math
           * @param {number} n The number to round up.
           * @param {number} [precision=0] The precision to round up to.
           * @returns {number} Returns the rounded up number.
           * @example
           *
           * _.ceil(4.006);
           * // => 5
           *
           * _.ceil(6.004, 2);
           * // => 6.01
           *
           * _.ceil(6040, -2);
           * // => 6100
           */
          var ceil = createRound('ceil');

          /**
           * Calculates `n` rounded down to `precision`.
           *
           * @static
           * @memberOf _
           * @category Math
           * @param {number} n The number to round down.
           * @param {number} [precision=0] The precision to round down to.
           * @returns {number} Returns the rounded down number.
           * @example
           *
           * _.floor(4.006);
           * // => 4
           *
           * _.floor(0.046, 2);
           * // => 0.04
           *
           * _.floor(4060, -2);
           * // => 4000
           */
          var floor = createRound('floor');

          /**
           * Gets the maximum value of `collection`. If `collection` is empty or falsey
           * `-Infinity` is returned. If an iteratee function is provided it is invoked
           * for each value in `collection` to generate the criterion by which the value
           * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
           * arguments: (value, index, collection).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Math
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {*} Returns the maximum value.
           * @example
           *
           * _.max([4, 2, 8, 6]);
           * // => 8
           *
           * _.max([]);
           * // => -Infinity
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 40 }
           * ];
           *
           * _.max(users, function(chr) {
           *   return chr.age;
           * });
           * // => { 'user': 'fred', 'age': 40 }
           *
           * // using the `_.property` callback shorthand
           * _.max(users, 'age');
           * // => { 'user': 'fred', 'age': 40 }
           */
          var max = createExtremum(gt, NEGATIVE_INFINITY);

          /**
           * Gets the minimum value of `collection`. If `collection` is empty or falsey
           * `Infinity` is returned. If an iteratee function is provided it is invoked
           * for each value in `collection` to generate the criterion by which the value
           * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
           * arguments: (value, index, collection).
           *
           * If a property name is provided for `iteratee` the created `_.property`
           * style callback returns the property value of the given element.
           *
           * If a value is also provided for `thisArg` the created `_.matchesProperty`
           * style callback returns `true` for elements that have a matching property
           * value, else `false`.
           *
           * If an object is provided for `iteratee` the created `_.matches` style
           * callback returns `true` for elements that have the properties of the given
           * object, else `false`.
           *
           * @static
           * @memberOf _
           * @category Math
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {*} Returns the minimum value.
           * @example
           *
           * _.min([4, 2, 8, 6]);
           * // => 2
           *
           * _.min([]);
           * // => Infinity
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 40 }
           * ];
           *
           * _.min(users, function(chr) {
           *   return chr.age;
           * });
           * // => { 'user': 'barney', 'age': 36 }
           *
           * // using the `_.property` callback shorthand
           * _.min(users, 'age');
           * // => { 'user': 'barney', 'age': 36 }
           */
          var min = createExtremum(lt, POSITIVE_INFINITY);

          /**
           * Calculates `n` rounded to `precision`.
           *
           * @static
           * @memberOf _
           * @category Math
           * @param {number} n The number to round.
           * @param {number} [precision=0] The precision to round to.
           * @returns {number} Returns the rounded number.
           * @example
           *
           * _.round(4.006);
           * // => 4
           *
           * _.round(4.006, 2);
           * // => 4.01
           *
           * _.round(4060, -2);
           * // => 4100
           */
          var round = createRound('round');

          /**
           * Gets the sum of the values in `collection`.
           *
           * @static
           * @memberOf _
           * @category Math
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [iteratee] The function invoked per iteration.
           * @param {*} [thisArg] The `this` binding of `iteratee`.
           * @returns {number} Returns the sum.
           * @example
           *
           * _.sum([4, 6]);
           * // => 10
           *
           * _.sum({ 'a': 4, 'b': 6 });
           * // => 10
           *
           * var objects = [
           *   { 'n': 4 },
           *   { 'n': 6 }
           * ];
           *
           * _.sum(objects, function(object) {
           *   return object.n;
           * });
           * // => 10
           *
           * // using the `_.property` callback shorthand
           * _.sum(objects, 'n');
           * // => 10
           */
          function sum(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = undefined;
            }
            iteratee = getCallback(iteratee, thisArg, 3);
            return iteratee.length == 1
              ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
              : baseSum(collection, iteratee);
          }

          /*------------------------------------------------------------------------*/

          // Ensure wrappers are instances of `baseLodash`.
          lodash.prototype = baseLodash.prototype;

          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;

          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;

          // Add functions to the `Map` cache.
          MapCache.prototype['delete'] = mapDelete;
          MapCache.prototype.get = mapGet;
          MapCache.prototype.has = mapHas;
          MapCache.prototype.set = mapSet;

          // Add functions to the `Set` cache.
          SetCache.prototype.push = cachePush;

          // Assign cache to `_.memoize`.
          memoize.Cache = MapCache;

          // Add functions that return wrapped values when chaining.
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.callback = callback;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.functions = functions;
          lodash.groupBy = groupBy;
          lodash.indexBy = indexBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.invert = invert;
          lodash.invoke = invoke;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.modArgs = modArgs;
          lodash.negate = negate;
          lodash.omit = omit;
          lodash.once = once;
          lodash.pairs = pairs;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pluck = pluck;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.restParam = restParam;
          lodash.set = set;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortByAll = sortByAll;
          lodash.sortByOrder = sortByOrder;
          lodash.spread = spread;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.times = times;
          lodash.toArray = toArray;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.union = union;
          lodash.uniq = uniq;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.where = where;
          lodash.without = without;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipWith = zipWith;

          // Add aliases.
          lodash.backflow = flowRight;
          lodash.collect = map;
          lodash.compose = flowRight;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.extend = assign;
          lodash.iteratee = callback;
          lodash.methods = functions;
          lodash.object = zipObject;
          lodash.select = filter;
          lodash.tail = rest;
          lodash.unique = uniq;

          // Add functions to `lodash.prototype`.
          mixin(lodash, lodash);

          /*------------------------------------------------------------------------*/

          // Add functions that return unwrapped values when chaining.
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.deburr = deburr;
          lodash.endsWith = endsWith;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.findWhere = findWhere;
          lodash.first = first;
          lodash.floor = floor;
          lodash.get = get;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isBoolean = isBoolean;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isError = isError;
          lodash.isFinite = isFinite;
          lodash.isFunction = isFunction;
          lodash.isMatch = isMatch;
          lodash.isNaN = isNaN;
          lodash.isNative = isNative;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isString = isString;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.min = min;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padLeft = padLeft;
          lodash.padRight = padRight;
          lodash.parseInt = parseInt;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.sum = sum;
          lodash.template = template;
          lodash.trim = trim;
          lodash.trimLeft = trimLeft;
          lodash.trimRight = trimRight;
          lodash.trunc = trunc;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.words = words;

          // Add aliases.
          lodash.all = every;
          lodash.any = some;
          lodash.contains = includes;
          lodash.eq = isEqual;
          lodash.detect = find;
          lodash.foldl = reduce;
          lodash.foldr = reduceRight;
          lodash.head = first;
          lodash.include = includes;
          lodash.inject = reduce;

          mixin(lodash, (function () {
            var source = {};
            baseForOwn(lodash, function (func, methodName) {
              if (!lodash.prototype[methodName]) {
                source[methodName] = func;
              }
            });
            return source;
          }()), false);

          /*------------------------------------------------------------------------*/

          // Add functions capable of returning wrapped and unwrapped values when chaining.
          lodash.sample = sample;

          lodash.prototype.sample = function (n) {
            if (!this.__chain__ && n == null) {
              return sample(this.value());
            }
            return this.thru(function (value) {
              return sample(value, n);
            });
          };

          /*------------------------------------------------------------------------*/

          /**
           * The semantic version number.
           *
           * @static
           * @memberOf _
           * @type string
           */
          lodash.VERSION = VERSION;

          // Assign default placeholders.
          arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
            lodash[methodName].placeholder = lodash;
          });

          // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
          arrayEach(['drop', 'take'], function (methodName, index) {
            LazyWrapper.prototype[methodName] = function (n) {
              var filtered = this.__filtered__;
              if (filtered && !index) {
                return new LazyWrapper(this);
              }
              n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

              var result = this.clone();
              if (filtered) {
                result.__takeCount__ = nativeMin(result.__takeCount__, n);
              } else {
                result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
              }
              return result;
            };

            LazyWrapper.prototype[methodName + 'Right'] = function (n) {
              return this.reverse()[methodName](n).reverse();
            };
          });

          // Add `LazyWrapper` methods that accept an `iteratee` value.
          arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
            var type = index + 1,
              isFilter = type != LAZY_MAP_FLAG;

            LazyWrapper.prototype[methodName] = function (iteratee, thisArg) {
              var result = this.clone();
              result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
              result.__filtered__ = result.__filtered__ || isFilter;
              return result;
            };
          });

          // Add `LazyWrapper` methods for `_.first` and `_.last`.
          arrayEach(['first', 'last'], function (methodName, index) {
            var takeName = 'take' + (index ? 'Right' : '');

            LazyWrapper.prototype[methodName] = function () {
              return this[takeName](1).value()[0];
            };
          });

          // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
          arrayEach(['initial', 'rest'], function (methodName, index) {
            var dropName = 'drop' + (index ? '' : 'Right');

            LazyWrapper.prototype[methodName] = function () {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });

          // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
          arrayEach(['pluck', 'where'], function (methodName, index) {
            var operationName = index ? 'filter' : 'map',
              createCallback = index ? baseMatches : property;

            LazyWrapper.prototype[methodName] = function (value) {
              return this[operationName](createCallback(value));
            };
          });

          LazyWrapper.prototype.compact = function () {
            return this.filter(identity);
          };

          LazyWrapper.prototype.reject = function (predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 1);
            return this.filter(function (value) {
              return !predicate(value);
            });
          };

          LazyWrapper.prototype.slice = function (start, end) {
            start = start == null ? 0 : (+start || 0);

            var result = this;
            if (result.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result);
            }
            if (start < 0) {
              result = result.takeRight(-start);
            } else if (start) {
              result = result.drop(start);
            }
            if (end !== undefined) {
              end = (+end || 0);
              result = end < 0 ? result.dropRight(-end) : result.take(end - start);
            }
            return result;
          };

          LazyWrapper.prototype.takeRightWhile = function (predicate, thisArg) {
            return this.reverse().takeWhile(predicate, thisArg).reverse();
          };

          LazyWrapper.prototype.toArray = function () {
            return this.take(POSITIVE_INFINITY);
          };

          // Add `LazyWrapper` methods to `lodash.prototype`.
          baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
              retUnwrapped = /^(?:first|last)$/.test(methodName),
              lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function () {
              var args = retUnwrapped ? [1] : arguments,
                chainAll = this.__chain__,
                value = this.__wrapped__,
                isHybrid = !!this.__actions__.length,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);

              if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                // Avoid lazy use if the iteratee has a "length" value other than `1`.
                isLazy = useLazy = false;
              }
              var interceptor = function (value) {
                return (retUnwrapped && chainAll)
                  ? lodashFunc(value, 1)[0]
                  : lodashFunc.apply(undefined, arrayPush([value], args));
              };

              var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
                onlyLazy = isLazy && !isHybrid;

              if (retUnwrapped && !chainAll) {
                if (onlyLazy) {
                  value = value.clone();
                  value.__actions__.push(action);
                  return func.call(value);
                }
                return lodashFunc.call(undefined, this.value())[0];
              }
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result = func.apply(value, args);
                result.__actions__.push(action);
                return new LodashWrapper(result, chainAll);
              }
              return this.thru(interceptor);
            };
          });

          // Add `Array` and `String` methods to `lodash.prototype`.
          arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function (methodName) {
            var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

            lodash.prototype[methodName] = function () {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                return func.apply(this.value(), args);
              }
              return this[chainName](function (value) {
                return func.apply(value, args);
              });
            };
          });

          // Map minified function names to their real names.
          baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name,
                names = realNames[key] || (realNames[key] = []);

              names.push({ 'name': methodName, 'func': lodashFunc });
            }
          });

          realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

          // Add functions to the lazy wrapper.
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;

          // Add chaining functions to the `lodash` wrapper.
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.concat = wrapperConcat;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toString = wrapperToString;
          lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

          // Add function aliases to the `lodash` wrapper.
          lodash.prototype.collect = lodash.prototype.map;
          lodash.prototype.head = lodash.prototype.first;
          lodash.prototype.select = lodash.prototype.filter;
          lodash.prototype.tail = lodash.prototype.rest;

          return lodash;
        }

        /*--------------------------------------------------------------------------*/

        // Export lodash.
        var _ = runInContext();

        // Some AMD build optimizers like r.js check for condition patterns like the following:
        if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
          // Expose lodash to the global object when an AMD loader is present to avoid
          // errors in cases where lodash is loaded by a script tag and not intended
          // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
          // more details.
          root._ = _;

          // Define as an anonymous module so, through path mapping, it can be
          // referenced as the "underscore" module.
          define(function () {
            return _;
          });
        }
        // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
        else if (freeExports && freeModule) {
          // Export for Node.js or RingoJS.
          if (moduleExports) {
            (freeModule.exports = _)._ = _;
          }
          // Export for Rhino with CommonJS support.
          else {
            freeExports._ = _;
          }
        }
        else {
          // Export for a browser or Rhino.
          root._ = _;
        }
      }.call(this));

    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, {}], 96: [function (require, module, exports) {
    module.exports = {
      "name": "blue-button",
      "version": "1.7.0-beta.1",
      "description": "Blue Button (CCDA, C32, CMS) to JSON Parser.",
      "main": "./index.js",
      "directories": {
        "doc": "doc",
        "lib": "lib"
      },
      "scripts": {
        "test": "grunt mocha"
      },
      "author": "Dmitry Kachaev <dmitry@amida-tech.com>",
      "contributors": [
        {
          "name": "Matthew McCall",
          "email": "matt@amida-tech.com"
        },
        {
          "name": "Afsin Ustundag",
          "email": "afsin.ustundag@us.pwc.com"
        },
        {
          "name": "Matt Martz",
          "email": "matt.martz@amida-tech.com"
        }
      ],
      "license": "Apache-2.0",
      "engines": {
        "node": ">= 0.10.0"
      },
      "dependencies": {
        "blue-button-cms": "~1.5.0",
        "blue-button-meta": "~1.5.0",
        "blue-button-model": "~1.5.0",
        "blue-button-xml": "^1.6.0-beta",
        "lodash": "^3.10.0",
        "winston": "~1.0.0"
      },
      "devDependencies": {
        "brfs": "~1.4.0",
        "chai": "~3.0.0",
        "coveralls": "~2.11.2",
        "grunt": "~0.4.5",
        "grunt-browserify": "~3.7.0",
        "grunt-contrib-connect": "~0.10.1",
        "grunt-contrib-jshint": "~0.11.2",
        "grunt-contrib-watch": "~0.6.1",
        "grunt-coveralls": "~1.0.0",
        "grunt-istanbul-coverage": "~0.1.1",
        "grunt-jsbeautifier": "~0.2.10",
        "grunt-mocha-phantomjs": "~2.0.0",
        "grunt-mocha-test": "~0.12.7",
        "grunt-shell": "^1.1.2",
        "mocha": "~2.2.4",
        "mocha-lcov-reporter": "~0.0.2"
      },
      "repository": {
        "type": "git",
        "url": "https://github.com/amida-tech/blue-button.git"
      },
      "keywords": [
        "bluebutton",
        "blue-button",
        "XML",
        "JSON",
        "CCDA",
        "CMS",
        "C32"
      ],
      "bugs": {
        "url": "https://github.com/amida-tech/blue-button/issues"
      },
      "homepage": "https://github.com/amida-tech/blue-button"
    }

  }, {}], "blue-button": [function (require, module, exports) {
    //main module that exports all other sub modules

    "use strict";

    // sense file type
    var sense = require("./lib/sense.js");
    exports.senseXml = sense.senseXml;
    exports.senseString = sense.senseString;

    // xml utilities
    exports.xml = require("@amida-tech/blue-button-xml").xmlUtil;

    // CCDA, C32, and CMS parser
    var parser = require("./lib/parser.js");
    exports.parseXml = parser.parseXml;
    exports.parseString = parser.parseString;
    exports.parseText = parser.parseText;
    exports.parse = parser.parse;

    // Data model schema validation
    exports.validator = require("@amida-tech/blue-button-model").validator;

  }, { "./lib/parser.js": 1, "./lib/sense.js": 44, "blue-button-model": 55, "blue-button-xml": "blue-button-xml" }]
}, {}, ["blue-button"]);
